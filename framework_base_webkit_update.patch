diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/AccessibilityInjector.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/AccessibilityInjector.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/AccessibilityInjector.java	2013-03-12 17:09:11.238011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/AccessibilityInjector.java	2013-03-12 17:03:37.000000000 +0100
@@ -18,9 +18,14 @@ package android.webkit;
 
 import android.content.Context;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.SystemClock;
 import android.provider.Settings;
 import android.speech.tts.TextToSpeech;
+import android.speech.tts.TextToSpeech.Engine;
+import android.speech.tts.TextToSpeech.OnInitListener;
+import android.speech.tts.UtteranceProgressListener;
+import android.util.Log;
 import android.view.KeyEvent;
 import android.view.View;
 import android.view.accessibility.AccessibilityManager;
@@ -34,6 +39,7 @@ import org.json.JSONObject;
 
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -43,6 +49,10 @@ import java.util.concurrent.atomic.Atomi
  * APIs.
  */
 class AccessibilityInjector {
+    private static final String TAG = AccessibilityInjector.class.getSimpleName();
+
+    private static boolean DEBUG = false;
+
     // The WebViewClassic this injector is responsible for managing.
     private final WebViewClassic mWebViewClassic;
 
@@ -53,7 +63,7 @@ class AccessibilityInjector {
     private final WebView mWebView;
 
     // The Java objects that are exposed to JavaScript.
-    private TextToSpeech mTextToSpeech;
+    private TextToSpeechWrapper mTextToSpeech;
     private CallbackHandler mCallback;
 
     // Lazily loaded helper objects.
@@ -87,7 +97,32 @@ class AccessibilityInjector {
 
     // Template for JavaScript that performs AndroidVox actions.
     private static final String ACCESSIBILITY_ANDROIDVOX_TEMPLATE =
-            "cvox.AndroidVox.performAction('%1s')";
+            "(function() {" +
+                    "  if ((typeof(cvox) != 'undefined')" +
+                    "      && (cvox != null)" +
+                    "      && (typeof(cvox.ChromeVox) != 'undefined')" +
+                    "      && (cvox.ChromeVox != null)" +
+                    "      && (typeof(cvox.AndroidVox) != 'undefined')" +
+                    "      && (cvox.AndroidVox != null)" +
+                    "      && cvox.ChromeVox.isActive) {" +
+                    "    return cvox.AndroidVox.performAction('%1s');" +
+                    "  } else {" +
+                    "    return false;" +
+                    "  }" +
+                    "})()";
+
+    // JS code used to shut down an active AndroidVox instance.
+    private static final String TOGGLE_CVOX_TEMPLATE =
+            "javascript:(function() {" +
+                    "  if ((typeof(cvox) != 'undefined')" +
+                    "      && (cvox != null)" +
+                    "      && (typeof(cvox.ChromeVox) != 'undefined')" +
+                    "      && (cvox.ChromeVox != null)" +
+                    "      && (typeof(cvox.ChromeVox.host) != 'undefined')" +
+                    "      && (cvox.ChromeVox.host != null)) {" +
+                    "    cvox.ChromeVox.host.activateOrDeactivateChromeVox(%b);" +
+                    "  }" +
+                    "})();";
 
     /**
      * Creates an instance of the AccessibilityInjector based on
@@ -104,10 +139,26 @@ class AccessibilityInjector {
     }
 
     /**
+     * If JavaScript is enabled, pauses or resumes AndroidVox.
+     *
+     * @param enabled Whether feedback should be enabled.
+     */
+    public void toggleAccessibilityFeedback(boolean enabled) {
+        if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {
+            return;
+        }
+
+        toggleAndroidVox(enabled);
+
+        if (!enabled && (mTextToSpeech != null)) {
+            mTextToSpeech.stop();
+        }
+    }
+
+    /**
      * Attempts to load scripting interfaces for accessibility.
      * <p>
-     * This should be called when the window is attached.
-     * </p>
+     * This should only be called before a page loads.
      */
     public void addAccessibilityApisIfNecessary() {
         if (!isAccessibilityEnabled() || !isJavaScriptEnabled()) {
@@ -121,15 +172,37 @@ class AccessibilityInjector {
     /**
      * Attempts to unload scripting interfaces for accessibility.
      * <p>
-     * This should be called when the window is detached.
-     * </p>
+     * This should only be called before a page loads.
      */
-    public void removeAccessibilityApisIfNecessary() {
+    private void removeAccessibilityApisIfNecessary() {
         removeTtsApis();
         removeCallbackApis();
     }
 
     /**
+     * Destroys this accessibility injector.
+     */
+    public void destroy() {
+        if (mTextToSpeech != null) {
+            mTextToSpeech.shutdown();
+            mTextToSpeech = null;
+        }
+
+        if (mCallback != null) {
+            mCallback = null;
+        }
+    }
+
+    private void toggleAndroidVox(boolean state) {
+        if (!mAccessibilityScriptInjected) {
+            return;
+        }
+
+        final String code = String.format(TOGGLE_CVOX_TEMPLATE, state);
+        mWebView.loadUrl(code);
+    }
+
+    /**
      * Initializes an {@link AccessibilityNodeInfo} with the actions and
      * movement granularity levels supported by this
      * {@link AccessibilityInjector}.
@@ -195,7 +268,7 @@ class AccessibilityInjector {
         if (mAccessibilityScriptInjected) {
             return sendActionToAndroidVox(action, arguments);
         }
-        
+
         if (mAccessibilityInjectorFallback != null) {
             return mAccessibilityInjectorFallback.performAccessibilityAction(action, arguments);
         }
@@ -261,6 +334,10 @@ class AccessibilityInjector {
      */
     public void onPageStarted(String url) {
         mAccessibilityScriptInjected = false;
+        if (DEBUG) {
+            Log.w(TAG, "[" + mWebView.hashCode() + "] Started loading new page");
+        }
+        addAccessibilityApisIfNecessary();
     }
 
     /**
@@ -273,22 +350,75 @@ class AccessibilityInjector {
      */
     public void onPageFinished(String url) {
         if (!isAccessibilityEnabled()) {
-            mAccessibilityScriptInjected = false;
             toggleFallbackAccessibilityInjector(false);
             return;
         }
 
-        if (!shouldInjectJavaScript(url)) {
-            toggleFallbackAccessibilityInjector(true);
-            return;
+        toggleFallbackAccessibilityInjector(true);
+
+        if (shouldInjectJavaScript(url)) {
+            // If we're supposed to use the JS screen reader, request a
+            // callback to confirm that CallbackHandler is working.
+            if (DEBUG) {
+                Log.d(TAG, "[" + mWebView.hashCode() + "] Request callback ");
+            }
+
+            mCallback.requestCallback(mWebView, mInjectScriptRunnable);
         }
+    }
 
+    /**
+     * Runnable used to inject the JavaScript-based screen reader if the
+     * {@link CallbackHandler} API was successfully exposed to JavaScript.
+     */
+    private Runnable mInjectScriptRunnable = new Runnable() {
+        @Override
+        public void run() {
+            if (DEBUG) {
+                Log.d(TAG, "[" + mWebView.hashCode() + "] Received callback");
+            }
+
+            injectJavaScript();
+        }
+    };
+
+    /**
+     * Called by {@link #mInjectScriptRunnable} to inject the JavaScript-based
+     * screen reader after confirming that the {@link CallbackHandler} API is
+     * functional.
+     */
+    private void injectJavaScript() {
         toggleFallbackAccessibilityInjector(false);
 
-        final String injectionUrl = getScreenReaderInjectionUrl();
-        mWebView.loadUrl(injectionUrl);
+        if (!mAccessibilityScriptInjected) {
+            mAccessibilityScriptInjected = true;
+            final String injectionUrl = getScreenReaderInjectionUrl();
+            mWebView.loadUrl(injectionUrl);
+            if (DEBUG) {
+                Log.d(TAG, "[" + mWebView.hashCode() + "] Loading screen reader into WebView");
+            }
+        } else {
+            if (DEBUG) {
+                Log.w(TAG, "[" + mWebView.hashCode() + "] Attempted to inject screen reader twice");
+            }
+        }
+    }
+
+    /**
+     * Adjusts the accessibility injection state to reflect changes in the
+     * JavaScript enabled state.
+     *
+     * @param enabled Whether JavaScript is enabled.
+     */
+    public void updateJavaScriptEnabled(boolean enabled) {
+        if (enabled) {
+            addAccessibilityApisIfNecessary();
+        } else {
+            removeAccessibilityApisIfNecessary();
+        }
 
-        mAccessibilityScriptInjected = true;
+        // We have to reload the page after adding or removing APIs.
+        mWebView.reload();
     }
 
     /**
@@ -346,13 +476,10 @@ class AccessibilityInjector {
      * been done.
      */
     private void addTtsApis() {
-        if (mTextToSpeech != null) {
-            return;
+        if (mTextToSpeech == null) {
+            mTextToSpeech = new TextToSpeechWrapper(mContext);
         }
 
-        final String pkgName = mContext.getPackageName();
-
-        mTextToSpeech = new TextToSpeech(mContext, null, null, pkgName + ".**webview**", true);
         mWebView.addJavascriptInterface(mTextToSpeech, ALIAS_TTS_JS_INTERFACE);
     }
 
@@ -361,32 +488,29 @@ class AccessibilityInjector {
      * already been done.
      */
     private void removeTtsApis() {
-        if (mTextToSpeech == null) {
-            return;
+        if (mTextToSpeech != null) {
+            mTextToSpeech.stop();
+            mTextToSpeech.shutdown();
+            mTextToSpeech = null;
         }
 
         mWebView.removeJavascriptInterface(ALIAS_TTS_JS_INTERFACE);
-        mTextToSpeech.stop();
-        mTextToSpeech.shutdown();
-        mTextToSpeech = null;
     }
 
     private void addCallbackApis() {
-        if (mCallback != null) {
-            return;
+        if (mCallback == null) {
+            mCallback = new CallbackHandler(ALIAS_TRAVERSAL_JS_INTERFACE);
         }
 
-        mCallback = new CallbackHandler(ALIAS_TRAVERSAL_JS_INTERFACE);
         mWebView.addJavascriptInterface(mCallback, ALIAS_TRAVERSAL_JS_INTERFACE);
     }
 
     private void removeCallbackApis() {
-        if (mCallback == null) {
-            return;
+        if (mCallback != null) {
+            mCallback = null;
         }
 
         mWebView.removeJavascriptInterface(ALIAS_TRAVERSAL_JS_INTERFACE);
-        mCallback = null;
     }
 
     /**
@@ -412,6 +536,8 @@ class AccessibilityInjector {
             }
         } catch (URISyntaxException e) {
             // Do nothing.
+        } catch (IllegalArgumentException e) {
+            // Catch badly-formed URLs.
         }
 
         return ACCESSIBILITY_SCRIPT_INJECTION_UNDEFINED;
@@ -448,7 +574,12 @@ class AccessibilityInjector {
      *         settings.
      */
     private boolean isJavaScriptEnabled() {
-        return mWebView.getSettings().getJavaScriptEnabled();
+        final WebSettings settings = mWebView.getSettings();
+        if (settings == null) {
+            return false;
+        }
+
+        return settings.getJavaScriptEnabled();
     }
 
     /**
@@ -508,6 +639,157 @@ class AccessibilityInjector {
     }
 
     /**
+     * Used to protect the TextToSpeech class, only exposing the methods we want to expose.
+     */
+    private static class TextToSpeechWrapper {
+        private static final String WRAP_TAG = TextToSpeechWrapper.class.getSimpleName();
+
+        private final HashMap<String, String> mTtsParams;
+        private final TextToSpeech mTextToSpeech;
+
+        /**
+         * Whether this wrapper is ready to speak. If this is {@code true} then
+         * {@link #mShutdown} is guaranteed to be {@code false}.
+         */
+        private volatile boolean mReady;
+
+        /**
+         * Whether this wrapper was shut down. If this is {@code true} then
+         * {@link #mReady} is guaranteed to be {@code false}.
+         */
+        private volatile boolean mShutdown;
+
+        public TextToSpeechWrapper(Context context) {
+            if (DEBUG) {
+                Log.d(WRAP_TAG, "[" + hashCode() + "] Initializing text-to-speech on thread "
+                        + Thread.currentThread().getId() + "...");
+            }
+
+            final String pkgName = context.getPackageName();
+
+            mReady = false;
+            mShutdown = false;
+
+            mTtsParams = new HashMap<String, String>();
+            mTtsParams.put(Engine.KEY_PARAM_UTTERANCE_ID, WRAP_TAG);
+
+            mTextToSpeech = new TextToSpeech(
+                    context, mInitListener, null, pkgName + ".**webview**", true);
+            mTextToSpeech.setOnUtteranceProgressListener(mErrorListener);
+        }
+
+        @JavascriptInterface
+        @SuppressWarnings("unused")
+        public boolean isSpeaking() {
+            synchronized (mTextToSpeech) {
+                if (!mReady) {
+                    return false;
+                }
+
+                return mTextToSpeech.isSpeaking();
+            }
+        }
+
+        @JavascriptInterface
+        @SuppressWarnings("unused")
+        public int speak(String text, int queueMode, HashMap<String, String> params) {
+            synchronized (mTextToSpeech) {
+                if (!mReady) {
+                    if (DEBUG) {
+                        Log.w(WRAP_TAG, "[" + hashCode() + "] Attempted to speak before TTS init");
+                    }
+                    return TextToSpeech.ERROR;
+                } else {
+                    if (DEBUG) {
+                        Log.i(WRAP_TAG, "[" + hashCode() + "] Speak called from JS binder");
+                    }
+                }
+
+                return mTextToSpeech.speak(text, queueMode, params);
+            }
+        }
+
+        @JavascriptInterface
+        @SuppressWarnings("unused")
+        public int stop() {
+            synchronized (mTextToSpeech) {
+                if (!mReady) {
+                    if (DEBUG) {
+                        Log.w(WRAP_TAG, "[" + hashCode() + "] Attempted to stop before initialize");
+                    }
+                    return TextToSpeech.ERROR;
+                } else {
+                    if (DEBUG) {
+                        Log.i(WRAP_TAG, "[" + hashCode() + "] Stop called from JS binder");
+                    }
+                }
+
+                return mTextToSpeech.stop();
+            }
+        }
+
+        @SuppressWarnings("unused")
+        protected void shutdown() {
+            synchronized (mTextToSpeech) {
+                if (!mReady) {
+                    if (DEBUG) {
+                        Log.w(WRAP_TAG, "[" + hashCode() + "] Called shutdown before initialize");
+                    }
+                } else {
+                    if (DEBUG) {
+                        Log.i(WRAP_TAG, "[" + hashCode() + "] Shutting down text-to-speech from "
+                                + "thread " + Thread.currentThread().getId() + "...");
+                    }
+                }
+                mShutdown = true;
+                mReady = false;
+                mTextToSpeech.shutdown();
+            }
+        }
+
+        private final OnInitListener mInitListener = new OnInitListener() {
+            @Override
+            public void onInit(int status) {
+                synchronized (mTextToSpeech) {
+                    if (!mShutdown && (status == TextToSpeech.SUCCESS)) {
+                        if (DEBUG) {
+                            Log.d(WRAP_TAG, "[" + TextToSpeechWrapper.this.hashCode()
+                                    + "] Initialized successfully");
+                        }
+                        mReady = true;
+                    } else {
+                        if (DEBUG) {
+                            Log.w(WRAP_TAG, "[" + TextToSpeechWrapper.this.hashCode()
+                                    + "] Failed to initialize");
+                        }
+                        mReady = false;
+                    }
+                }
+            }
+        };
+
+        private final UtteranceProgressListener mErrorListener = new UtteranceProgressListener() {
+            @Override
+            public void onStart(String utteranceId) {
+                // Do nothing.
+            }
+
+            @Override
+            public void onError(String utteranceId) {
+                if (DEBUG) {
+                    Log.w(WRAP_TAG, "[" + TextToSpeechWrapper.this.hashCode()
+                            + "] Failed to speak utterance");
+                }
+            }
+
+            @Override
+            public void onDone(String utteranceId) {
+                // Do nothing.
+            }
+        };
+    }
+
+    /**
      * Exposes result interface to JavaScript.
      */
     private static class CallbackHandler {
@@ -520,12 +802,16 @@ class AccessibilityInjector {
         private final AtomicInteger mResultIdCounter = new AtomicInteger();
         private final Object mResultLock = new Object();
         private final String mInterfaceName;
+        private final Handler mMainHandler;
+
+        private Runnable mCallbackRunnable;
 
         private boolean mResult = false;
-        private long mResultId = -1;
+        private int mResultId = -1;
 
         private CallbackHandler(String interfaceName) {
             mInterfaceName = interfaceName;
+            mMainHandler = new Handler();
         }
 
         /**
@@ -574,24 +860,53 @@ class AccessibilityInjector {
          * @return Whether the result was received.
          */
         private boolean waitForResultTimedLocked(int resultId) {
-            long waitTimeMillis = RESULT_TIMEOUT;
             final long startTimeMillis = SystemClock.uptimeMillis();
+
+            if (DEBUG) {
+                Log.d(TAG, "Waiting for CVOX result with ID " + resultId + "...");
+            }
+
             while (true) {
-                try {
-                    if (mResultId == resultId) {
-                        return true;
+                // Fail if we received a callback from the future.
+                if (mResultId > resultId) {
+                    if (DEBUG) {
+                        Log.w(TAG, "Aborted CVOX result");
+                    }
+                    return false;
+                }
+
+                final long elapsedTimeMillis = (SystemClock.uptimeMillis() - startTimeMillis);
+
+                // Succeed if we received the callback we were expecting.
+                if (DEBUG) {
+                    Log.w(TAG, "Check " + mResultId + " versus expected " + resultId);
+                }
+                if (mResultId == resultId) {
+                    if (DEBUG) {
+                        Log.w(TAG, "Received CVOX result after " + elapsedTimeMillis + " ms");
                     }
-                    if (mResultId > resultId) {
-                        return false;
+                    return true;
+                }
+
+                final long waitTimeMillis = (RESULT_TIMEOUT - elapsedTimeMillis);
+
+                // Fail if we've already exceeded the timeout.
+                if (waitTimeMillis <= 0) {
+                    if (DEBUG) {
+                        Log.w(TAG, "Timed out while waiting for CVOX result");
                     }
-                    final long elapsedTimeMillis = SystemClock.uptimeMillis() - startTimeMillis;
-                    waitTimeMillis = RESULT_TIMEOUT - elapsedTimeMillis;
-                    if (waitTimeMillis <= 0) {
-                        return false;
+                    return false;
+                }
+
+                try {
+                    if (DEBUG) {
+                        Log.w(TAG, "Start waiting...");
                     }
                     mResultLock.wait(waitTimeMillis);
                 } catch (InterruptedException ie) {
-                    /* ignore */
+                    if (DEBUG) {
+                        Log.w(TAG, "Interrupted while waiting for CVOX result");
+                    }
                 }
             }
         }
@@ -603,12 +918,16 @@ class AccessibilityInjector {
          * @param id The result id of the request as a {@link String}.
          * @param result The result of the request as a {@link String}.
          */
+        @JavascriptInterface
         @SuppressWarnings("unused")
         public void onResult(String id, String result) {
-            final long resultId;
+            if (DEBUG) {
+                Log.w(TAG, "Saw CVOX result of '" + result + "' for ID " + id);
+            }
+            final int resultId;
 
             try {
-                resultId = Long.parseLong(id);
+                resultId = Integer.parseInt(id);
             } catch (NumberFormatException e) {
                 return;
             }
@@ -617,9 +936,35 @@ class AccessibilityInjector {
                 if (resultId > mResultId) {
                     mResult = Boolean.parseBoolean(result);
                     mResultId = resultId;
+                } else {
+                    if (DEBUG) {
+                        Log.w(TAG, "Result with ID " + resultId + " was stale vesus " + mResultId);
+                    }
                 }
                 mResultLock.notifyAll();
             }
         }
+
+        /**
+         * Requests a callback to ensure that the JavaScript interface for this
+         * object has been added successfully.
+         *
+         * @param webView The web view to request a callback from.
+         * @param callbackRunnable Runnable to execute if a callback is received.
+         */
+        public void requestCallback(WebView webView, Runnable callbackRunnable) {
+            mCallbackRunnable = callbackRunnable;
+
+            webView.loadUrl("javascript:(function() { " + mInterfaceName + ".callback(); })();");
+        }
+
+        @JavascriptInterface
+        @SuppressWarnings("unused")
+        public void callback() {
+            if (mCallbackRunnable != null) {
+                mMainHandler.post(mCallbackRunnable);
+                mCallbackRunnable = null;
+            }
+        }
     }
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/BrowserDownloadListener.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/BrowserDownloadListener.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/BrowserDownloadListener.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/BrowserDownloadListener.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+/**
+ * An abstract download listener that allows passing extra information as
+ * part of onDownloadStart callback.
+ * @hide
+ */
+public abstract class BrowserDownloadListener implements DownloadListener {
+
+    /**
+     * Notify the host application that a file should be downloaded
+     * @param url The full url to the content that should be downloaded
+     * @param userAgent the user agent to be used for the download.
+     * @param contentDisposition Content-disposition http header, if
+     *                           present.
+     * @param mimetype The mimetype of the content reported by the server
+     * @param referer The referer associated with this url
+     * @param contentLength The file size reported by the server
+     */
+    public abstract void onDownloadStart(String url, String userAgent,
+            String contentDisposition, String mimetype, String referer,
+            long contentLength);
+
+
+    /**
+     * Notify the host application that a file should be downloaded
+     * @param url The full url to the content that should be downloaded
+     * @param userAgent the user agent to be used for the download.
+     * @param contentDisposition Content-disposition http header, if
+     *                           present.
+     * @param mimetype The mimetype of the content reported by the server
+     * @param contentLength The file size reported by the server
+     */
+    @Override
+    public void onDownloadStart(String url, String userAgent,
+            String contentDisposition, String mimetype, long contentLength) {
+
+        onDownloadStart(url, userAgent, contentDisposition, mimetype, null,
+                      contentLength);
+    }
+}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/BrowserFrame.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/BrowserFrame.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/BrowserFrame.java	2013-03-12 17:09:11.238011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/BrowserFrame.java	2013-03-12 17:03:37.000000000 +0100
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
- * Copyright (C) 2011, 2012 Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,7 +32,6 @@ import android.net.http.SslCertificate;
 import android.net.http.SslError;
 import android.os.Handler;
 import android.os.Message;
-import android.os.SystemProperties;
 import android.util.Log;
 import android.util.TypedValue;
 import android.view.Surface;
@@ -76,6 +74,7 @@ class BrowserFrame extends Handler {
     private final CallbackProxy mCallbackProxy;
     private final WebSettingsClassic mSettings;
     private final Context mContext;
+    private final WebViewDatabaseClassic mDatabase;
     private final WebViewCore mWebViewCore;
     /* package */ boolean mLoadInitFromJava;
     private int mLoadType;
@@ -90,16 +89,24 @@ class BrowserFrame extends Handler {
     // Is this frame the main frame?
     private boolean mIsMainFrame;
 
+    // Javascript interface object
+    private class JSObject {
+        Object object;
+        boolean requireAnnotation;
+
+        public JSObject(Object object, boolean requireAnnotation) {
+            this.object = object;
+            this.requireAnnotation = requireAnnotation;
+        }
+    }
+
     // Attached Javascript interfaces
-    private Map<String, Object> mJavaScriptObjects;
+    private Map<String, JSObject> mJavaScriptObjects;
     private Set<Object> mRemovedJavaScriptObjects;
 
     // Key store handler when Chromium HTTP stack is used.
     private KeyStoreHandler mKeyStoreHandler = null;
 
-    // Implementation of the searchbox API.
-    private final SearchBoxImpl mSearchBox;
-
     // message ids
     // a message posted when a frame loading is completed
     static final int FRAME_COMPLETED = 1001;
@@ -214,13 +221,11 @@ class BrowserFrame extends Handler {
             // set WebCore native cache size
             ActivityManager am = (ActivityManager) context
                     .getSystemService(Context.ACTIVITY_SERVICE);
-            int defCacheSize = am.getMemoryClass() > 16 ?
-                8 * 1024 * 1024 : 4 * 1024 * 1024;
-            int cacheSize = SystemProperties.getInt("net.webkit.cache.size", defCacheSize);
-            if ((cacheSize < 0) || (cacheSize > (100 * 1024 * 1024))) {
-                cacheSize = defCacheSize;
+            if (am.getMemoryClass() > 16) {
+                sJavaBridge.setCacheSize(8 * 1024 * 1024);
+            } else {
+                sJavaBridge.setCacheSize(4 * 1024 * 1024);
             }
-            sJavaBridge.setCacheSize(cacheSize);
             // initialize CacheManager
             CacheManager.init(appContext);
             // create CookieSyncManager with current Context
@@ -237,20 +242,16 @@ class BrowserFrame extends Handler {
         }
         sConfigCallback.addHandler(this);
 
-        mJavaScriptObjects = javascriptInterfaces;
-        if (mJavaScriptObjects == null) {
-            mJavaScriptObjects = new HashMap<String, Object>();
-        }
+        mJavaScriptObjects = new HashMap<String, JSObject>();
+        addJavaScriptObjects(javascriptInterfaces);
         mRemovedJavaScriptObjects = new HashSet<Object>();
 
         mSettings = settings;
         mContext = context;
         mCallbackProxy = proxy;
+        mDatabase = WebViewDatabaseClassic.getInstance(appContext);
         mWebViewCore = w;
 
-        mSearchBox = new SearchBoxImpl(mWebViewCore, mCallbackProxy);
-        mJavaScriptObjects.put(SearchBoxImpl.JS_INTERFACE_NAME, mSearchBox);
-
         AssetManager am = context.getAssets();
         nativeCreateFrame(w, am, proxy.getBackForwardList());
 
@@ -428,8 +429,7 @@ class BrowserFrame extends Handler {
             if (h != null) {
                 String url = WebTextView.urlForAutoCompleteData(h.getUrl());
                 if (url != null) {
-                    WebViewDatabaseClassic.getInstance(mContext).setFormData(
-                            url, data);
+                    mDatabase.setFormData(url, data);
                 }
             }
         }
@@ -501,9 +501,8 @@ class BrowserFrame extends Handler {
                     if (item != null) {
                         WebAddress uri = new WebAddress(item.getUrl());
                         String schemePlusHost = uri.getScheme() + uri.getHost();
-                        String[] up =
-                                WebViewDatabaseClassic.getInstance(mContext)
-                                        .getUsernamePassword(schemePlusHost);
+                        String[] up = mDatabase.getUsernamePassword(
+                                schemePlusHost);
                         if (up != null && up[0] != null) {
                             setUsernamePassword(up[0], up[1]);
                         }
@@ -595,15 +594,34 @@ class BrowserFrame extends Handler {
         Iterator<String> iter = mJavaScriptObjects.keySet().iterator();
         while (iter.hasNext())  {
             String interfaceName = iter.next();
-            Object object = mJavaScriptObjects.get(interfaceName);
-            if (object != null) {
+            JSObject jsobject = mJavaScriptObjects.get(interfaceName);
+            if (jsobject != null && jsobject.object != null) {
                 nativeAddJavascriptInterface(nativeFramePointer,
-                        mJavaScriptObjects.get(interfaceName), interfaceName);
+                        jsobject.object, interfaceName, jsobject.requireAnnotation);
             }
         }
         mRemovedJavaScriptObjects.clear();
+    }
 
-        stringByEvaluatingJavaScriptFromString(SearchBoxImpl.JS_BRIDGE);
+    /*
+     * Add javascript objects to the internal list of objects. The default behavior
+     * is to allow access to inherited methods (no annotation needed). This is only
+     * used when js objects are passed through a constructor (via a hidden constructor).
+     *
+     * @TODO change the default behavior to be compatible with the public addjavascriptinterface
+     */
+    private void addJavaScriptObjects(Map<String, Object> javascriptInterfaces) {
+
+        // TODO in a separate CL provide logic to enable annotations for API level JB_MR1 and above.
+        if (javascriptInterfaces == null) return;
+        Iterator<String> iter = javascriptInterfaces.keySet().iterator();
+        while (iter.hasNext())  {
+            String interfaceName = iter.next();
+            Object object = javascriptInterfaces.get(interfaceName);
+            if (object != null) {
+                mJavaScriptObjects.put(interfaceName, new JSObject(object, false));
+            }
+        }
     }
 
     /**
@@ -623,11 +641,11 @@ class BrowserFrame extends Handler {
         }
     }
 
-    public void addJavascriptInterface(Object obj, String interfaceName) {
+    public void addJavascriptInterface(Object obj, String interfaceName,
+            boolean requireAnnotation) {
         assert obj != null;
         removeJavascriptInterface(interfaceName);
-
-        mJavaScriptObjects.put(interfaceName, obj);
+        mJavaScriptObjects.put(interfaceName, new JSObject(obj, requireAnnotation));
     }
 
     public void removeJavascriptInterface(String interfaceName) {
@@ -804,10 +822,10 @@ class BrowserFrame extends Handler {
             // the post data (there could be another form on the
             // page and that was posted instead.
             String postString = new String(postData);
-            WebViewDatabaseClassic db = WebViewDatabaseClassic.getInstance(mContext);
             if (postString.contains(URLEncoder.encode(username)) &&
                     postString.contains(URLEncoder.encode(password))) {
-                String[] saved = db.getUsernamePassword(schemePlusHost);
+                String[] saved = mDatabase.getUsernamePassword(
+                        schemePlusHost);
                 if (saved != null) {
                     // null username implies that user has chosen not to
                     // save password
@@ -815,8 +833,7 @@ class BrowserFrame extends Handler {
                         // non-null username implies that user has
                         // chosen to save password, so update the
                         // recorded password
-                        db.setUsernamePassword(schemePlusHost, username,
-                                password);
+                        mDatabase.setUsernamePassword(schemePlusHost, username, password);
                     }
                 } else {
                     // CallbackProxy will handle creating the resume
@@ -1008,7 +1025,7 @@ class BrowserFrame extends Handler {
     }
 
     private float density() {
-        return mContext.getResources().getDisplayMetrics().density;
+        return WebViewCore.getFixedDisplayDensity(mContext);
     }
 
     /**
@@ -1142,7 +1159,7 @@ class BrowserFrame extends Handler {
      * DownloadListener.
      */
     private void downloadStart(String url, String userAgent,
-            String contentDisposition, String mimeType, long contentLength) {
+            String contentDisposition, String mimeType, String referer, long contentLength) {
         // This will only work if the url ends with the filename
         if (mimeType.isEmpty()) {
             try {
@@ -1162,7 +1179,7 @@ class BrowserFrame extends Handler {
             mKeyStoreHandler = new KeyStoreHandler(mimeType);
         } else {
             mCallbackProxy.onDownloadStart(url, userAgent,
-                contentDisposition, mimeType, contentLength);
+                contentDisposition, mimeType, referer, contentLength);
         }
     }
 
@@ -1195,10 +1212,6 @@ class BrowserFrame extends Handler {
         }
     }
 
-    /*package*/ SearchBox getSearchBox() {
-        return mSearchBox;
-    }
-
     /**
      * Called by JNI when processing the X-Auto-Login header.
      */
@@ -1253,7 +1266,7 @@ class BrowserFrame extends Handler {
      * Add a javascript interface to the main frame.
      */
     private native void nativeAddJavascriptInterface(int nativeFramePointer,
-            Object obj, String interfaceName);
+            Object obj, String interfaceName, boolean requireAnnotation);
 
     public native void clearCache();
 
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/CacheManager.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CacheManager.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/CacheManager.java	2013-03-12 17:09:11.238011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CacheManager.java	2013-03-12 17:03:37.000000000 +0100
@@ -32,6 +32,7 @@ import java.util.Map;
 /**
  * Manages the HTTP cache used by an application's {@link WebView} instances.
  * @deprecated Access to the HTTP cache will be removed in a future release.
+ * @hide Since {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
  */
 // The class CacheManager provides the persistent cache of content that is
 // received over the network. The component handles parsing of HTTP headers and
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/CallbackProxy.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CallbackProxy.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/CallbackProxy.java	2013-03-12 17:09:11.242011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CallbackProxy.java	2013-03-12 17:03:37.000000000 +0100
@@ -71,7 +71,7 @@ class CallbackProxy extends Handler {
     // Start with 100 to indicate it is not in load for the empty page.
     private volatile int mLatestProgress = 100;
     // Back/Forward list
-    private final WebBackForwardList mBackForwardList;
+    private final WebBackForwardListClassic mBackForwardList;
     // Back/Forward list client
     private volatile WebBackForwardListClient mWebBackForwardListClient;
     // Used to call startActivity during url override.
@@ -117,12 +117,8 @@ class CallbackProxy extends Handler {
     private static final int ADD_HISTORY_ITEM                     = 135;
     private static final int HISTORY_INDEX_CHANGED                = 136;
     private static final int AUTH_CREDENTIALS                     = 137;
-    private static final int SET_INSTALLABLE_WEBAPP               = 138;
-    private static final int NOTIFY_SEARCHBOX_LISTENERS           = 139;
     private static final int AUTO_LOGIN                           = 140;
     private static final int CLIENT_CERT_REQUEST                  = 141;
-    private static final int SEARCHBOX_IS_SUPPORTED_CALLBACK      = 142;
-    private static final int SEARCHBOX_DISPATCH_COMPLETE_CALLBACK = 143;
     private static final int PROCEEDED_AFTER_SSL_ERROR            = 144;
 
     // Message triggered by the client to resume execution
@@ -188,7 +184,7 @@ class CallbackProxy extends Handler {
         // Used to start a default activity.
         mContext = context;
         mWebView = w;
-        mBackForwardList = new WebBackForwardList(this);
+        mBackForwardList = new WebBackForwardListClassic(this);
     }
 
     protected synchronized void blockMessages() {
@@ -249,7 +245,7 @@ class CallbackProxy extends Handler {
      * Get the Back/Forward list to return to the user or to update the cached
      * history list.
      */
-    public WebBackForwardList getBackForwardList() {
+    public WebBackForwardListClassic getBackForwardList() {
         return mBackForwardList;
     }
 
@@ -403,17 +399,18 @@ class CallbackProxy extends Handler {
                 break;
 
             case PROCEEDED_AFTER_SSL_ERROR:
-                if (mWebViewClient != null) {
-                    mWebViewClient.onProceededAfterSslError(mWebView.getWebView(),
+                if (mWebViewClient != null && mWebViewClient instanceof WebViewClientClassicExt) {
+                    ((WebViewClientClassicExt) mWebViewClient).onProceededAfterSslError(
+                            mWebView.getWebView(),
                             (SslError) msg.obj);
                 }
                 break;
 
             case CLIENT_CERT_REQUEST:
-                if (mWebViewClient != null) {
-                    HashMap<String, Object> map =
-                        (HashMap<String, Object>) msg.obj;
-                    mWebViewClient.onReceivedClientCertRequest(mWebView.getWebView(),
+                if (mWebViewClient != null  && mWebViewClient instanceof WebViewClientClassicExt) {
+                    HashMap<String, Object> map = (HashMap<String, Object>) msg.obj;
+                    ((WebViewClientClassicExt) mWebViewClient).onReceivedClientCertRequest(
+                            mWebView.getWebView(),
                             (ClientCertRequestHandler) map.get("handler"),
                             (String) map.get("host_and_port"));
                 }
@@ -452,10 +449,16 @@ class CallbackProxy extends Handler {
                     String contentDisposition =
                         msg.getData().getString("contentDisposition");
                     String mimetype = msg.getData().getString("mimetype");
+                    String referer = msg.getData().getString("referer");
                     Long contentLength = msg.getData().getLong("contentLength");
 
-                    mDownloadListener.onDownloadStart(url, userAgent,
-                            contentDisposition, mimetype, contentLength);
+                    if (mDownloadListener instanceof BrowserDownloadListener) {
+                        ((BrowserDownloadListener) mDownloadListener).onDownloadStart(url,
+                             userAgent, contentDisposition, mimetype, referer, contentLength);
+                    } else {
+                        mDownloadListener.onDownloadStart(url, userAgent,
+                             contentDisposition, mimetype, contentLength);
+                    }
                 }
                 break;
 
@@ -736,6 +739,14 @@ class CallbackProxy extends Handler {
                                                 res.cancel();
                                             }
                                         })
+                                .setOnCancelListener(
+                                        new DialogInterface.OnCancelListener() {
+                                            @Override
+                                            public void onCancel(
+                                                    DialogInterface dialog) {
+                                                res.cancel();
+                                            }
+                                        })
                                 .show();
                     }
                     receiver.setReady();
@@ -857,19 +868,6 @@ class CallbackProxy extends Handler {
                         host, realm, username, password);
                 break;
             }
-            case SET_INSTALLABLE_WEBAPP:
-                if (mWebChromeClient != null) {
-                    mWebChromeClient.setInstallableWebApp();
-                }
-                break;
-            case NOTIFY_SEARCHBOX_LISTENERS: {
-                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
-
-                @SuppressWarnings("unchecked")
-                List<String> suggestions = (List<String>) msg.obj;
-                searchBox.handleSuggestions(msg.getData().getString("query"), suggestions);
-                break;
-            }
             case AUTO_LOGIN: {
                 if (mWebViewClient != null) {
                     String realm = msg.getData().getString("realm");
@@ -880,19 +878,6 @@ class CallbackProxy extends Handler {
                 }
                 break;
             }
-            case SEARCHBOX_IS_SUPPORTED_CALLBACK: {
-                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
-                Boolean supported = (Boolean) msg.obj;
-                searchBox.handleIsSupportedCallback(supported);
-                break;
-            }
-            case SEARCHBOX_DISPATCH_COMPLETE_CALLBACK: {
-                SearchBoxImpl searchBox = (SearchBoxImpl) mWebView.getSearchBox();
-                Boolean success = (Boolean) msg.obj;
-                searchBox.handleDispatchCompleteCallback(msg.getData().getString("function"),
-                        msg.getData().getInt("id"), success);
-                break;
-            }
         }
     }
 
@@ -1081,7 +1066,7 @@ class CallbackProxy extends Handler {
     }
 
     public void onProceededAfterSslError(SslError error) {
-        if (mWebViewClient == null) {
+        if (mWebViewClient == null || !(mWebViewClient instanceof WebViewClientClassicExt)) {
             return;
         }
         Message msg = obtainMessage(PROCEEDED_AFTER_SSL_ERROR);
@@ -1092,7 +1077,7 @@ class CallbackProxy extends Handler {
     public void onReceivedClientCertRequest(ClientCertRequestHandler handler, String host_and_port) {
         // Do an unsynchronized quick check to avoid posting if no callback has
         // been set.
-        if (mWebViewClient == null) {
+        if (mWebViewClient == null || !(mWebViewClient instanceof WebViewClientClassicExt)) {
             handler.cancel();
             return;
         }
@@ -1176,7 +1161,8 @@ class CallbackProxy extends Handler {
      * return false.
      */
     public boolean onDownloadStart(String url, String userAgent,
-            String contentDisposition, String mimetype, long contentLength) {
+            String contentDisposition, String mimetype, String referer,
+            long contentLength) {
         // Do an unsynchronized quick check to avoid posting if no callback has
         // been set.
         if (mDownloadListener == null) {
@@ -1189,6 +1175,7 @@ class CallbackProxy extends Handler {
         bundle.putString("url", url);
         bundle.putString("userAgent", userAgent);
         bundle.putString("mimetype", mimetype);
+        bundle.putString("referer", referer);
         bundle.putLong("contentLength", contentLength);
         bundle.putString("contentDisposition", contentDisposition);
         sendMessage(msg);
@@ -1301,7 +1288,7 @@ class CallbackProxy extends Handler {
     public void onReceivedIcon(Bitmap icon) {
         // The current item might be null if the icon was already stored in the
         // database and this is a new WebView.
-        WebHistoryItem i = mBackForwardList.getCurrentItem();
+        WebHistoryItemClassic i = mBackForwardList.getCurrentItem();
         if (i != null) {
             i.setFavicon(icon);
         }
@@ -1316,7 +1303,7 @@ class CallbackProxy extends Handler {
     /* package */ void onReceivedTouchIconUrl(String url, boolean precomposed) {
         // We should have a current item but we do not want to crash so check
         // for null.
-        WebHistoryItem i = mBackForwardList.getCurrentItem();
+        WebHistoryItemClassic i = mBackForwardList.getCurrentItem();
         if (i != null) {
             i.setTouchIconUrl(url, precomposed);
         }
@@ -1608,13 +1595,6 @@ class CallbackProxy extends Handler {
         sendMessage(msg);
     }
 
-    void setInstallableWebApp() {
-        if (mWebChromeClient == null) {
-            return;
-        }
-        sendMessage(obtainMessage(SET_INSTALLABLE_WEBAPP));
-    }
-
     boolean canShowAlertDialog() {
         // We can only display the alert dialog if mContext is
         // an Activity context.
@@ -1625,29 +1605,6 @@ class CallbackProxy extends Handler {
         return mContext instanceof Activity;
     }
 
-    void onSearchboxSuggestionsReceived(String query, List<String> suggestions) {
-        Message msg = obtainMessage(NOTIFY_SEARCHBOX_LISTENERS);
-        msg.obj = suggestions;
-        msg.getData().putString("query", query);
-
-        sendMessage(msg);
-    }
-
-    void onIsSupportedCallback(boolean isSupported) {
-        Message msg = obtainMessage(SEARCHBOX_IS_SUPPORTED_CALLBACK);
-        msg.obj = Boolean.valueOf(isSupported);
-        sendMessage(msg);
-    }
-
-    void onSearchboxDispatchCompleteCallback(String function, int id, boolean success) {
-        Message msg = obtainMessage(SEARCHBOX_DISPATCH_COMPLETE_CALLBACK);
-        msg.obj = Boolean.valueOf(success);
-        msg.getData().putString("function", function);
-        msg.getData().putInt("id", id);
-
-        sendMessage(msg);
-    }
-
     private synchronized void sendMessageToUiThreadSync(Message msg) {
         sendMessage(msg);
         WebCoreThreadWatchdog.pause();
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/CertTool.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CertTool.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/CertTool.java	2013-03-12 17:09:11.242011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CertTool.java	2013-03-12 17:03:37.000000000 +0100
@@ -16,6 +16,7 @@
 
 package android.webkit;
 
+import com.android.org.bouncycastle.asn1.ASN1Encoding;
 import com.android.org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
 import com.android.org.bouncycastle.asn1.x509.AlgorithmIdentifier;
 import com.android.org.bouncycastle.jce.netscape.NetscapeCertRequest;
@@ -57,7 +58,7 @@ final class CertTool {
             NetscapeCertRequest request = new NetscapeCertRequest(challenge,
                     MD5_WITH_RSA, pair.getPublic());
             request.sign(pair.getPrivate());
-            byte[] signed = request.toASN1Object().getDEREncoded();
+            byte[] signed = request.toASN1Primitive().getEncoded(ASN1Encoding.DER);
 
             Credentials.getInstance().install(context, pair);
             return new String(Base64.encode(signed));
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/CookieManager.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CookieManager.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/CookieManager.java	2013-03-12 17:09:11.246011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CookieManager.java	2013-03-12 17:03:37.000000000 +0100
@@ -37,8 +37,8 @@ public class CookieManager {
     /**
      * Gets the singleton CookieManager instance. If this method is used
      * before the application instantiates a {@link WebView} instance,
-     * {@link CookieSyncManager#createInstance(Context)} must be called
-     * first.
+     * {@link CookieSyncManager#createInstance CookieSyncManager.createInstance(Context)}
+     * must be called first.
      *
      * @return the singleton CookieManager instance
      */
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/CookieSyncManager.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CookieSyncManager.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/CookieSyncManager.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/CookieSyncManager.java	2013-03-12 17:03:37.000000000 +0100
@@ -86,10 +86,8 @@ public final class CookieSyncManager ext
             throw new IllegalArgumentException("Invalid context argument");
         }
 
-        JniUtil.setContext(context);
-        Context appContext = context.getApplicationContext();
         if (sRef == null) {
-            sRef = new CookieSyncManager(appContext);
+            sRef = new CookieSyncManager(context);
         }
         return sRef;
     }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/DateSorter.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/DateSorter.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/DateSorter.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/DateSorter.java	2013-03-12 17:03:37.000000000 +0100
@@ -21,6 +21,9 @@ import android.content.res.Resources;
 
 import java.util.Calendar;
 import java.util.Date;
+import java.util.Locale;
+
+import libcore.icu.LocaleData;
 
 /**
  * Sorts dates into the following groups:
@@ -63,8 +66,13 @@ public class DateSorter {
         mBins[3] = c.getTimeInMillis();  // One month ago
 
         // build labels
-        mLabels[0] = context.getText(com.android.internal.R.string.today).toString();
-        mLabels[1] = context.getText(com.android.internal.R.string.yesterday).toString();
+        Locale locale = resources.getConfiguration().locale;
+        if (locale == null) {
+            locale = Locale.getDefault();
+        }
+        LocaleData localeData = LocaleData.get(locale);
+        mLabels[0] = localeData.today;
+        mLabels[1] = localeData.yesterday;
 
         int resId = com.android.internal.R.plurals.last_num_days;
         String format = resources.getQuantityString(resId, NUM_DAYS_AGO);
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/DeviceOrientationService.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/DeviceOrientationService.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/DeviceOrientationService.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/DeviceOrientationService.java	2013-03-12 17:03:37.000000000 +0100
@@ -123,7 +123,7 @@ final class DeviceOrientationService imp
         // The angles are in radians
         float[] rotationAngles = new float[3];
         SensorManager.getOrientation(deviceRotationMatrix, rotationAngles);
-        double alpha = Math.toDegrees(-rotationAngles[0]) - 90.0;
+        double alpha = Math.toDegrees(-rotationAngles[0]);
         while (alpha < 0.0) { alpha += 360.0; } // [0, 360)
         double beta = Math.toDegrees(-rotationAngles[1]);
         while (beta < -180.0) { beta += 360.0; } // [-180, 180)
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5Audio.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5Audio.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5Audio.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5Audio.java	2013-03-12 17:03:37.000000000 +0100
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2010 The Android Open Source Project
- * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -71,15 +70,10 @@ class HTML5Audio extends Handler
     private boolean mLoopEnabled = false;
     private boolean mProcessingOnEnd = false;
     private Context mContext;
-    // The handler for WebCore thread messages;
-    private Handler mWebCoreHandler;
 
     // Timer thread -> UI thread
     private static final int TIMEUPDATE = 100;
 
-    // AudioManager callback thread -> Webcore thread
-    private static final int AUDIOFOCUS_CHANGED = 200;
-
     private static final String COOKIE = "Cookie";
     private static final String HIDE_URL_LOGS = "x-hide-urls-from-log";
 
@@ -194,7 +188,6 @@ class HTML5Audio extends Handler
     public HTML5Audio(WebViewCore webViewCore, int nativePtr) {
         // Save the native ptr
         mNativePointer = nativePtr;
-        createWebCoreHandler();
         resetMediaPlayer();
         mContext = webViewCore.getContext();
         mIsPrivateBrowsingEnabledGetter = new IsPrivateBrowsingEnabledGetter(
@@ -247,7 +240,8 @@ class HTML5Audio extends Handler
         }
     }
 
-    private void handleAudioFocusChange(int focusChange) {
+    @Override
+    public void onAudioFocusChange(int focusChange) {
         switch (focusChange) {
         case AudioManager.AUDIOFOCUS_GAIN:
             // resume playback
@@ -260,10 +254,10 @@ class HTML5Audio extends Handler
             break;
 
         case AudioManager.AUDIOFOCUS_LOSS:
-            // Lost focus for an unbounded amount of time: pause playback.
+            // Lost focus for an unbounded amount of time: stop playback.
             if (mState != ERROR && mMediaPlayer.isPlaying()) {
-                pause();
-                nativeOnPaused(mNativePointer);
+                mMediaPlayer.stop();
+                mState = STOPPED;
             }
             break;
 
@@ -276,25 +270,6 @@ class HTML5Audio extends Handler
         }
     }
 
-    private void createWebCoreHandler() {
-        mWebCoreHandler = new Handler() {
-            @Override
-            public void handleMessage(Message msg) {
-                switch (msg.what) {
-                    case AUDIOFOCUS_CHANGED:
-                        handleAudioFocusChange(msg.arg1);
-                        break;
-                }
-            }
-        };
-    }
-
-    @Override
-    public void onAudioFocusChange(int focusChange) {
-        Message msg = Message.obtain(mWebCoreHandler, AUDIOFOCUS_CHANGED);
-        msg.arg1 = focusChange;
-        mWebCoreHandler.sendMessage(msg);
-    }
 
     private void play() {
         if (mState == COMPLETE && mLoopEnabled == true) {
@@ -341,12 +316,6 @@ class HTML5Audio extends Handler
         }
     }
 
-    private void setVolume(float volume) {
-        if (mState >= PREPARED) {
-            mMediaPlayer.setVolume(volume, volume);
-        }
-    }
-
     /**
      * Called only over JNI when WebKit is happy to
      * destroy the media player.
@@ -368,7 +337,6 @@ class HTML5Audio extends Handler
 
     private native void nativeOnBuffering(int percent, int nativePointer);
     private native void nativeOnEnded(int nativePointer);
-    private native void nativeOnPaused(int nativePointer);
     private native void nativeOnRequestPlay(int nativePointer);
     private native void nativeOnPrepared(int duration, int width, int height, int nativePointer);
     private native void nativeOnTimeupdate(int position, int nativePointer);
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoFullScreen.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoFullScreen.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoFullScreen.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoFullScreen.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,408 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import android.content.Context;
+import android.media.MediaPlayer;
+import android.media.Metadata;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.MediaController;
+import android.widget.MediaController.MediaPlayerControl;
+
+
+/**
+ * @hide This is only used by the browser
+ */
+public class HTML5VideoFullScreen extends HTML5VideoView
+    implements MediaPlayerControl, MediaPlayer.OnPreparedListener,
+    View.OnTouchListener {
+
+    // Add this sub-class to handle the resizing when rotating screen.
+    private class VideoSurfaceView extends SurfaceView {
+
+        public VideoSurfaceView(Context context) {
+            super(context);
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            int width = getDefaultSize(mVideoWidth, widthMeasureSpec);
+            int height = getDefaultSize(mVideoHeight, heightMeasureSpec);
+            if (mVideoWidth > 0 && mVideoHeight > 0) {
+                if ( mVideoWidth * height  > width * mVideoHeight ) {
+                    height = width * mVideoHeight / mVideoWidth;
+                } else if ( mVideoWidth * height  < width * mVideoHeight ) {
+                    width = height * mVideoWidth / mVideoHeight;
+                }
+            }
+            setMeasuredDimension(width, height);
+        }
+    }
+
+    // This view will contain the video.
+    private VideoSurfaceView mVideoSurfaceView;
+
+    // We need the full screen state to decide which surface to render to and
+    // when to create the MediaPlayer accordingly.
+    static final int FULLSCREEN_OFF               = 0;
+    static final int FULLSCREEN_SURFACECREATING   = 1;
+    static final int FULLSCREEN_SURFACECREATED    = 2;
+
+    private int mFullScreenMode;
+    // The Media Controller only used for full screen mode
+    private MediaController mMediaController;
+
+    // SurfaceHolder for full screen
+    private SurfaceHolder mSurfaceHolder = null;
+
+    // Data only for MediaController
+    private boolean mCanSeekBack;
+    private boolean mCanSeekForward;
+    private boolean mCanPause;
+    private int mCurrentBufferPercentage;
+
+    // The progress view.
+    private static View mProgressView;
+    // The container for the progress view and video view
+    private static FrameLayout mLayout;
+
+    // The video size will be ready when prepared. Used to make sure the aspect
+    // ratio is correct.
+    private int mVideoWidth;
+    private int mVideoHeight;
+    private boolean mPlayingWhenDestroyed = false;
+    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
+    {
+        @Override
+        public void surfaceChanged(SurfaceHolder holder, int format,
+                                    int w, int h)
+        {
+            if (mPlayer != null && mMediaController != null
+                    && mCurrentState == STATE_PREPARED) {
+                if (mMediaController.isShowing()) {
+                    // ensure the controller will get repositioned later
+                    mMediaController.hide();
+                }
+                mMediaController.show();
+            }
+        }
+
+        @Override
+        public void surfaceCreated(SurfaceHolder holder)
+        {
+            mSurfaceHolder = holder;
+            mFullScreenMode = FULLSCREEN_SURFACECREATED;
+
+            prepareForFullScreen();
+        }
+
+        @Override
+        public void surfaceDestroyed(SurfaceHolder holder)
+        {
+            mPlayingWhenDestroyed = mPlayer.isPlaying();
+            pauseAndDispatch(mProxy);
+            // We need to set the display to null before switching into inline
+            // mode to avoid error.
+            mPlayer.setDisplay(null);
+            mSurfaceHolder = null;
+            if (mMediaController != null) {
+                mMediaController.hide();
+            }
+        }
+    };
+
+    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
+        new MediaPlayer.OnVideoSizeChangedListener() {
+            @Override
+            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
+                mVideoWidth = mp.getVideoWidth();
+                mVideoHeight = mp.getVideoHeight();
+                if (mVideoWidth != 0 && mVideoHeight != 0) {
+                    mVideoSurfaceView.getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+                }
+            }
+    };
+
+    private SurfaceView getSurfaceView() {
+        return mVideoSurfaceView;
+    }
+
+    HTML5VideoFullScreen(Context context, int videoLayerId, int position, boolean skipPrepare) {
+        mVideoSurfaceView = new VideoSurfaceView(context);
+        mFullScreenMode = FULLSCREEN_OFF;
+        mVideoWidth = 0;
+        mVideoHeight = 0;
+        init(videoLayerId, position, skipPrepare);
+    }
+
+    private void setMediaController(MediaController m) {
+        mMediaController  = m;
+        attachMediaController();
+    }
+
+    private void attachMediaController() {
+        if (mPlayer != null && mMediaController != null) {
+            mMediaController.setMediaPlayer(this);
+            mMediaController.setAnchorView(mVideoSurfaceView);
+            //Will be enabled when prepared
+            mMediaController.setEnabled(false);
+        }
+    }
+
+    @Override
+    public void decideDisplayMode() {
+        mPlayer.setDisplay(mSurfaceHolder);
+    }
+
+    private void prepareForFullScreen() {
+        MediaController mc = new FullScreenMediaController(mProxy.getContext(), mLayout);
+        mc.setSystemUiVisibility(mLayout.getSystemUiVisibility());
+        setMediaController(mc);
+        mPlayer.setScreenOnWhilePlaying(true);
+        mPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);
+        prepareDataAndDisplayMode(mProxy);
+    }
+
+
+    private void toggleMediaControlsVisiblity() {
+        if (mMediaController.isShowing()) {
+            mMediaController.hide();
+        } else {
+            mMediaController.show();
+        }
+    }
+
+    @Override
+    public void onPrepared(MediaPlayer mp) {
+        super.onPrepared(mp);
+
+        mVideoSurfaceView.setOnTouchListener(this);
+        // Get the capabilities of the player for this stream
+        Metadata data = mp.getMetadata(MediaPlayer.METADATA_ALL,
+                MediaPlayer.BYPASS_METADATA_FILTER);
+        if (data != null) {
+            mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
+                    || data.getBoolean(Metadata.PAUSE_AVAILABLE);
+            mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
+                    || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
+            mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
+                    || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
+        } else {
+            mCanPause = mCanSeekBack = mCanSeekForward = true;
+        }
+
+        if (getStartWhenPrepared()) {
+            mPlayer.start();
+            // Clear the flag.
+            setStartWhenPrepared(false);
+        }
+
+        // mMediaController status depends on the Metadata result, so put it
+        // after reading the MetaData.
+        // And make sure mPlayer state is updated before showing the controller.
+        if (mMediaController != null) {
+            mMediaController.setEnabled(true);
+            mMediaController.show();
+        }
+
+        if (mProgressView != null) {
+            mProgressView.setVisibility(View.GONE);
+        }
+
+        mVideoWidth = mp.getVideoWidth();
+        mVideoHeight = mp.getVideoHeight();
+        // This will trigger the onMeasure to get the display size right.
+        mVideoSurfaceView.getHolder().setFixedSize(mVideoWidth, mVideoHeight);
+
+    }
+
+    @Override
+    public boolean fullScreenExited() {
+        return (mLayout == null);
+    }
+
+    private final WebChromeClient.CustomViewCallback mCallback =
+        new WebChromeClient.CustomViewCallback() {
+            @Override
+            public void onCustomViewHidden() {
+                // It listens to SurfaceHolder.Callback.SurfaceDestroyed event
+                // which happens when the video view is detached from its parent
+                // view. This happens in the WebChromeClient before this method
+                // is invoked.
+                mLayout.removeView(getSurfaceView());
+
+                if (mProgressView != null) {
+                    mLayout.removeView(mProgressView);
+                    mProgressView = null;
+                }
+                mLayout = null;
+                // Re enable plugin views.
+                mProxy.getWebView().getViewManager().showAll();
+                // Don't show the controller after exiting the full screen.
+                mMediaController = null;
+                // Continue the inline mode playing if necessary.
+                mProxy.dispatchOnStopFullScreen(mPlayingWhenDestroyed);
+                mProxy = null;
+            }
+        };
+
+    @Override
+    public void enterFullScreenVideoState(int layerId,
+            HTML5VideoViewProxy proxy, WebViewClassic webView) {
+        mFullScreenMode = FULLSCREEN_SURFACECREATING;
+        mCurrentBufferPercentage = 0;
+        mPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
+        mProxy = proxy;
+
+        mVideoSurfaceView.getHolder().addCallback(mSHCallback);
+        mVideoSurfaceView.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+        mVideoSurfaceView.setFocusable(true);
+        mVideoSurfaceView.setFocusableInTouchMode(true);
+        mVideoSurfaceView.requestFocus();
+        mVideoSurfaceView.setOnKeyListener(mProxy);
+        // Create a FrameLayout that will contain the VideoView and the
+        // progress view (if any).
+        mLayout = new FrameLayout(mProxy.getContext());
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
+                            ViewGroup.LayoutParams.WRAP_CONTENT,
+                            ViewGroup.LayoutParams.WRAP_CONTENT,
+                            Gravity.CENTER);
+
+        mLayout.addView(getSurfaceView(), layoutParams);
+
+        mLayout.setVisibility(View.VISIBLE);
+        WebChromeClient client = webView.getWebChromeClient();
+        if (client != null) {
+            client.onShowCustomView(mLayout, mCallback);
+            // Plugins like Flash will draw over the video so hide
+            // them while we're playing.
+            if (webView.getViewManager() != null)
+                webView.getViewManager().hideAll();
+
+            mProgressView = client.getVideoLoadingProgressView();
+            if (mProgressView != null) {
+                mLayout.addView(mProgressView, layoutParams);
+                mProgressView.setVisibility(View.VISIBLE);
+            }
+        }
+    }
+
+    /**
+     * @return true when we are in full screen mode, even the surface not fully
+     * created.
+     */
+    @Override
+    public boolean isFullScreenMode() {
+        return true;
+    }
+
+    // MediaController FUNCTIONS:
+    @Override
+    public boolean canPause() {
+        return mCanPause;
+    }
+
+    @Override
+    public boolean canSeekBackward() {
+        return mCanSeekBack;
+    }
+
+    @Override
+    public boolean canSeekForward() {
+        return mCanSeekForward;
+    }
+
+    @Override
+    public int getBufferPercentage() {
+        if (mPlayer != null) {
+            return mCurrentBufferPercentage;
+        }
+    return 0;
+    }
+
+    @Override
+    public void showControllerInFullScreen() {
+        if (mMediaController != null) {
+            mMediaController.show(0);
+        }
+    }
+
+    // Other listeners functions:
+    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
+        new MediaPlayer.OnBufferingUpdateListener() {
+        @Override
+        public void onBufferingUpdate(MediaPlayer mp, int percent) {
+            mCurrentBufferPercentage = percent;
+        }
+    };
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        if (mFullScreenMode >= FULLSCREEN_SURFACECREATED
+                && mMediaController != null) {
+            toggleMediaControlsVisiblity();
+        }
+        return false;
+    }
+
+    @Override
+    protected void switchProgressView(boolean playerBuffering) {
+        if (mProgressView != null) {
+            if (playerBuffering) {
+                mProgressView.setVisibility(View.VISIBLE);
+            } else {
+                mProgressView.setVisibility(View.GONE);
+            }
+        }
+        return;
+    }
+
+    static class FullScreenMediaController extends MediaController {
+
+        View mVideoView;
+
+        public FullScreenMediaController(Context context, View video) {
+            super(context);
+            mVideoView = video;
+        }
+
+        @Override
+        public void show() {
+            super.show();
+            if (mVideoView != null) {
+                mVideoView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
+            }
+        }
+
+        @Override
+        public void hide() {
+            if (mVideoView != null) {
+                mVideoView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE
+                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
+            }
+            super.hide();
+        }
+
+    }
+
+}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoInline.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoInline.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoInline.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoInline.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import android.Manifest.permission;
+import android.content.pm.PackageManager;
+import android.graphics.SurfaceTexture;
+import android.webkit.HTML5VideoView;
+import android.webkit.HTML5VideoViewProxy;
+import android.view.Surface;
+import android.opengl.GLES20;
+import android.os.PowerManager;
+
+/**
+ * @hide This is only used by the browser
+ */
+public class HTML5VideoInline extends HTML5VideoView{
+
+    // Due to the fact that the decoder consume a lot of memory, we make the
+    // surface texture as singleton. But the GL texture (m_textureNames)
+    // associated with the surface texture can be used for showing the screen
+    // shot when paused, so they are not singleton.
+    private static SurfaceTexture mSurfaceTexture = null;
+    private static int[] mTextureNames = null;
+    // Every time when the VideoLayer Id change, we need to recreate the
+    // SurfaceTexture in order to delete the old video's decoder memory.
+    private static int mVideoLayerUsingSurfaceTexture = -1;
+
+    // Video control FUNCTIONS:
+    @Override
+    public void start() {
+        if (!getPauseDuringPreparing()) {
+            super.start();
+        }
+    }
+
+    HTML5VideoInline(int videoLayerId, int position, boolean skipPrepare) {
+        init(videoLayerId, position, skipPrepare);
+    }
+
+    @Override
+    public void decideDisplayMode() {
+        SurfaceTexture surfaceTexture = getSurfaceTexture(getVideoLayerId());
+        Surface surface = new Surface(surfaceTexture);
+        mPlayer.setSurface(surface);
+        surface.release();
+    }
+
+    // Normally called immediately after setVideoURI. But for full screen,
+    // this should be after surface holder created
+    @Override
+    public void prepareDataAndDisplayMode(HTML5VideoViewProxy proxy) {
+        super.prepareDataAndDisplayMode(proxy);
+        setFrameAvailableListener(proxy);
+        // TODO: This is a workaround, after b/5375681 fixed, we should switch
+        // to the better way.
+        if (mProxy.getContext().checkCallingOrSelfPermission(permission.WAKE_LOCK)
+                == PackageManager.PERMISSION_GRANTED) {
+            mPlayer.setWakeMode(proxy.getContext(), PowerManager.FULL_WAKE_LOCK);
+        }
+    }
+
+    // Pause the play and update the play/pause button
+    @Override
+    public void pauseAndDispatch(HTML5VideoViewProxy proxy) {
+        super.pauseAndDispatch(proxy);
+    }
+
+    // Inline Video specific FUNCTIONS:
+
+    public static SurfaceTexture getSurfaceTexture(int videoLayerId) {
+        // Create the surface texture.
+        if (videoLayerId != mVideoLayerUsingSurfaceTexture
+            || mSurfaceTexture == null
+            || mTextureNames == null) {
+            // The GL texture will store in the VideoLayerManager at native side.
+            // They will be clean up when requested.
+            // The reason we recreated GL texture name is for screen shot support.
+            mTextureNames = new int[1];
+            GLES20.glGenTextures(1, mTextureNames, 0);
+            mSurfaceTexture = new SurfaceTexture(mTextureNames[0]);
+        }
+        mVideoLayerUsingSurfaceTexture = videoLayerId;
+        return mSurfaceTexture;
+    }
+
+    public static boolean surfaceTextureDeleted() {
+        return (mSurfaceTexture == null);
+    }
+
+    @Override
+    public void deleteSurfaceTexture() {
+        cleanupSurfaceTexture();
+        return;
+    }
+
+    public static void cleanupSurfaceTexture() {
+        mSurfaceTexture = null;
+        mVideoLayerUsingSurfaceTexture = -1;
+        return;
+    }
+
+    @Override
+    public int getTextureName() {
+        if (mTextureNames != null) {
+            return mTextureNames[0];
+        } else {
+            return 0;
+        }
+    }
+
+    private void setFrameAvailableListener(SurfaceTexture.OnFrameAvailableListener l) {
+        if (mSurfaceTexture != null) {
+            mSurfaceTexture.setOnFrameAvailableListener(l);
+        }
+    }
+
+}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoView.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoView.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoView.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoView.java	2013-03-12 17:03:37.000000000 +0100
@@ -1,59 +1,24 @@
-/* Copyright (c) 2011, 2012, Code Aurora Forum. All rights reserved.
+/*
+ * Copyright (C) 2012 The Android Open Source Project
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package android.webkit;
 
-import android.Manifest.permission;
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.graphics.Point;
-import android.graphics.SurfaceTexture;
-import android.media.MediaMetadataRetriever;
 import android.media.MediaPlayer;
-import android.media.Metadata;
 import android.net.Uri;
-import android.opengl.GLES20;
-import android.os.PowerManager;
-import android.util.Log;
-import android.view.Display;
-import android.view.Gravity;
-import android.view.MotionEvent;
-import android.view.Surface;
-import android.view.TextureView;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-import android.widget.FrameLayout;
-import android.widget.MediaController;
-import android.widget.MediaController.MediaPlayerControl;
-
+import android.webkit.HTML5VideoViewProxy;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
@@ -63,15 +28,12 @@ import java.util.TimerTask;
 /**
  * @hide This is only used by the browser
  */
-public class HTML5VideoView implements MediaPlayer.OnPreparedListener,
-    MediaPlayerControl, View.OnTouchListener, TextureView.SurfaceTextureListener,
-    SurfaceTexture.OnFrameAvailableListener, MediaPlayer.OnVideoSizeChangedListener
-{
-    private static final String LOGTAG = "HTML5VideoView";
-    private static final String COOKIE = "Cookie";
-    private static final String HIDE_URL_LOGS = "x-hide-urls-from-log";
+public class HTML5VideoView implements MediaPlayer.OnPreparedListener {
+
+    protected static final String LOGTAG = "HTML5VideoView";
 
-    private static final long ANIMATION_DURATION = 750L; // in ms
+    protected static final String COOKIE = "Cookie";
+    protected static final String HIDE_URL_LOGS = "x-hide-urls-from-log";
 
     // For handling the seekTo before prepared, we need to know whether or not
     // the video is prepared. Therefore, we differentiate the state between
@@ -84,72 +46,37 @@ public class HTML5VideoView implements M
     static final int STATE_PREPARING          = 1;
     static final int STATE_PREPARED           = 2;
     static final int STATE_PLAYING            = 3;
-    static final int STATE_BUFFERING          = 4;
+    static final int STATE_RESETTED           = 4;
     static final int STATE_RELEASED           = 5;
 
-    static final int ANIMATION_STATE_NONE     = 0;
-    static final int ANIMATION_STATE_STARTED  = 1;
-    static final int ANIMATION_STATE_FINISHED = 2;
-    private int mAnimationState;
-
-    private HTML5VideoViewProxy mProxy;
+    protected HTML5VideoViewProxy mProxy;
 
     // Save the seek time when not prepared. This can happen when switching
     // video besides initial load.
-    private int mSaveSeekTime;
+    protected int mSaveSeekTime;
+
+    // This is used to find the VideoLayer on the native side.
+    protected int mVideoLayerId;
 
-    private MediaPlayer mPlayer;
-    private int mCurrentState;
+    // Given the fact we only have one SurfaceTexture, we cannot support multiple
+    // player at the same time. We may recreate a new one and abandon the old
+    // one at transition time.
+    protected static MediaPlayer mPlayer = null;
+    protected static int mCurrentState = -1;
 
     // We need to save such info.
-    private Uri mUri;
-    private Map<String, String> mHeaders;
+    protected Uri mUri;
+    protected Map<String, String> mHeaders;
 
     // The timer for timeupate events.
     // See http://www.whatwg.org/specs/web-apps/current-work/#event-media-timeupdate
-    private Timer mTimer;
-
-    private boolean mIsFullscreen;
+    protected static Timer mTimer;
 
     protected boolean mPauseDuringPreparing;
 
     // The spec says the timer should fire every 250 ms or less.
     private static final int TIMEUPDATE_PERIOD = 250;  // ms
-
-    private int mVideoWidth;
-    private int mVideoHeight;
-    private int mDuration;
-
-    private int mFullscreenWidth;
-    private int mFullscreenHeight;
-
-    private float mInlineX;
-    private float mInlineY;
-    private float mInlineWidth;
-    private float mInlineHeight;
-
-    private Point mDisplaySize;
-    private int[] mWebViewLocation;
-
-    // The Media Controller only used for full screen mode
-    private MediaController mMediaController;
-
-    // Data only for MediaController
-    private boolean mCanSeekBack;
-    private boolean mCanSeekForward;
-    private boolean mCanPause;
-    private int mCurrentBufferPercentage;
-
-    // The progress view.
-    private View mProgressView;
-    // The container for the progress view and video view
-    private FrameLayout mLayout;
-
-    private SurfaceTexture mSurfaceTexture;
-    private VideoTextureView mTextureView;
-    // m_textureNames is the texture bound with this SurfaceTexture.
-    private int[] mTextureNames;
-    private boolean mNeedsAttachToInlineGlContext;
+    private boolean mSkipPrepare = false;
 
     // common Video control FUNCTIONS:
     public void start() {
@@ -163,18 +90,8 @@ public class HTML5VideoView implements M
                         TIMEUPDATE_PERIOD);
             }
             mPlayer.start();
-
             setPlayerBuffering(false);
-            // Notify webkit MediaPlayer that video is playing to make sure
-            // webkit MediaPlayer is always synchronized with the proxy.
-            // This is particularly important when using the fullscreen
-            // MediaController.
-            mProxy.dispatchOnPlaying();
-
-            if (mMediaController != null)
-                mMediaController.show();
-        } else
-            setStartWhenPrepared(true);
+        }
     }
 
     public void pause() {
@@ -183,15 +100,6 @@ public class HTML5VideoView implements M
         } else if (mCurrentState == STATE_PREPARING) {
             mPauseDuringPreparing = true;
         }
-        // Notify webkit MediaPlayer that video is paused to make sure
-        // webkit MediaPlayer is always synchronized with the proxy
-        // This is particularly important when using the fullscreen
-        // MediaController.
-        mProxy.dispatchOnPaused();
-
-        if (mMediaController != null)
-            mMediaController.show(0);
-
         // Delete the Timer to stop it since there is no stop call.
         if (mTimer != null) {
             mTimer.purge();
@@ -200,22 +108,6 @@ public class HTML5VideoView implements M
         }
     }
 
-    public void attachToInlineGlContextIfNeeded() {
-        if (mNeedsAttachToInlineGlContext && !mIsFullscreen
-                && (mCurrentState == STATE_PREPARED ||
-                    mCurrentState == STATE_PREPARING ||
-                    mCurrentState == STATE_PLAYING)) {
-            // Attach the previous GL texture
-            try {
-                mSurfaceTexture.attachToGLContext(getTextureName());
-                mNeedsAttachToInlineGlContext = false;
-            } catch (RuntimeException e) {
-                // This can occur when the EGL context has been detached from this view.
-                // Just try to re-attach at a later time.
-            }
-        }
-    }
-
     public int getDuration() {
         if (mCurrentState == STATE_PREPARED) {
             return mPlayer.getDuration();
@@ -246,13 +138,11 @@ public class HTML5VideoView implements M
         }
     }
 
-    public void release() {
-        if (mCurrentState != STATE_RELEASED) {
-            stopPlayback();
-            mPlayer.release();
-            mSurfaceTexture.release();
+    public void reset() {
+        if (mCurrentState < STATE_RESETTED) {
+            mPlayer.reset();
         }
-        mCurrentState = STATE_RELEASED;
+        mCurrentState = STATE_RESETTED;
     }
 
     public void stopPlayback() {
@@ -261,30 +151,44 @@ public class HTML5VideoView implements M
         }
     }
 
-    public boolean getPauseDuringPreparing() {
-        return mPauseDuringPreparing;
+    public static void release() {
+        if (mPlayer != null && mCurrentState != STATE_RELEASED) {
+            mPlayer.release();
+            mPlayer = null;
+        }
+        mCurrentState = STATE_RELEASED;
     }
 
-    public void setVolume(float volume) {
-        if (mCurrentState != STATE_RELEASED) {
-            mPlayer.setVolume(volume, volume);
-        }
+    public boolean isReleased() {
+        return mCurrentState == STATE_RELEASED;
+    }
+
+    public boolean getPauseDuringPreparing() {
+        return mPauseDuringPreparing;
     }
 
     // Every time we start a new Video, we create a VideoView and a MediaPlayer
-    HTML5VideoView(HTML5VideoViewProxy proxy, int position) {
-        mPlayer = new MediaPlayer();
-        mCurrentState = STATE_INITIALIZED;
-        mProxy = proxy;
+    public void init(int videoLayerId, int position, boolean skipPrepare) {
+        if (mPlayer == null) {
+            mPlayer = new MediaPlayer();
+            mCurrentState = STATE_INITIALIZED;
+        }
+        mSkipPrepare = skipPrepare;
+        // If we want to skip the prepare, then we keep the state.
+        if (!mSkipPrepare) {
+            mCurrentState = STATE_INITIALIZED;
+        }
+        mProxy = null;
+        mVideoLayerId = videoLayerId;
         mSaveSeekTime = position;
         mTimer = null;
         mPauseDuringPreparing = false;
-        mIsFullscreen = false;
-        mDisplaySize = new Point();
-        mWebViewLocation = new int[2];
     }
 
-    private static Map<String, String> generateHeaders(String url,
+    protected HTML5VideoView() {
+    }
+
+    protected static Map<String, String> generateHeaders(String url,
             HTML5VideoViewProxy proxy) {
         boolean isPrivate = proxy.getWebView().isPrivateBrowsingEnabled();
         String cookieValue = CookieManager.getInstance().getCookie(url, isPrivate);
@@ -299,39 +203,10 @@ public class HTML5VideoView implements M
         return headers;
     }
 
-    public void setVideoURI(String uri) {
+    public void setVideoURI(String uri, HTML5VideoViewProxy proxy) {
+        // When switching players, surface texture will be reused.
         mUri = Uri.parse(uri);
-        mHeaders = generateHeaders(uri, mProxy);
-    }
-
-    // When there is a frame ready from surface texture, we should tell WebView
-    // to refresh.
-    @Override
-    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
-        // TODO: This should support partial invalidation too.
-        mProxy.getWebView().invalidate();
-    }
-
-    public void retrieveMetadata(HTML5VideoViewProxy proxy) {
-        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
-        try {
-            retriever.setDataSource(mUri.toString(), mHeaders);
-            mVideoWidth = Integer.parseInt(retriever.extractMetadata(
-                    MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH));
-            mVideoHeight = Integer.parseInt(retriever.extractMetadata(
-                    MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT));
-            mDuration = Integer.parseInt(retriever.extractMetadata(
-                    MediaMetadataRetriever.METADATA_KEY_DURATION));
-            proxy.updateSizeAndDuration(mVideoWidth, mVideoHeight, mDuration);
-        } catch (IllegalArgumentException e) {
-            e.printStackTrace();
-        } catch (RuntimeException e) {
-            // RuntimeException occurs when connection is not available or
-            // the source type is not supported (e.g. HLS). Not calling
-            // e.printStackTrace() here since it occurs quite often.
-        } finally {
-            retriever.release();
-        }
+        mHeaders = generateHeaders(uri, proxy);
     }
 
     // Listeners setup FUNCTIONS:
@@ -339,46 +214,70 @@ public class HTML5VideoView implements M
         mPlayer.setOnCompletionListener(proxy);
     }
 
-    private void prepareDataCommon(HTML5VideoViewProxy proxy) {
-        try {
-            mPlayer.setDataSource(proxy.getContext(), mUri, mHeaders);
-            mPlayer.prepareAsync();
-        } catch (IllegalArgumentException e) {
-            e.printStackTrace();
-        } catch (IllegalStateException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-        mCurrentState = STATE_PREPARING;
+    public void setOnErrorListener(HTML5VideoViewProxy proxy) {
+        mPlayer.setOnErrorListener(proxy);
     }
 
-    public void prepareDataAndDisplayMode() {
-        decideDisplayMode();
-
-        mPlayer.setOnCompletionListener(mProxy);
+    public void setOnPreparedListener(HTML5VideoViewProxy proxy) {
+        mProxy = proxy;
         mPlayer.setOnPreparedListener(this);
-        mPlayer.setOnErrorListener(mProxy);
-        mPlayer.setOnInfoListener(mProxy);
-        mPlayer.setOnVideoSizeChangedListener(this);
+    }
 
-        prepareDataCommon(mProxy);
+    public void setOnInfoListener(HTML5VideoViewProxy proxy) {
+        mPlayer.setOnInfoListener(proxy);
+    }
 
-        // TODO: This is a workaround, after b/5375681 fixed, we should switch
-        // to the better way.
-        if (mProxy.getContext().checkCallingOrSelfPermission(permission.WAKE_LOCK)
-                == PackageManager.PERMISSION_GRANTED) {
-            mPlayer.setWakeMode(mProxy.getContext(), PowerManager.FULL_WAKE_LOCK);
+    public void prepareDataCommon(HTML5VideoViewProxy proxy) {
+        if (!mSkipPrepare) {
+            try {
+                mPlayer.reset();
+                mPlayer.setDataSource(proxy.getContext(), mUri, mHeaders);
+                mPlayer.prepareAsync();
+            } catch (IllegalArgumentException e) {
+                e.printStackTrace();
+            } catch (IllegalStateException e) {
+                e.printStackTrace();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            mCurrentState = STATE_PREPARING;
+        } else {
+            // If we skip prepare and the onPrepared happened in inline mode, we
+            // don't need to call prepare again, we just need to call onPrepared
+            // to refresh the state here.
+            if (mCurrentState >= STATE_PREPARED) {
+                onPrepared(mPlayer);
+            }
+            mSkipPrepare = false;
         }
-        if (!mIsFullscreen)
-            setInlineFrameAvailableListener();
     }
 
-    // This configures the SurfaceTexture OnFrameAvailableListener in inline mode
-    private void setInlineFrameAvailableListener() {
-        getSurfaceTexture().setOnFrameAvailableListener(this);
+    public void reprepareData(HTML5VideoViewProxy proxy) {
+        mPlayer.reset();
+        prepareDataCommon(proxy);
     }
 
+    // Normally called immediately after setVideoURI. But for full screen,
+    // this should be after surface holder created
+    public void prepareDataAndDisplayMode(HTML5VideoViewProxy proxy) {
+        // SurfaceTexture will be created lazily here for inline mode
+        decideDisplayMode();
+
+        setOnCompletionListener(proxy);
+        setOnPreparedListener(proxy);
+        setOnErrorListener(proxy);
+        setOnInfoListener(proxy);
+
+        prepareDataCommon(proxy);
+    }
+
+
+    // Common code
+    public int getVideoLayerId() {
+        return mVideoLayerId;
+    }
+
+
     public int getCurrentState() {
         if (isPlaying()) {
             return STATE_PLAYING;
@@ -387,7 +286,7 @@ public class HTML5VideoView implements M
         }
     }
 
-    private final class TimeupdateTask extends TimerTask {
+    private static final class TimeupdateTask extends TimerTask {
         private HTML5VideoViewProxy mProxy;
 
         public TimeupdateTask(HTML5VideoViewProxy proxy) {
@@ -400,335 +299,74 @@ public class HTML5VideoView implements M
         }
     }
 
+    @Override
     public void onPrepared(MediaPlayer mp) {
         mCurrentState = STATE_PREPARED;
         seekTo(mSaveSeekTime);
-
-        if (mProxy != null)
+        if (mProxy != null) {
             mProxy.onPrepared(mp);
-
-        if (mPauseDuringPreparing || !getStartWhenPrepared())
+        }
+        if (mPauseDuringPreparing) {
+            pauseAndDispatch(mProxy);
             mPauseDuringPreparing = false;
-        else
-            start();
-
-        if (mIsFullscreen) {
-            attachMediaController();
-            if (mProgressView != null)
-                mProgressView.setVisibility(View.GONE);
         }
     }
 
-    public void decideDisplayMode() {
-        SurfaceTexture surfaceTexture = getSurfaceTexture();
-        Surface surface = new Surface(surfaceTexture);
-        mPlayer.setSurface(surface);
-        surface.release();
-    }
-
-    // SurfaceTexture will be created lazily here
-    public SurfaceTexture getSurfaceTexture() {
-        // Create the surface texture.
-        if (mSurfaceTexture == null || mTextureNames == null) {
-            mTextureNames = new int[1];
-            GLES20.glGenTextures(1, mTextureNames, 0);
-            mSurfaceTexture = new SurfaceTexture(mTextureNames[0]);
-        }
-        return mSurfaceTexture;
-    }
-
-    public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
-        mVideoWidth = width;
-        mVideoHeight = height;
-        if (mTextureView != null) {
-            // Request layout now that mVideoWidth and mVideoHeight are known
-            // This will trigger onMeasure to get the display size right
-            mTextureView.requestLayout();
-        }
-        if (mProxy != null) {
-            mProxy.onVideoSizeChanged(mp, width, height);
+    // Pause the play and update the play/pause button
+    public void pauseAndDispatch(HTML5VideoViewProxy proxy) {
+        pause();
+        if (proxy != null) {
+            proxy.dispatchOnPaused();
         }
     }
 
-    public int getTextureName() {
-        if (mTextureNames != null) {
-            return mTextureNames[0];
-        } else {
-            return 0;
-        }
+    // Below are functions that are different implementation on inline and full-
+    // screen mode. Some are specific to one type, but currently are called
+    // directly from the proxy.
+    public void enterFullScreenVideoState(int layerId,
+            HTML5VideoViewProxy proxy, WebViewClassic webView) {
     }
 
-    // This is true only when the player is buffering and paused
-    private boolean mPlayerBuffering = false;
-
-    public boolean getPlayerBuffering() {
-        return mPlayerBuffering;
+    public boolean isFullScreenMode() {
+        return false;
     }
 
-    public void setPlayerBuffering(boolean playerBuffering) {
-        mPlayerBuffering = playerBuffering;
-        if (mProgressView != null)
-            switchProgressView(playerBuffering);
+    public void decideDisplayMode() {
     }
 
-    private void switchProgressView(boolean playerBuffering) {
-        if (playerBuffering)
-            mProgressView.setVisibility(View.VISIBLE);
-        else
-            mProgressView.setVisibility(View.GONE);
+    public boolean getReadyToUseSurfTex() {
+        return false;
     }
 
-    class VideoTextureView extends TextureView {
-        public VideoTextureView(Context context, SurfaceTexture surface) {
-            super(context);
-            try {
-                // Detach the inline GL context
-                surface.detachFromGLContext();
-            } catch (RuntimeException e) {
-                e.printStackTrace();
-            }
-            setSurfaceTexture(surface);
-        }
-
-        @Override
-        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-            mFullscreenWidth = getDefaultSize(mVideoWidth, widthMeasureSpec);
-            mFullscreenHeight = getDefaultSize(mVideoHeight, heightMeasureSpec);
-            if (mVideoWidth > 0 && mVideoHeight > 0) {
-                if ( mVideoWidth * mFullscreenHeight > mFullscreenWidth * mVideoHeight ) {
-                    mFullscreenHeight = mFullscreenWidth * mVideoHeight / mVideoWidth;
-                } else if ( mVideoWidth * mFullscreenHeight < mFullscreenWidth * mVideoHeight ) {
-                    mFullscreenWidth = mFullscreenHeight * mVideoWidth / mVideoHeight;
-                }
-            }
-            setMeasuredDimension(mFullscreenWidth, mFullscreenHeight);
-
-            if (mAnimationState == ANIMATION_STATE_NONE) {
-                // Configuring VideoTextureView to inline bounds
-                mTextureView.setTranslationX(getInlineXOffset());
-                mTextureView.setTranslationY(getInlineYOffset());
-                mTextureView.setScaleX(getInlineXScale());
-                mTextureView.setScaleY(getInlineYScale());
-
-                // inline to fullscreen zoom out animation
-                mTextureView.animate().setListener(new AnimatorListenerAdapter() {
-                    public void onAnimationEnd(Animator animation) {
-                        mAnimationState = ANIMATION_STATE_FINISHED;
-                        attachMediaController();
-                    }
-                });
-                mTextureView.animate().setDuration(ANIMATION_DURATION);
-                mAnimationState = ANIMATION_STATE_STARTED;
-                mTextureView.animate().scaleX(1.0f).scaleY(1.0f).translationX(0.0f).translationY(0.0f);
-            }
-        }
-
-        @Override
-        protected void onDetachedFromWindow() {
-            super.onDetachedFromWindow();
-            // Attach to the previous GL texture
-            mNeedsAttachToInlineGlContext = true;
-            attachToInlineGlContextIfNeeded();
-        }
-
-        @Override
-        protected void onSizeChanged(int w, int h, int oldw, int oldh) {
-            super.onSizeChanged(w, h, oldw, oldh);
-            // Needed to update the view during orientation change when video is paused
-            // Calling setOpaque() forces the layer to be updated
-            setOpaque(false);
-            setOpaque(true);
-        }
+    public void deleteSurfaceTexture() {
     }
 
-    // Note: Call this for fullscreen mode only
-    // If MediaPlayer is prepared, enable the buttons
-    private void attachMediaController() {
-        // Get the capabilities of the player for this stream
-        // This should only be called when MediaPlayer is in prepared state
-        // Otherwise data will return invalid values
-        if (mIsFullscreen && mCurrentState == STATE_PREPARED) {
-            if (mMediaController == null) {
-                MediaController mc = new FullscreenMediaController(mProxy.getContext(), mLayout);
-                mc.setSystemUiVisibility(mLayout.getSystemUiVisibility());
-                mMediaController = mc;
-                mMediaController.setMediaPlayer(this);
-                mMediaController.setAnchorView(mTextureView);
-                mMediaController.setEnabled(false);
-            }
-
-            Metadata data = mPlayer.getMetadata(MediaPlayer.METADATA_ALL,
-                    MediaPlayer.BYPASS_METADATA_FILTER);
-            if (data != null) {
-                mCanPause = !data.has(Metadata.PAUSE_AVAILABLE)
-                    || data.getBoolean(Metadata.PAUSE_AVAILABLE);
-                mCanSeekBack = !data.has(Metadata.SEEK_BACKWARD_AVAILABLE)
-                    || data.getBoolean(Metadata.SEEK_BACKWARD_AVAILABLE);
-                mCanSeekForward = !data.has(Metadata.SEEK_FORWARD_AVAILABLE)
-                    || data.getBoolean(Metadata.SEEK_FORWARD_AVAILABLE);
-            } else {
-                mCanPause = mCanSeekBack = mCanSeekForward = true;
-            }
-            // mMediaController status depends on the Metadata result, so put it
-            // after reading the MetaData
-            mMediaController.setEnabled(true);
-
-            if (mAnimationState == ANIMATION_STATE_FINISHED) {
-                // If paused, should show the controller for ever!
-                if (getStartWhenPrepared() || isPlaying())
-                    mMediaController.show();
-                else
-                    mMediaController.show(0);
-            }
-        }
+    public int getTextureName() {
+        return 0;
     }
 
-    private void toggleMediaControlsVisiblity() {
-        if (mMediaController.isShowing())
-            mMediaController.hide();
-        else
-            mMediaController.show();
-    }
+    // This is true only when the player is buffering and paused
+    public boolean mPlayerBuffering = false;
 
-    public boolean fullscreenExited() {
-        return (mLayout == null);
+    public boolean getPlayerBuffering() {
+        return mPlayerBuffering;
     }
 
-    private final WebChromeClient.CustomViewCallback mCallback =
-        new WebChromeClient.CustomViewCallback() {
-            public void onCustomViewHidden() {
-                mProxy.prepareExitFullscreen();
-            }
-        };
-
-    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
+    public void setPlayerBuffering(boolean playerBuffering) {
+        mPlayerBuffering = playerBuffering;
+        switchProgressView(playerBuffering);
     }
 
-    public void onSurfaceTextureUpdated(SurfaceTexture surface) {
-    }
 
-    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
+    protected void switchProgressView(boolean playerBuffering) {
+        // Only used in HTML5VideoFullScreen
     }
 
-    /**
-     * Invoked when the specified {@link SurfaceTexture} is about to be destroyed.
-     * If returns true, no rendering should happen inside the surface texture after this method
-     * is invoked. If returns false, the client needs to call {@link SurfaceTexture#release()}.
-     *
-     * @param surface The surface about to be destroyed
-     */
-    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
-        // Tells the TextureView not to free the buffer
+    public boolean fullScreenExited() {
+        // Only meaningful for HTML5VideoFullScreen
         return false;
     }
 
-    public void enterFullscreenVideoState(WebViewClassic webView, float x, float y, float w, float h) {
-        if (mIsFullscreen == true)
-            return;
-        mIsFullscreen = true;
-        mAnimationState = ANIMATION_STATE_NONE;
-        mCurrentBufferPercentage = 0;
-        mPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
-        mInlineX = x;
-        mInlineY = y;
-        mInlineWidth = w;
-        mInlineHeight = h;
-
-        assert(mSurfaceTexture != null);
-        mTextureView = new VideoTextureView(mProxy.getContext(), getSurfaceTexture());
-        mTextureView.setOnTouchListener(this);
-        mTextureView.setFocusable(true);
-        mTextureView.setFocusableInTouchMode(true);
-        mTextureView.requestFocus();
-
-        mLayout = new FrameLayout(mProxy.getContext());
-        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
-                            ViewGroup.LayoutParams.WRAP_CONTENT,
-                            ViewGroup.LayoutParams.WRAP_CONTENT,
-                            Gravity.CENTER);
-        mTextureView.setVisibility(View.VISIBLE);
-        mTextureView.setSurfaceTextureListener(this);
-
-        mLayout.addView(mTextureView, layoutParams);
-
-        mLayout.setVisibility(View.VISIBLE);
-        WebChromeClient client = webView.getWebChromeClient();
-        if (client != null) {
-            client.onShowCustomView(mLayout, mCallback);
-            // Plugins like Flash will draw over the video so hide
-            // them while we're playing.
-            if (webView.getViewManager() != null)
-                webView.getViewManager().hideAll();
-
-            // Add progress view
-            mProgressView = client.getVideoLoadingProgressView();
-            if (mProgressView != null) {
-                mLayout.addView(mProgressView, layoutParams);
-                if (mCurrentState != STATE_PREPARED)
-                    mProgressView.setVisibility(View.VISIBLE);
-                else
-                    mProgressView.setVisibility(View.GONE);
-            }
-        }
-    }
-
-    public void exitFullscreenVideoState(float x, float y, float w, float h) {
-        if (mIsFullscreen == false) {
-            return;
-        }
-        mIsFullscreen = false;
-
-        mInlineX = x;
-        mInlineY = y;
-        mInlineWidth = w;
-        mInlineHeight = h;
-
-        // Don't show the controller after exiting the full screen.
-        if (mMediaController != null) {
-            mMediaController.hide();
-            mMediaController = null;
-        }
-
-        if (mAnimationState == ANIMATION_STATE_STARTED) {
-            mTextureView.animate().cancel();
-            finishExitingFullscreen();
-        } else {
-            // fullscreen to inline zoom in animation
-            mTextureView.animate().setListener(new AnimatorListenerAdapter() {
-                public void onAnimationEnd(Animator animation) {
-                    finishExitingFullscreen();
-                }
-            });
-
-            mTextureView.animate().setDuration(ANIMATION_DURATION);
-            mTextureView.animate().scaleX(getInlineXScale()).scaleY(getInlineYScale()).translationX(getInlineXOffset()).translationY(getInlineYOffset());
-        }
-    }
-
-    public boolean isFullscreenMode() {
-        return mIsFullscreen;
-    }
-
-    // MediaController FUNCTIONS:
-    public boolean canPause() {
-        return mCanPause;
-    }
-
-    public boolean canSeekBackward() {
-        return mCanSeekBack;
-    }
-
-    public boolean canSeekForward() {
-        return mCanSeekForward;
-    }
-
-    public int getBufferPercentage() {
-        if (mPlayer != null) {
-            return mCurrentBufferPercentage;
-        }
-        return 0;
-    }
-
     private boolean mStartWhenPrepared = false;
 
     public void setStartWhenPrepared(boolean willPlay) {
@@ -739,105 +377,7 @@ public class HTML5VideoView implements M
         return mStartWhenPrepared;
     }
 
-    public void showControllerInFullscreen() {
-        if (mMediaController != null) {
-            mMediaController.show(0);
-        }
-    }
-
-    // Other listeners functions:
-    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
-        new MediaPlayer.OnBufferingUpdateListener() {
-        public void onBufferingUpdate(MediaPlayer mp, int percent) {
-            mCurrentBufferPercentage = percent;
-        }
-    };
-
-    public boolean onTouch(View v, MotionEvent event) {
-        if (mIsFullscreen && mMediaController != null)
-            toggleMediaControlsVisiblity();
-        return false;
-    }
-
-    static class FullscreenMediaController extends MediaController {
-
-        View mVideoView;
-
-        public FullscreenMediaController(Context context, View video) {
-            super(context);
-            mVideoView = video;
-        }
-
-        @Override
-        public void show() {
-            super.show();
-            if (mVideoView != null) {
-                mVideoView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
-            }
-        }
-
-        @Override
-        public void hide() {
-            if (mVideoView != null) {
-                mVideoView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE
-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
-            }
-            super.hide();
-        }
-    }
-
-    private float getInlineXOffset() {
-        updateDisplaySize();
-        if (mInlineWidth < 0 || mInlineHeight < 0)
-            return 0;
-        else
-            return mInlineX + mWebViewLocation[0] - (mDisplaySize.x - mInlineWidth) / 2;
-    }
-
-    private float getInlineYOffset() {
-        updateDisplaySize();
-        if (mInlineWidth < 0 || mInlineHeight < 0)
-            return 0;
-        else
-            return mInlineY + mWebViewLocation[1] - (mDisplaySize.y - mInlineHeight) / 2;
-    }
-
-    private float getInlineXScale() {
-        if (mInlineWidth < 0 || mInlineHeight < 0 || mFullscreenWidth == 0)
-            return 0;
-        else
-            return mInlineWidth / mFullscreenWidth;
-    }
-
-    private float getInlineYScale() {
-        if (mInlineWidth < 0 || mInlineHeight < 0 || mFullscreenHeight == 0)
-            return 0;
-        else
-            return mInlineHeight / mFullscreenHeight;
-    }
-
-    private void updateDisplaySize() {
-        WindowManager wm = (WindowManager)mProxy.getContext().getSystemService(Context.WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-        display.getSize(mDisplaySize);
-
-        mProxy.getWebView().getWebView().getLocationOnScreen(mWebViewLocation);
-        mWebViewLocation[1] += mProxy.getWebView().getVisibleTitleHeight();
-    }
-
-    private void finishExitingFullscreen() {
-        mProxy.dispatchOnStopFullscreen();
-        mLayout.removeView(mTextureView);
-        mTextureView = null;
-        if (mProgressView != null) {
-            mLayout.removeView(mProgressView);
-            mProgressView = null;
-        }
-        mLayout = null;
-        // Re enable plugin views.
-        mProxy.getWebView().getViewManager().showAll();
-        // Set the frame available listener back to the inline listener
-        setInlineFrameAvailableListener();
+    public void showControllerInFullScreen() {
     }
 
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoViewManager.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoViewManager.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoViewManager.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoViewManager.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,108 +0,0 @@
-/* Copyright (c) 2011, Code Aurora Forum. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package android.webkit;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-
-/**
- * @hide This is only used by the browser. Manager for HTML5 video views.
- */
-class HTML5VideoViewManager
-{
-    private WebViewClassic mWebView;
-    private ArrayList<HTML5VideoViewProxy> mProxyList;
-    private final Thread mUiThread;
-
-    public HTML5VideoViewManager(WebViewClassic webView) {
-        mWebView = webView;
-        mUiThread = Thread.currentThread();
-        mProxyList = new ArrayList<HTML5VideoViewProxy>();
-    }
-
-    public boolean registerProxy(HTML5VideoViewProxy proxy) {
-        assert (mUiThread == Thread.currentThread());
-        boolean result = mProxyList.add(proxy);
-        return result;
-    }
-
-    public boolean unregisterProxy(HTML5VideoViewProxy proxy) {
-        assert (mUiThread == Thread.currentThread());
-        boolean result = mProxyList.remove(proxy);
-        return result;
-    }
-
-    public void setBaseLayer(int layer) {
-        assert (mUiThread == Thread.currentThread());
-        Iterator<HTML5VideoViewProxy> iter = mProxyList.iterator();
-        while (iter.hasNext()) {
-            HTML5VideoViewProxy proxy = iter.next();
-            proxy.setBaseLayer(layer);
-        }
-    }
-
-    public void suspend() {
-        assert (mUiThread == Thread.currentThread());
-        Iterator<HTML5VideoViewProxy> iter = mProxyList.iterator();
-        while (iter.hasNext()) {
-            HTML5VideoViewProxy proxy = iter.next();
-            proxy.suspend();
-        }
-    }
-
-    public void pauseAndDispatch() {
-        assert (mUiThread == Thread.currentThread());
-        Iterator<HTML5VideoViewProxy> iter = mProxyList.iterator();
-        while (iter.hasNext()) {
-            HTML5VideoViewProxy proxy = iter.next();
-            proxy.pauseAndDispatch();
-        }
-    }
-
-    public void enterFullscreenVideo(int layerId, String url) {
-        assert (mUiThread == Thread.currentThread());
-        Iterator<HTML5VideoViewProxy> iter = mProxyList.iterator();
-        while (iter.hasNext()) {
-            HTML5VideoViewProxy proxy = iter.next();
-            if (proxy.getVideoLayerId() == layerId)
-                proxy.webkitEnterFullscreen();
-            else
-                proxy.pauseAndDispatch();
-        }
-    }
-
-    public void exitFullscreenVideo() {
-        assert (mUiThread == Thread.currentThread());
-        Iterator<HTML5VideoViewProxy> iter = mProxyList.iterator();
-        while (iter.hasNext()) {
-            HTML5VideoViewProxy proxy = iter.next();
-            proxy.webKitExitFullscreen();
-        }
-    }
-}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoViewProxy.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoViewProxy.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HTML5VideoViewProxy.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HTML5VideoViewProxy.java	2013-03-12 17:03:37.000000000 +0100
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
- * Copyright (c) 2011, 2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,6 +31,8 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
+import android.view.KeyEvent;
+import android.view.View;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -41,14 +42,15 @@ import java.util.HashMap;
 import java.util.Map;
 
 /**
- * <p>Proxy for HTML5 video views.</p>
+ * <p>Proxy for HTML5 video views.
  */
 class HTML5VideoViewProxy extends Handler
                           implements MediaPlayer.OnPreparedListener,
                           MediaPlayer.OnCompletionListener,
                           MediaPlayer.OnErrorListener,
                           MediaPlayer.OnInfoListener,
-                          MediaPlayer.OnVideoSizeChangedListener {
+                          SurfaceTexture.OnFrameAvailableListener,
+                          View.OnKeyListener {
     // Logging tag.
     private static final String LOGTAG = "HTML5VideoViewProxy";
 
@@ -60,13 +62,7 @@ class HTML5VideoViewProxy extends Handle
     private static final int LOAD_DEFAULT_POSTER = 104;
     private static final int BUFFERING_START     = 105;
     private static final int BUFFERING_END       = 106;
-    private static final int INIT                = 107;
-    private static final int TERM                = 108;
-    private static final int SET_VOLUME          = 109;
-    private static final int LOAD                = 110;
-    private static final int LOAD_METADATA       = 111;
-    private static final int ENTER_FULLSCREEN    = 112;
-    private static final int EXIT_FULLSCREEN     = 113;
+    private static final int ENTER_FULLSCREEN    = 107;
 
     // Message Ids to be handled on the WebCore thread
     private static final int PREPARED          = 200;
@@ -74,8 +70,7 @@ class HTML5VideoViewProxy extends Handle
     private static final int POSTER_FETCHED    = 202;
     private static final int PAUSED            = 203;
     private static final int STOPFULLSCREEN    = 204;
-    private static final int SIZE_CHANGED      = 205;
-    private static final int PLAYING           = 206;
+    private static final int RESTORESTATE      = 205;
 
     // Timer thread -> UI thread
     private static final int TIMEUPDATE = 300;
@@ -93,90 +88,97 @@ class HTML5VideoViewProxy extends Handle
     private PosterDownloader mPosterDownloader;
     // The seek position.
     private int mSeekPosition;
-    // The video layer ID
-    private int mVideoLayerId;
-
     // A helper class to control the playback. This executes on the UI thread!
-    private final class VideoPlayer {
-        private HTML5VideoViewProxy mProxy;
-        private HTML5VideoView mHTML5VideoView;
-
-        private boolean isVideoSelfEnded = false;
-        // The cached volume before HTML5VideoView is initialized.
-        // This should be set back to -1.0f every time after the
-        // function mHTML5VideoView.setVolume is called.
-        private float mCachedVolume = -1.0f;
-        // Cached media position used to preserve playback position when
-        // resuming suspended video
-        private int mCachedPosition;
+    private static final class VideoPlayer {
+        // The proxy that is currently playing (if any).
+        private static HTML5VideoViewProxy mCurrentProxy;
+        // The VideoView instance. This is a singleton for now, at least until
+        // http://b/issue?id=1973663 is fixed.
+        private static HTML5VideoView mHTML5VideoView;
 
-        private void setPlayerBuffering(boolean playerBuffering) {
-            mHTML5VideoView.setPlayerBuffering(playerBuffering);
-        }
+        private static boolean isVideoSelfEnded = false;
 
-        VideoPlayer(HTML5VideoViewProxy proxy) {
-            mProxy = proxy;
+        private static void setPlayerBuffering(boolean playerBuffering) {
+            mHTML5VideoView.setPlayerBuffering(playerBuffering);
         }
 
         // Every time webView setBaseLayer, this will be called.
         // When we found the Video layer, then we set the Surface Texture to it.
-        // By using the baseLayer and the current video Layer ID, we can
-        // identify the exact layer on the UI thread to use the SurfaceTexture.
-        // We should never save the base layer handle since its lifetime is not
-        // guaranteed outside of the function call from WebView::setBaseLayer.
-        //
-        // This function allows layer value to be null. If layer is null, only
-        // the player state will be set in native code. This allows the proxy to
-        // save the player state in the native video layer.
-        public void setBaseLayer(int layer) {
-            if (mHTML5VideoView != null) {
-                int playerState = mHTML5VideoView.getCurrentState();
-                if (mHTML5VideoView.getPlayerBuffering())
-                    playerState = HTML5VideoView.STATE_BUFFERING;
-
-                nativeSendSurfaceTexture(mHTML5VideoView.getSurfaceTexture(),
-                        layer, mVideoLayerId, mHTML5VideoView.getTextureName(),
-                        playerState, mNativePointer);
-
-                // Re-attach the inline GL context
-                // TODO: Find a better place to call this.
-                mHTML5VideoView.attachToInlineGlContextIfNeeded();
+        // Otherwise, we may want to delete the Surface Texture to save memory.
+        public static void setBaseLayer(int layer) {
+            // Don't do this for full screen mode.
+            if (mHTML5VideoView != null
+                && !mHTML5VideoView.isFullScreenMode()
+                && !mHTML5VideoView.isReleased()) {
+                int currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
+                SurfaceTexture surfTexture =
+                        HTML5VideoInline.getSurfaceTexture(currentVideoLayerId);
+                int textureName = mHTML5VideoView.getTextureName();
+
+                if (layer != 0 && surfTexture != null && currentVideoLayerId != -1) {
+                    int playerState = mHTML5VideoView.getCurrentState();
+                    if (mHTML5VideoView.getPlayerBuffering())
+                        playerState = HTML5VideoView.STATE_PREPARING;
+                    boolean foundInTree = nativeSendSurfaceTexture(surfTexture,
+                            layer, currentVideoLayerId, textureName,
+                            playerState);
+                    if (playerState >= HTML5VideoView.STATE_PREPARED
+                            && !foundInTree) {
+                        mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
+                    }
+                }
             }
         }
 
-        public void suspend() {
+        // When a WebView is paused, we also want to pause the video in it.
+        public static void pauseAndDispatch() {
             if (mHTML5VideoView != null) {
-                mHTML5VideoView.pause();
-                mCachedPosition = getCurrentPosition();
-                mHTML5VideoView.release();
-                // Call setBaseLayer to update VideoLayerAndroid player state
-                // This is important for flagging the associated texture for recycling
-                setBaseLayer(0);
-                mHTML5VideoView = null;
-                // isVideoSelfEnded is false when video playback
-                // has ended but is not complete.
-                // isVideoSelfEnded is true only when playback is complete.
-                isVideoSelfEnded = false;
-                end();
-            }
-        }
-
-        public void enterFullscreenVideo(String url, float x, float y, float w, float h) {
-            if (ensureHTML5VideoView(url, mCachedPosition, false)) {
-                mHTML5VideoView.prepareDataAndDisplayMode();
+                mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
             }
-            mHTML5VideoView.enterFullscreenVideoState(mWebView, x, y, w, h);
         }
 
-        public void exitFullscreenVideo(float x, float y, float w, float h) {
-            if (mHTML5VideoView != null) {
-                mHTML5VideoView.exitFullscreenVideoState(x, y, w, h);
-            }
+        public static void enterFullScreenVideo(int layerId, String url,
+                HTML5VideoViewProxy proxy, WebViewClassic webView) {
+                // Save the inline video info and inherit it in the full screen
+                int savePosition = 0;
+                boolean canSkipPrepare = false;
+                boolean forceStart = false;
+                if (mHTML5VideoView != null) {
+                    // We don't allow enter full screen mode while the previous
+                    // full screen video hasn't finished yet.
+                    if (!mHTML5VideoView.fullScreenExited() && mHTML5VideoView.isFullScreenMode()) {
+                        Log.w(LOGTAG, "Try to reenter the full screen mode");
+                        return;
+                    }
+                    int playerState = mHTML5VideoView.getCurrentState();
+                    // If we are playing the same video, then it is better to
+                    // save the current position.
+                    if (layerId == mHTML5VideoView.getVideoLayerId()) {
+                        savePosition = mHTML5VideoView.getCurrentPosition();
+                        canSkipPrepare = (playerState == HTML5VideoView.STATE_PREPARING
+                                || playerState == HTML5VideoView.STATE_PREPARED
+                                || playerState == HTML5VideoView.STATE_PLAYING)
+                                && !mHTML5VideoView.isFullScreenMode();
+                    }
+                    if (!canSkipPrepare) {
+                        mHTML5VideoView.reset();
+                    } else {
+                        forceStart = playerState == HTML5VideoView.STATE_PREPARING
+                                || playerState == HTML5VideoView.STATE_PLAYING;
+                    }
+                }
+                mHTML5VideoView = new HTML5VideoFullScreen(proxy.getContext(),
+                        layerId, savePosition, canSkipPrepare);
+                mHTML5VideoView.setStartWhenPrepared(forceStart);
+                mCurrentProxy = proxy;
+                mHTML5VideoView.setVideoURI(url, mCurrentProxy);
+                mHTML5VideoView.enterFullScreenVideoState(layerId, proxy, webView);
         }
 
-        public void webkitExitFullscreenVideo() {
-            if (!mHTML5VideoView.fullscreenExited() && mHTML5VideoView.isFullscreenMode()) {
-                WebChromeClient client = mWebView.getWebChromeClient();
+        public static void exitFullScreenVideo(HTML5VideoViewProxy proxy,
+                WebViewClassic webView) {
+            if (!mHTML5VideoView.fullScreenExited() && mHTML5VideoView.isFullScreenMode()) {
+                WebChromeClient client = webView.getWebChromeClient();
                 if (client != null) {
                     client.onHideCustomView();
                 }
@@ -184,36 +186,83 @@ class HTML5VideoViewProxy extends Handle
         }
 
         // This is on the UI thread.
-        public void loadMetadata(String url) {
-            if (ensureHTML5VideoView(url, 0, false)) {
-                mHTML5VideoView.retrieveMetadata(mProxy);
+        // When native tell Java to play, we need to check whether or not it is
+        // still the same video by using videoLayerId and treat it differently.
+        public static void play(String url, int time, HTML5VideoViewProxy proxy,
+                WebChromeClient client, int videoLayerId) {
+            int currentVideoLayerId = -1;
+            boolean backFromFullScreenMode = false;
+            if (mHTML5VideoView != null) {
+                currentVideoLayerId = mHTML5VideoView.getVideoLayerId();
+                backFromFullScreenMode = mHTML5VideoView.fullScreenExited();
+
+                // When playing video back to back in full screen mode,
+                // javascript will switch the src and call play.
+                // In this case, we can just reuse the same full screen view,
+                // and play the video after prepared.
+                if (mHTML5VideoView.isFullScreenMode()
+                    && !backFromFullScreenMode
+                    && currentVideoLayerId != videoLayerId
+                    && mCurrentProxy != proxy) {
+                    mCurrentProxy = proxy;
+                    mHTML5VideoView.setStartWhenPrepared(true);
+                    mHTML5VideoView.setVideoURI(url, proxy);
+                    mHTML5VideoView.reprepareData(proxy);
+                    return;
+                }
             }
-        }
 
-        public void load(String url) {
-            if (ensureHTML5VideoView(url, 0, false)) {
-                mHTML5VideoView.prepareDataAndDisplayMode();
+            boolean skipPrepare = false;
+            boolean createInlineView = false;
+            if (backFromFullScreenMode
+                && currentVideoLayerId == videoLayerId
+                && !mHTML5VideoView.isReleased()) {
+                skipPrepare = true;
+                createInlineView = true;
+            } else if(backFromFullScreenMode
+                || currentVideoLayerId != videoLayerId
+                || HTML5VideoInline.surfaceTextureDeleted()) {
+                // Here, we handle the case when switching to a new video,
+                // either inside a WebView or across WebViews
+                // For switching videos within a WebView or across the WebView,
+                // we need to pause the old one and re-create a new media player
+                // inside the HTML5VideoView.
+                if (mHTML5VideoView != null) {
+                    if (!backFromFullScreenMode) {
+                        mHTML5VideoView.pauseAndDispatch(mCurrentProxy);
+                    }
+                    mHTML5VideoView.reset();
+                }
+                createInlineView = true;
+            }
+            if (createInlineView) {
+                mCurrentProxy = proxy;
+                mHTML5VideoView = new HTML5VideoInline(videoLayerId, time, skipPrepare);
+
+                mHTML5VideoView.setVideoURI(url, mCurrentProxy);
+                mHTML5VideoView.prepareDataAndDisplayMode(proxy);
+                return;
             }
-        }
 
-        public void play(String url, int time) {
-            if (ensureHTML5VideoView(url, time, true)) {
-                mHTML5VideoView.prepareDataAndDisplayMode();
-                mHTML5VideoView.seekTo(time);
-            } else {
+            if (mCurrentProxy == proxy) {
                 // Here, we handle the case when we keep playing with one video
                 if (!mHTML5VideoView.isPlaying()) {
+                    mHTML5VideoView.seekTo(time);
                     mHTML5VideoView.start();
-                    setBaseLayer(0);
                 }
+            } else if (mCurrentProxy != null) {
+                // Some other video is already playing. Notify the caller that
+                // its playback ended.
+                proxy.dispatchOnEnded();
             }
         }
 
-        public boolean isPlaying() {
-            return (mHTML5VideoView != null && mHTML5VideoView.isPlaying());
+        public static boolean isPlaying(HTML5VideoViewProxy proxy) {
+            return (mCurrentProxy == proxy && mHTML5VideoView != null
+                    && mHTML5VideoView.isPlaying());
         }
 
-        public int getCurrentPosition() {
+        public static int getCurrentPosition() {
             int currentPosMs = 0;
             if (mHTML5VideoView != null) {
                 currentPosMs = mHTML5VideoView.getCurrentPosition();
@@ -221,69 +270,41 @@ class HTML5VideoViewProxy extends Handle
             return currentPosMs;
         }
 
-        public void seek(int time) {
-            if (time >= 0 && mHTML5VideoView != null) {
+        public static void seek(int time, HTML5VideoViewProxy proxy) {
+            if (mCurrentProxy == proxy && time >= 0 && mHTML5VideoView != null) {
                 mHTML5VideoView.seekTo(time);
             }
         }
 
-        public void pause() {
-            if (mHTML5VideoView != null) {
+        public static void pause(HTML5VideoViewProxy proxy) {
+            if (mCurrentProxy == proxy && mHTML5VideoView != null) {
                 mHTML5VideoView.pause();
             }
         }
 
-        public void onPrepared() {
-            if (mCachedVolume >= 0.0f) {
-                mHTML5VideoView.setVolume(mCachedVolume);
-                mCachedVolume = -1.0f;
-            }
-            setBaseLayer(0);
+        public static void onPrepared() {
+            if (!mHTML5VideoView.isFullScreenMode()) {
+                mHTML5VideoView.start();
+            }
         }
 
-        public void end() {
-            if (mHTML5VideoView != null)
-                mHTML5VideoView.showControllerInFullscreen();
-            if (mProxy != null) {
+        public static void end() {
+            mHTML5VideoView.showControllerInFullScreen();
+            if (mCurrentProxy != null) {
                 if (isVideoSelfEnded)
-                    mProxy.dispatchOnEnded();
+                    mCurrentProxy.dispatchOnEnded();
                 else
-                    mProxy.dispatchOnPaused();
+                    mCurrentProxy.dispatchOnPaused();
             }
             isVideoSelfEnded = false;
         }
-
-        public void setVolume(float volume) {
-            if (mHTML5VideoView != null) {
-                mHTML5VideoView.setVolume(volume);
-                mCachedVolume = -1.0f;
-            } else {
-                mCachedVolume = volume;
-            }
-        }
-
-        // Return true if we have to allocate a new HTML5VideoView.
-        // Otherwise return false and we can reuse the previously allocated HTML5VideoView
-        private boolean ensureHTML5VideoView(String url, int time, boolean willPlay) {
-            if (mHTML5VideoView == null) {
-                mHTML5VideoView = new HTML5VideoView(mProxy, time);
-                mHTML5VideoView.setStartWhenPrepared(willPlay);
-                mHTML5VideoView.setVideoURI(url);
-                return true;
-            }
-            return false;
-        }
-
-        public boolean isPrepared() {
-            return mHTML5VideoView.getCurrentState() >= HTML5VideoView.STATE_PREPARED;
-        }
     }
-    private VideoPlayer mVideoPlayer;
 
     // A bunch event listeners for our VideoView
     // MediaPlayer.OnPreparedListener
+    @Override
     public void onPrepared(MediaPlayer mp) {
-        mVideoPlayer.onPrepared();
+        VideoPlayer.onPrepared();
         Message msg = Message.obtain(mWebCoreHandler, PREPARED);
         Map<String, Object> map = new HashMap<String, Object>();
         map.put("dur", new Integer(mp.getDuration()));
@@ -293,21 +314,8 @@ class HTML5VideoViewProxy extends Handle
         mWebCoreHandler.sendMessage(msg);
     }
 
-    //MediaPlayer.OnVideoSizeChangedListener
-    public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
-        Message msg = Message.obtain(mWebCoreHandler, SIZE_CHANGED);
-        Map<String, Object> map = new HashMap<String, Object>();
-        if (mVideoPlayer.isPrepared())
-            map.put("dur", new Integer(mp.getDuration()));
-        else
-            map.put("dur", new Integer(0));
-        map.put("width", new Integer(width));
-        map.put("height", new Integer(height));
-        msg.obj = map;
-        mWebCoreHandler.sendMessage(msg);
-    }
-
     // MediaPlayer.OnCompletionListener;
+    @Override
     public void onCompletion(MediaPlayer mp) {
         // The video ended by itself, so we need to
         // send a message to the UI thread to dismiss
@@ -317,6 +325,7 @@ class HTML5VideoViewProxy extends Handle
     }
 
     // MediaPlayer.OnErrorListener
+    @Override
     public boolean onError(MediaPlayer mp, int what, int extra) {
         sendMessage(obtainMessage(ERROR));
         return false;
@@ -332,23 +341,14 @@ class HTML5VideoViewProxy extends Handle
         mWebCoreHandler.sendMessage(msg);
     }
 
-    public void dispatchOnPlaying() {
-        Message msg = Message.obtain(mWebCoreHandler, PLAYING);
-        mWebCoreHandler.sendMessage(msg);
-    }
-
-    public void dispatchOnStopFullscreen() {
+    public void dispatchOnStopFullScreen(boolean stillPlaying) {
         Message msg = Message.obtain(mWebCoreHandler, STOPFULLSCREEN);
+        msg.arg1 = stillPlaying ? 1 : 0;
         mWebCoreHandler.sendMessage(msg);
     }
 
-    public void updateSizeAndDuration(int width, int height, int duration) {
-        Message msg = Message.obtain(mWebCoreHandler, SIZE_CHANGED);
-        Map<String, Object> map = new HashMap<String, Object>();
-        map.put("dur", new Integer(duration));
-        map.put("width", new Integer(width));
-        map.put("height", new Integer(height));
-        msg.obj = map;
+    public void dispatchOnRestoreState() {
+        Message msg = Message.obtain(mWebCoreHandler, RESTORESTATE);
         mWebCoreHandler.sendMessage(msg);
     }
 
@@ -356,6 +356,14 @@ class HTML5VideoViewProxy extends Handle
         sendMessage(obtainMessage(TIMEUPDATE));
     }
 
+    // When there is a frame ready from surface texture, we should tell WebView
+    // to refresh.
+    @Override
+    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
+        // TODO: This should support partial invalidation too.
+        mWebView.invalidate();
+    }
+
     // Handler for the messages from WebCore or Timer thread to the UI thread.
     @Override
     public void handleMessage(Message msg) {
@@ -363,34 +371,36 @@ class HTML5VideoViewProxy extends Handle
         switch (msg.what) {
             case PLAY: {
                 String url = (String) msg.obj;
-                int seekPosition = msg.arg1;
-                mVideoPlayer.play(url, seekPosition);
-                break;
-            }
-            case LOAD_METADATA: {
-                String url = (String) msg.obj;
-                mVideoPlayer.loadMetadata(url);
+                WebChromeClient client = mWebView.getWebChromeClient();
+                int videoLayerID = msg.arg1;
+                if (client != null) {
+                    VideoPlayer.play(url, mSeekPosition, this, client, videoLayerID);
+                }
                 break;
             }
-            case LOAD: {
+            case ENTER_FULLSCREEN:{
                 String url = (String) msg.obj;
-                mVideoPlayer.load(url);
+                WebChromeClient client = mWebView.getWebChromeClient();
+                int videoLayerID = msg.arg1;
+                if (client != null) {
+                    VideoPlayer.enterFullScreenVideo(videoLayerID, url, this, mWebView);
+                }
                 break;
             }
             case SEEK: {
                 Integer time = (Integer) msg.obj;
                 mSeekPosition = time;
-                mVideoPlayer.seek(mSeekPosition);
+                VideoPlayer.seek(mSeekPosition, this);
                 break;
             }
             case PAUSE: {
-                mVideoPlayer.pause();
+                VideoPlayer.pause(this);
                 break;
             }
             case ENDED:
                 if (msg.arg1 == 1)
-                    mVideoPlayer.isVideoSelfEnded = true;
-                mVideoPlayer.end();
+                    VideoPlayer.isVideoSelfEnded = true;
+                VideoPlayer.end();
                 break;
             case ERROR: {
                 WebChromeClient client = mWebView.getWebChromeClient();
@@ -407,46 +417,17 @@ class HTML5VideoViewProxy extends Handle
                 break;
             }
             case TIMEUPDATE: {
-                if (mVideoPlayer.isPlaying()) {
+                if (VideoPlayer.isPlaying(this)) {
                     sendTimeupdate();
                 }
                 break;
             }
             case BUFFERING_START: {
-                mVideoPlayer.setPlayerBuffering(true);
+                VideoPlayer.setPlayerBuffering(true);
                 break;
             }
             case BUFFERING_END: {
-                mVideoPlayer.setPlayerBuffering(false);
-                break;
-            }
-            case INIT: {
-                // Pass Proxy into webview, such that every time we have a setBaseLayer
-                // call, we tell this Proxy to call the native to update the layer tree
-                // for the Video Layer's surface texture info
-                mWebView.registerHTML5VideoViewProxy(this);
-                break;
-            }
-            case TERM: {
-                mVideoPlayer.suspend();
-                mWebView.unregisterHTML5VideoViewProxy(this);
-                break;
-            }
-            case SET_VOLUME: {
-                float vol = ((Float)msg.obj).floatValue();
-                mVideoPlayer.setVolume(vol);
-                break;
-            }
-            case ENTER_FULLSCREEN: {
-                InlineVideoInfo info = (InlineVideoInfo)msg.obj;
-                mVideoPlayer.enterFullscreenVideo(info.getUrl(),
-                        info.getX(), info.getY(), info.getWidth(), info.getHeight());
-                break;
-            }
-            case EXIT_FULLSCREEN: {
-                InlineVideoInfo info = (InlineVideoInfo)msg.obj;
-                mVideoPlayer.exitFullscreenVideo(info.getX(), info.getY(),
-                        info.getWidth(), info.getHeight());
+                VideoPlayer.setPlayerBuffering(false);
                 break;
             }
         }
@@ -510,6 +491,7 @@ class HTML5VideoViewProxy extends Handle
             releaseQueue();
         }
         // EventHandler methods. Executed on the network thread.
+        @Override
         public void status(int major_version,
                 int minor_version,
                 int code,
@@ -517,10 +499,12 @@ class HTML5VideoViewProxy extends Handle
             mStatusCode = code;
         }
 
+        @Override
         public void headers(Headers headers) {
             mHeaders = headers;
         }
 
+        @Override
         public void data(byte[] data, int len) {
             if (mPosterBytes == null) {
                 mPosterBytes = new ByteArrayOutputStream();
@@ -528,6 +512,7 @@ class HTML5VideoViewProxy extends Handle
             mPosterBytes.write(data, 0, len);
         }
 
+        @Override
         public void endData() {
             if (mStatusCode == 200) {
                 if (mPosterBytes.size() > 0) {
@@ -545,6 +530,7 @@ class HTML5VideoViewProxy extends Handle
                 }
                 if (mUrl != null) {
                     mHandler.post(new Runnable() {
+                       @Override
                        public void run() {
                            if (mRequestHandle != null) {
                                mRequestHandle.setupRedirect(mUrl.toString(), mStatusCode,
@@ -556,14 +542,17 @@ class HTML5VideoViewProxy extends Handle
             }
         }
 
+        @Override
         public void certificate(SslCertificate certificate) {
             // Don't care.
         }
 
+        @Override
         public void error(int id, String description) {
             cleanup();
         }
 
+        @Override
         public boolean handleSslErrorRequest(SslError error) {
             // Don't care. If this happens, data() will never be called so
             // mPosterBytes will never be created, so no need to call cleanup.
@@ -606,21 +595,19 @@ class HTML5VideoViewProxy extends Handle
      * @param webView is the WebView that hosts the video.
      * @param nativePtr is the C++ pointer to the MediaPlayerPrivate object.
      */
-    private HTML5VideoViewProxy(WebViewClassic webView, int nativePtr, int videoLayerId) {
+    private HTML5VideoViewProxy(WebViewClassic webView, int nativePtr) {
         // This handler is for the main (UI) thread.
         super(Looper.getMainLooper());
         // Save the WebView object.
         mWebView = webView;
+        // Pass Proxy into webview, such that every time we have a setBaseLayer
+        // call, we tell this Proxy to call the native to update the layer tree
+        // for the Video Layer's surface texture info
+        mWebView.setHTML5VideoViewProxy(this);
         // Save the native ptr
         mNativePointer = nativePtr;
-        // Save the videoLayerId. This is needed early in order to support fullscreen mode
-        // before video playback
-        mVideoLayerId = videoLayerId;
         // create the message handler for this thread
         createWebCoreHandler();
-        mVideoPlayer = new VideoPlayer(this);
-        Message message = obtainMessage(INIT);
-        sendMessage(message);
     }
 
     private void createWebCoreHandler() {
@@ -637,15 +624,6 @@ class HTML5VideoViewProxy extends Handle
                                 height.intValue(), mNativePointer);
                         break;
                     }
-                    case SIZE_CHANGED: {
-                        Map<String, Object> map = (Map<String, Object>) msg.obj;
-                        Integer duration = (Integer) map.get("dur");
-                        Integer width = (Integer) map.get("width");
-                        Integer height = (Integer) map.get("height");
-                        nativeOnSizeChanged(duration.intValue(), width.intValue(),
-                                height.intValue(), mNativePointer);
-                        break;
-                    }
                     case ENDED:
                         mSeekPosition = 0;
                         nativeOnEnded(mNativePointer);
@@ -653,9 +631,6 @@ class HTML5VideoViewProxy extends Handle
                     case PAUSED:
                         nativeOnPaused(mNativePointer);
                         break;
-                    case PLAYING:
-                        nativeOnPlaying(mNativePointer);
-                        break;
                     case POSTER_FETCHED:
                         Bitmap poster = (Bitmap) msg.obj;
                         nativeOnPosterFetched(poster, mNativePointer);
@@ -664,7 +639,10 @@ class HTML5VideoViewProxy extends Handle
                         nativeOnTimeupdate(msg.arg1, mNativePointer);
                         break;
                     case STOPFULLSCREEN:
-                        nativeOnStopFullscreen(mNativePointer);
+                        nativeOnStopFullscreen(msg.arg1, mNativePointer);
+                        break;
+                    case RESTORESTATE:
+                        nativeOnRestoreState(mNativePointer);
                         break;
                 }
             }
@@ -684,7 +662,7 @@ class HTML5VideoViewProxy extends Handle
 
     private void sendTimeupdate() {
         Message msg = Message.obtain(mWebCoreHandler, TIMEUPDATE);
-        msg.arg1 = mVideoPlayer.getCurrentPosition();
+        msg.arg1 = VideoPlayer.getCurrentPosition();
         mWebCoreHandler.sendMessage(msg);
     }
 
@@ -697,38 +675,31 @@ class HTML5VideoViewProxy extends Handle
      * Play a video stream.
      * @param url is the URL of the video stream.
      */
-    public void play(String url, int position) {
+    public void play(String url, int position, int videoLayerID) {
         if (url == null) {
             return;
         }
-        Message message = obtainMessage(PLAY);
-        message.arg1 = position;
-        message.obj = url;
-        sendMessage(message);
-    }
 
-    /**
-     * Load a video stream.
-     * @param url is the URL of the video stream.
-     */
-    public void loadVideo(String url) {
-        if (url == null) {
-            return;
+        if (position > 0) {
+            seek(position);
         }
-        Message message = obtainMessage(LOAD);
+        Message message = obtainMessage(PLAY);
+        message.arg1 = videoLayerID;
         message.obj = url;
         sendMessage(message);
     }
 
     /**
-     * Load video metadata.
+     * Play a video stream in full screen mode.
      * @param url is the URL of the video stream.
      */
-    public void loadMetadata(String url) {
+    public void enterFullscreenForVideoLayer(String url, int videoLayerID) {
         if (url == null) {
             return;
         }
-        Message message = obtainMessage(LOAD_METADATA);
+
+        Message message = obtainMessage(ENTER_FULLSCREEN);
+        message.arg1 = videoLayerID;
         message.obj = url;
         sendMessage(message);
     }
@@ -760,8 +731,6 @@ class HTML5VideoViewProxy extends Handle
         if (mPosterDownloader != null) {
             mPosterDownloader.cancelAndReleaseQueue();
         }
-        Message message = obtainMessage(TERM);
-        sendMessage(message);
         mNativePointer = 0;
     }
 
@@ -784,94 +753,21 @@ class HTML5VideoViewProxy extends Handle
         mPosterDownloader.start();
     }
 
-    public void enterFullscreen(String url, float x, float y, float w, float h) {
-        if (url == null)
-            return;
-        Message message = obtainMessage(ENTER_FULLSCREEN);
-        message.obj = new InlineVideoInfo(url, x, y, w, h);
-        sendMessage(message);
-    }
-
-    public void exitFullscreen(float x, float y, float w, float h) {
-        Message message = obtainMessage(EXIT_FULLSCREEN);
-        message.obj = new InlineVideoInfo(null, x, y, w, h);
-        sendMessage(message);
-    }
-
-    private static final class InlineVideoInfo {
-        private String mUrl;
-        private float mX;
-        private float mY;
-        private float mWidth;
-        private float mHeight;
-
-        public InlineVideoInfo(String url, float x, float y, float w, float h) {
-            mUrl = url;
-            mX = x;
-            mY = y;
-            mWidth = w;
-            mHeight = h;
-        }
-
-        public String getUrl() {
-            return mUrl;
-        }
-
-        public float getX() {
-            return mX;
-        }
-
-        public float getY() {
-            return mY;
-        }
-
-        public float getWidth() {
-            return mWidth;
-        }
-
-        public float getHeight() {
-            return mHeight;
-        }
-    }
-
-    // These functions are called from UI thread only by WebView.
+    // These three function are called from UI thread only by WebView.
     public void setBaseLayer(int layer) {
-        mVideoPlayer.setBaseLayer(layer);
+        VideoPlayer.setBaseLayer(layer);
     }
 
     public void pauseAndDispatch() {
-        // mVideoPlayer.pause will always dispatch notification
-        mVideoPlayer.pause();
-    }
-
-    public void suspend() {
-        mVideoPlayer.suspend();
-    }
-
-    public void webkitEnterFullscreen() {
-        nativePrepareEnterFullscreen(mNativePointer);
-    }
-
-    public void prepareExitFullscreen() {
-        nativePrepareExitFullscreen(mNativePointer);
+        VideoPlayer.pauseAndDispatch();
     }
 
-    public void webKitExitFullscreen() {
-        mVideoPlayer.webkitExitFullscreenVideo();
+    public void enterFullScreenVideo(int layerId, String url) {
+        VideoPlayer.enterFullScreenVideo(layerId, url, this, mWebView);
     }
 
-    public int getVideoLayerId() {
-        return mVideoLayerId;
-    }
-    // End functions called from UI thread only by WebView
-
-    /**
-     * Change the volume of the playback
-     */
-    public void setVolume(float volume) {
-        Message message = obtainMessage(SET_VOLUME);
-        message.obj = new Float(volume);
-        sendMessage(message);
+    public void exitFullScreenVideo() {
+        VideoPlayer.exitFullScreenVideo(this, mWebView);
     }
 
     /**
@@ -880,8 +776,8 @@ class HTML5VideoViewProxy extends Handle
      *
      * @return a new HTML5VideoViewProxy object.
      */
-    public static HTML5VideoViewProxy getInstance(WebViewCore webViewCore, int nativePtr, int videoLayerId) {
-        return new HTML5VideoViewProxy(webViewCore.getWebViewClassic(), nativePtr, videoLayerId);
+    public static HTML5VideoViewProxy getInstance(WebViewCore webViewCore, int nativePtr) {
+        return new HTML5VideoViewProxy(webViewCore.getWebViewClassic(), nativePtr);
     }
 
     /* package */ WebViewClassic getWebView() {
@@ -889,18 +785,15 @@ class HTML5VideoViewProxy extends Handle
     }
 
     private native void nativeOnPrepared(int duration, int width, int height, int nativePointer);
-    private native void nativeOnSizeChanged(int duration, int width, int height, int nativePointer);
     private native void nativeOnEnded(int nativePointer);
     private native void nativeOnPaused(int nativePointer);
-    private native void nativeOnPlaying(int nativePointer);
     private native void nativeOnPosterFetched(Bitmap poster, int nativePointer);
     private native void nativeOnTimeupdate(int position, int nativePointer);
-    private native void nativeOnStopFullscreen(int nativePointer);
+    private native void nativeOnStopFullscreen(int stillPlaying, int nativePointer);
+    private native void nativeOnRestoreState(int nativePointer);
     private native static boolean nativeSendSurfaceTexture(SurfaceTexture texture,
             int baseLayer, int videoLayerId, int textureName,
-            int playerState, int nativePointer);
-    private native void nativePrepareEnterFullscreen(int nativePointer);
-    private native void nativePrepareExitFullscreen(int nativePoint);
+            int playerState);
 
     @Override
     public boolean onInfo(MediaPlayer mp, int what, int extra) {
@@ -911,4 +804,17 @@ class HTML5VideoViewProxy extends Handle
         }
         return false;
     }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                return true;
+            } else if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
+                VideoPlayer.exitFullScreenVideo(this, mWebView);
+                return true;
+            }
+        }
+        return false;
+    }
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/HttpAuthHandler.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HttpAuthHandler.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/HttpAuthHandler.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/HttpAuthHandler.java	2013-03-12 17:03:37.000000000 +0100
@@ -19,40 +19,51 @@ package android.webkit;
 import android.os.Handler;
 
 /**
- * HTTP authentication request that must be handled by the user interface.
- * WebView creates the object and hands it to the current {@link WebViewClient},
- * which must call either {@link #proceed(String, String)} or {@link #cancel()}.
+ * Represents a request for HTTP authentication. Instances of this class are
+ * created by the WebView and passed to
+ * {@link WebViewClient#onReceivedHttpAuthRequest}. The host application must
+ * call either {@link #proceed} or {@link #cancel} to set the WebView's
+ * response to the request.
  */
 public class HttpAuthHandler extends Handler {
 
     /**
-     * Package-private constructor needed for API compatibility.
+     * @hide Only for use by WebViewProvider implementations.
      */
-    HttpAuthHandler() {
+    public HttpAuthHandler() {
     }
 
     /**
-     * @return True if we can use user credentials on record
-     * (ie, if we did not fail trying to use them last time)
+     * Gets whether the credentials stored for the current host (i.e. the host
+     * for which {@link WebViewClient#onReceivedHttpAuthRequest} was called)
+     * are suitable for use. Credentials are not suitable if they have
+     * previously been rejected by the server for the current request.
+     *
+     * @return whether the credentials are suitable for use
+     * @see Webview#getHttpAuthUsernamePassword
      */
     public boolean useHttpAuthUsernamePassword() {
         return false;
     }
 
     /**
-     * Cancel the authorization request.
+     * Instructs the WebView to cancel the authentication request.
      */
     public void cancel() {
     }
 
     /**
-     * Proceed with the authorization with the given credentials.
+     * Instructs the WebView to proceed with the authentication with the given
+     * credentials. Credentials for use with this method can be retrieved from
+     * the WebView's store using {@link WebView#getHttpAuthUsernamePassword}.
      */
     public void proceed(String username, String password) {
     }
 
     /**
-     * return true if the prompt dialog should be suppressed.
+     * Gets whether the prompt dialog should be suppressed.
+     *
+     * @return whether the prompt dialog should be suppressed
      * @hide
      */
     public boolean suppressDialog() {
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/JavascriptInterface.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/JavascriptInterface.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/JavascriptInterface.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/JavascriptInterface.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Annotation that allows exposing methods to JavaScript. Starting from API level
+ * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1} and above, only methods explicitly
+ * marked with this annotation are available to the Javascript code. See
+ * {@link android.webkit.WebView#addJavascriptInterface} for more information about it.
+ *
+ */
+@SuppressWarnings("javadoc")
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+public @interface JavascriptInterface {
+}
\ No newline at end of file
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/JniUtil.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/JniUtil.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/JniUtil.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/JniUtil.java	2013-03-12 17:03:37.000000000 +0100
@@ -173,8 +173,8 @@ class JniUtil {
         checkInitialized();
         // If the device has not checked in it won't have pulled down the system setting for the
         // Autofill Url. In that case we will not make autofill server requests.
-        return Settings.Secure.getString(sContext.getContentResolver(),
-                Settings.Secure.WEB_AUTOFILL_QUERY_URL);
+        return Settings.Global.getString(sContext.getContentResolver(),
+                Settings.Global.WEB_AUTOFILL_QUERY_URL);
     }
 
     private static boolean canSatisfyMemoryAllocation(long bytesRequested) {
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/MockGeolocation.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/MockGeolocation.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/MockGeolocation.java	2013-03-12 17:09:11.250011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/MockGeolocation.java	2013-03-12 17:03:37.000000000 +0100
@@ -17,21 +17,29 @@
 package android.webkit;
 
 /**
- * This class is simply a container for the methods used to configure WebKit's
- * mock Geolocation service for use in LayoutTests.
+ * Used to configure the mock Geolocation client for the LayoutTests.
  * @hide
  */
 public final class MockGeolocation {
+    private WebViewCore mWebViewCore;
 
-    // Global instance of a MockGeolocation
-    private static MockGeolocation sMockGeolocation;
+    public MockGeolocation(WebViewCore webViewCore) {
+        mWebViewCore = webViewCore;
+    }
+
+    /**
+     * Sets use of the mock Geolocation client. Also resets that client.
+     */
+    public void setUseMock() {
+        nativeSetUseMock(mWebViewCore);
+    }
 
     /**
      * Set the position for the mock Geolocation service.
      */
     public void setPosition(double latitude, double longitude, double accuracy) {
         // This should only ever be called on the WebKit thread.
-        nativeSetPosition(latitude, longitude, accuracy);
+        nativeSetPosition(mWebViewCore, latitude, longitude, accuracy);
     }
 
     /**
@@ -39,21 +47,18 @@ public final class MockGeolocation {
      */
     public void setError(int code, String message) {
         // This should only ever be called on the WebKit thread.
-        nativeSetError(code, message);
+        nativeSetError(mWebViewCore, code, message);
     }
 
-    /**
-     * Get the global instance of MockGeolocation.
-     * @return The global MockGeolocation instance.
-     */
-    public static MockGeolocation getInstance() {
-      if (sMockGeolocation == null) {
-          sMockGeolocation = new MockGeolocation();
-      }
-      return sMockGeolocation;
+    public void setPermission(boolean allow) {
+        // This should only ever be called on the WebKit thread.
+        nativeSetPermission(mWebViewCore, allow);
     }
 
     // Native functions
-    private static native void nativeSetPosition(double latitude, double longitude, double accuracy);
-    private static native void nativeSetError(int code, String message);
+    private static native void nativeSetUseMock(WebViewCore webViewCore);
+    private static native void nativeSetPosition(WebViewCore webViewCore, double latitude,
+            double longitude, double accuracy);
+    private static native void nativeSetError(WebViewCore webViewCore, int code, String message);
+    private static native void nativeSetPermission(WebViewCore webViewCore, boolean allow);
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/package.html /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/package.html
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/package.html	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/package.html	2013-03-12 17:03:37.000000000 +0100
@@ -1,7 +1,7 @@
 <html>
 <body>
-Provides tools for browsing the web.
-<p>The only classes or interfaces in this package intended for use by SDK
-developers are WebView, BroswerCallbackAdapter, BrowserCallback, and CookieManager.
+<p>Provides tools for browsing the web.
+<p>For more information about building apps with web-based content, see the
+<a href="{@docRoot}guide/webapps/overview.html">Web Apps Overview</a>.
 </body>
 </html>
\ No newline at end of file
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/SearchBoxImpl.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SearchBoxImpl.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/SearchBoxImpl.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SearchBoxImpl.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,304 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.webkit;
-
-import android.text.TextUtils;
-import android.util.Log;
-import android.webkit.WebViewCore.EventHub;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.json.JSONStringer;
-
-/**
- * The default implementation of the SearchBox interface. Implemented
- * as a java bridge object and a javascript adapter that is called into
- * by the page hosted in the frame.
- */
-final class SearchBoxImpl implements SearchBox {
-    private static final String TAG = "WebKit.SearchBoxImpl";
-
-    /* package */ static final String JS_INTERFACE_NAME = "searchBoxJavaBridge_";
-
-    /* package */ static final String JS_BRIDGE
-            = "(function()"
-            + "{"
-            + "if (!window.chrome) {"
-            + "  window.chrome = {};"
-            + "}"
-            + "if (!window.chrome.searchBox) {"
-            + "  var sb = window.chrome.searchBox = {};"
-            + "  sb.setSuggestions = function(suggestions) {"
-            + "    if (window.searchBoxJavaBridge_) {"
-            + "      window.searchBoxJavaBridge_.setSuggestions(JSON.stringify(suggestions));"
-            + "    }"
-            + "  };"
-            + "  sb.setValue = function(valueArray) { sb.value = valueArray[0]; };"
-            + "  sb.value = '';"
-            + "  sb.x = 0;"
-            + "  sb.y = 0;"
-            + "  sb.width = 0;"
-            + "  sb.height = 0;"
-            + "  sb.selectionStart = 0;"
-            + "  sb.selectionEnd = 0;"
-            + "  sb.verbatim = false;"
-            + "}"
-            + "})();";
-
-    private static final String SET_QUERY_SCRIPT
-            = "if (window.chrome && window.chrome.searchBox) {"
-            + "  window.chrome.searchBox.setValue(%s);"
-            + "}";
-
-    private static final String SET_VERBATIM_SCRIPT
-            =  "if (window.chrome && window.chrome.searchBox) {"
-            + "  window.chrome.searchBox.verbatim = %1$s;"
-            + "}";
-
-    private static final String SET_SELECTION_SCRIPT
-            = "if (window.chrome && window.chrome.searchBox) {"
-            + "  var f = window.chrome.searchBox;"
-            + "  f.selectionStart = %d"
-            + "  f.selectionEnd = %d"
-            + "}";
-
-    private static final String SET_DIMENSIONS_SCRIPT
-            = "if (window.chrome && window.chrome.searchBox) { "
-            + "  var f = window.chrome.searchBox;"
-            + "  f.x = %d;"
-            + "  f.y = %d;"
-            + "  f.width = %d;"
-            + "  f.height = %d;"
-            + "}";
-
-    private static final String DISPATCH_EVENT_SCRIPT
-            = "if (window.chrome && window.chrome.searchBox && window.chrome.searchBox.on%1$s) {"
-            + "  window.chrome.searchBox.on%1$s();"
-            + "  window.searchBoxJavaBridge_.dispatchCompleteCallback('%1$s', %2$d, true);"
-            + "} else {"
-            + "  window.searchBoxJavaBridge_.dispatchCompleteCallback('%1$s', %2$d, false);"
-            + "}";
-
-    private static final String EVENT_CHANGE = "change";
-    private static final String EVENT_SUBMIT = "submit";
-    private static final String EVENT_RESIZE = "resize";
-    private static final String EVENT_CANCEL = "cancel";
-
-    private static final String IS_SUPPORTED_SCRIPT
-            = "if (window.searchBoxJavaBridge_) {"
-            + "  if (window.chrome && window.chrome.sv) {"
-            + "    window.searchBoxJavaBridge_.isSupportedCallback(true);"
-            + "  } else {"
-            + "    window.searchBoxJavaBridge_.isSupportedCallback(false);"
-            + "  }}";
-
-    private final List<SearchBoxListener> mListeners;
-    private final WebViewCore mWebViewCore;
-    private final CallbackProxy mCallbackProxy;
-    private IsSupportedCallback mSupportedCallback;
-    private int mNextEventId = 1;
-    private final HashMap<Integer, SearchBoxListener> mEventCallbacks;
-
-    SearchBoxImpl(WebViewCore webViewCore, CallbackProxy callbackProxy) {
-        mListeners = new ArrayList<SearchBoxListener>();
-        mWebViewCore = webViewCore;
-        mCallbackProxy = callbackProxy;
-        mEventCallbacks = new HashMap<Integer, SearchBoxListener>();
-    }
-
-    @Override
-    public void setQuery(String query) {
-        final String formattedQuery = jsonSerialize(query);
-        if (formattedQuery != null) {
-            final String js = String.format(SET_QUERY_SCRIPT, formattedQuery);
-            dispatchJs(js);
-        }
-    }
-
-    @Override
-    public void setVerbatim(boolean verbatim) {
-        final String js = String.format(SET_VERBATIM_SCRIPT, String.valueOf(verbatim));
-        dispatchJs(js);
-    }
-
-
-    @Override
-    public void setSelection(int selectionStart, int selectionEnd) {
-        final String js = String.format(SET_SELECTION_SCRIPT, selectionStart, selectionEnd);
-        dispatchJs(js);
-    }
-
-    @Override
-    public void setDimensions(int x, int y, int width, int height) {
-        final String js = String.format(SET_DIMENSIONS_SCRIPT, x, y, width, height);
-        dispatchJs(js);
-    }
-
-    @Override
-    public void onchange(SearchBoxListener callback) {
-        dispatchEvent(EVENT_CHANGE, callback);
-    }
-
-    @Override
-    public void onsubmit(SearchBoxListener callback) {
-        dispatchEvent(EVENT_SUBMIT, callback);
-    }
-
-    @Override
-    public void onresize(SearchBoxListener callback) {
-        dispatchEvent(EVENT_RESIZE, callback);
-    }
-
-    @Override
-    public void oncancel(SearchBoxListener callback) {
-        dispatchEvent(EVENT_CANCEL, callback);
-    }
-
-    private void dispatchEvent(String eventName, SearchBoxListener callback) {
-        int eventId;
-        if (callback != null) {
-            synchronized(this) {
-                eventId = mNextEventId++;
-                mEventCallbacks.put(eventId, callback);
-            }
-        } else {
-            eventId = 0;
-        }
-        final String js = String.format(DISPATCH_EVENT_SCRIPT, eventName, eventId);
-        dispatchJs(js);
-    }
-
-    private void dispatchJs(String js) {
-        mWebViewCore.sendMessage(EventHub.EXECUTE_JS, js);
-    }
-
-    @Override
-    public void addSearchBoxListener(SearchBoxListener l) {
-        synchronized (mListeners) {
-            mListeners.add(l);
-        }
-    }
-
-    @Override
-    public void removeSearchBoxListener(SearchBoxListener l) {
-        synchronized (mListeners) {
-            mListeners.remove(l);
-        }
-    }
-
-    @Override
-    public void isSupported(IsSupportedCallback callback) {
-        mSupportedCallback = callback;
-        dispatchJs(IS_SUPPORTED_SCRIPT);
-    }
-
-    // Called by Javascript through the Java bridge.
-    public void isSupportedCallback(boolean isSupported) {
-        mCallbackProxy.onIsSupportedCallback(isSupported);
-    }
-
-    public void handleIsSupportedCallback(boolean isSupported) {
-        IsSupportedCallback callback = mSupportedCallback;
-        mSupportedCallback = null;
-        if (callback != null) {
-            callback.searchBoxIsSupported(isSupported);
-        }
-    }
-
-    // Called by Javascript through the Java bridge.
-    public void dispatchCompleteCallback(String function, int id, boolean successful) {
-        mCallbackProxy.onSearchboxDispatchCompleteCallback(function, id, successful);
-    }
-
-    public void handleDispatchCompleteCallback(String function, int id, boolean successful) {
-        if (id != 0) {
-            SearchBoxListener listener;
-            synchronized(this) {
-                listener = mEventCallbacks.get(id);
-                mEventCallbacks.remove(id);
-            }
-            if (listener != null) {
-                if (TextUtils.equals(EVENT_CHANGE, function)) {
-                    listener.onChangeComplete(successful);
-                } else if (TextUtils.equals(EVENT_SUBMIT, function)) {
-                    listener.onSubmitComplete(successful);
-                } else if (TextUtils.equals(EVENT_RESIZE, function)) {
-                    listener.onResizeComplete(successful);
-                } else if (TextUtils.equals(EVENT_CANCEL, function)) {
-                    listener.onCancelComplete(successful);
-                }
-            }
-        }
-    }
-
-    // This is used as a hackish alternative to javascript escaping.
-    // There appears to be no such functionality in the core framework.
-    private static String jsonSerialize(String query) {
-        JSONStringer stringer = new JSONStringer();
-        try {
-            stringer.array().value(query).endArray();
-        } catch (JSONException e) {
-            Log.w(TAG, "Error serializing query : " + query);
-            return null;
-        }
-        return stringer.toString();
-    }
-
-    // Called by Javascript through the Java bridge.
-    public void setSuggestions(String jsonArguments) {
-        if (jsonArguments == null) {
-            return;
-        }
-
-        String query = null;
-        List<String> suggestions = new ArrayList<String>();
-        try {
-            JSONObject suggestionsJson = new JSONObject(jsonArguments);
-            query = suggestionsJson.getString("query");
-
-            final JSONArray suggestionsArray = suggestionsJson.getJSONArray("suggestions");
-            for (int i = 0; i < suggestionsArray.length(); ++i) {
-                final JSONObject suggestion = suggestionsArray.getJSONObject(i);
-                final String value = suggestion.getString("value");
-                if (value != null) {
-                    suggestions.add(value);
-                }
-                // We currently ignore the "type" of the suggestion. This isn't
-                // documented anywhere in the API documents.
-                // final String type = suggestions.getString("type");
-            }
-        } catch (JSONException je) {
-            Log.w(TAG, "Error parsing json [" + jsonArguments + "], exception = " + je);
-            return;
-        }
-
-        mCallbackProxy.onSearchboxSuggestionsReceived(query, suggestions);
-    }
-
-    /* package */ void handleSuggestions(String query, List<String> suggestions) {
-        synchronized (mListeners) {
-            for (int i = mListeners.size() - 1; i >= 0; i--) {
-                mListeners.get(i).onSuggestionsReceived(query, suggestions);
-            }
-        }
-    }
-}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/SearchBox.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SearchBox.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/SearchBox.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SearchBox.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package android.webkit;
-
-import java.util.List;
-
-/**
- * Defines the interaction between the browser/renderer and the page running on
- * a given WebView frame, if the page supports the chromium SearchBox API.
- *
- * http://dev.chromium.org/searchbox
- *
- * The browser or container app can query the page for search results using
- * SearchBox.query() and receive suggestions by registering a listener on the
- * SearchBox object.
- *
- * @hide
- */
-public interface SearchBox {
-    /**
-     * Sets the current searchbox query. Note that the caller must call
-     * onchange() to ensure that the search page processes this query.
-     */
-    void setQuery(String query);
-
-    /**
-     * Verbatim is true if the caller suggests that the search page
-     * treat the current query as a verbatim search query (as opposed to a
-     * partially typed search query). As with setQuery, onchange() must be
-     * called to ensure that the search page processes the query.
-     */
-    void setVerbatim(boolean verbatim);
-
-    /**
-     * These attributes must contain the offset to the characters that immediately
-     * follow the start and end of the selection in the search box. If there is
-     * no such selection, then both selectionStart and selectionEnd must be the offset
-     * to the character that immediately follows the text entry cursor. In the case
-     * that there is no explicit text entry cursor, the cursor is
-     * implicitly at the end of the input.
-     */
-    void setSelection(int selectionStart, int selectionEnd);
-
-    /**
-     * Sets the dimensions of the view (if any) that overlaps the current
-     * window object. This is to ensure that the page renders results in
-     * a manner that allows them to not be obscured by such a view. Note
-     * that a call to onresize() is required if these dimensions change.
-     */
-    void setDimensions(int x, int y, int width, int height);
-
-    /**
-     * Notify the search page of any changes to the searchbox. Such as
-     * a change in the typed query (onchange), the user commiting a given query
-     * (onsubmit), or a change in size of a suggestions dropdown (onresize).
-     *
-     * @param listener an optional listener to notify of the success of the operation,
-     *      indicating if the javascript function existed and could be called or not.
-     *      It will be called on the UI thread.
-     */
-    void onchange(SearchBoxListener listener);
-    void onsubmit(SearchBoxListener listener);
-    void onresize(SearchBoxListener listener);
-    void oncancel(SearchBoxListener listener);
-
-    /**
-     * Add and remove listeners to the given Searchbox. Listeners are notified
-     * of any suggestions to the query that the underlying search engine might
-     * provide.
-     */
-    void addSearchBoxListener(SearchBoxListener l);
-    void removeSearchBoxListener(SearchBoxListener l);
-
-    /**
-     * Indicates if the searchbox API is supported in the current page.
-     */
-    void isSupported(IsSupportedCallback callback);
-
-    /**
-     * Listeners (if any) will be called on the thread that created the
-     * webview.
-     */
-    public abstract class SearchBoxListener {
-        public void onSuggestionsReceived(String query, List<String> suggestions) {}
-        public void onChangeComplete(boolean called) {}
-        public void onSubmitComplete(boolean called) {}
-        public void onResizeComplete(boolean called) {}
-        public void onCancelComplete(boolean called) {}
-    }
-
-    interface IsSupportedCallback {
-        void searchBoxIsSupported(boolean supported);
-    }
-}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/SelectActionModeCallback.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SelectActionModeCallback.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/SelectActionModeCallback.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SelectActionModeCallback.java	2013-03-12 17:03:37.000000000 +0100
@@ -21,9 +21,7 @@ import android.app.SearchManager;
 import android.content.ClipboardManager;
 import android.content.Context;
 import android.content.Intent;
-import android.net.Uri;
 import android.provider.Browser;
-import android.util.Patterns;
 import android.view.ActionMode;
 import android.view.Menu;
 import android.view.MenuItem;
@@ -32,7 +30,6 @@ class SelectActionModeCallback implement
     private WebViewClassic mWebView;
     private ActionMode mActionMode;
     private boolean mIsTextSelected = true;
-    private Menu mMenu;
 
     void setWebView(WebViewClassic webView) {
         mWebView = webView;
@@ -55,7 +52,7 @@ class SelectActionModeCallback implement
     @Override
     public boolean onCreateActionMode(ActionMode mode, Menu menu) {
         mode.getMenuInflater().inflate(com.android.internal.R.menu.webview_copy, menu);
-        mMenu = menu;
+
         final Context context = mWebView.getContext();
         mode.setTitle(context.getString(com.android.internal.R.string.textSelectionCABTitle));
         mode.setTitleOptionalHint(true);
@@ -79,16 +76,10 @@ class SelectActionModeCallback implement
         setMenuVisibility(menu, canCut, com.android.internal.R.id.cut);
         setMenuVisibility(menu, canCopy, com.android.internal.R.id.copy);
         setMenuVisibility(menu, canWebSearch, com.android.internal.R.id.websearch);
-        setOpenUrlVisibility();
         mActionMode = mode;
         return true;
     }
 
-    protected void setOpenUrlVisibility() {
-        boolean isUrl = Patterns.WEB_URL.matcher(mWebView.getSelection()).matches();
-        setMenuVisibility(mMenu, isUrl, com.android.internal.R.id.openurl);
-    }
-
     @Override
     public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
         return true;
@@ -137,13 +128,7 @@ class SelectActionModeCallback implement
                 }
                 mWebView.getContext().startActivity(i);
                 break;
-            case com.android.internal.R.id.openurl:
-                String url = mWebView.getSelection();
-                if (!url.startsWith("https://") && !url.startsWith("http://")){
-                    url = "http://" + url;
-                }
-                Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
-                mWebView.getContext().startActivity(browserIntent);
+
             default:
                 return false;
         }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/SslErrorHandler.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SslErrorHandler.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/SslErrorHandler.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/SslErrorHandler.java	2013-03-12 17:03:37.000000000 +0100
@@ -26,9 +26,9 @@ import android.os.Handler;
 public class SslErrorHandler extends Handler {
 
     /**
-     * Package-private constructor needed for API compatibility.
+     * @hide Only for use by WebViewProvider implementations.
      */
-    SslErrorHandler() {}
+    public SslErrorHandler() {}
 
     /**
      * Proceed with the SSL certificate.
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/ViewStateSerializer.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/ViewStateSerializer.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/ViewStateSerializer.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/ViewStateSerializer.java	2013-03-12 17:03:37.000000000 +0100
@@ -16,7 +16,6 @@
 package android.webkit;
 
 import android.graphics.Point;
-import android.graphics.Region;
 import android.webkit.WebViewCore.DrawData;
 
 import java.io.DataInputStream;
@@ -68,6 +67,15 @@ class ViewStateSerializer {
         return draw;
     }
 
+    public static void dumpLayerHierarchy(int baseLayer, OutputStream out, int level) {
+        nativeDumpLayerHierarchy(baseLayer, level, out,
+                new byte[WORKING_STREAM_STORAGE]);
+    }
+
+
+    private static native void nativeDumpLayerHierarchy(int baseLayer, int level,
+            OutputStream out, byte[] storage);
+
     private static native boolean nativeSerializeViewState(int baseLayer,
             OutputStream stream, byte[] storage);
 
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebBackForwardListClassic.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebBackForwardListClassic.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebBackForwardListClassic.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebBackForwardListClassic.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+
+/* package */ class WebBackForwardListClassic extends WebBackForwardList implements Cloneable,
+        Serializable {
+
+    // Current position in the list.
+    private int mCurrentIndex;
+    // ArrayList of WebHistoryItems for maintaining our copy.
+    private ArrayList<WebHistoryItemClassic> mArray;
+    // Flag to indicate that the list is invalid
+    private boolean mClearPending;
+    // CallbackProxy to issue client callbacks.
+    private final CallbackProxy mCallbackProxy;
+
+    /*package*/ WebBackForwardListClassic(CallbackProxy proxy) {
+        mCurrentIndex = -1;
+        mArray = new ArrayList<WebHistoryItemClassic>();
+        mCallbackProxy = proxy;
+    }
+
+    public synchronized WebHistoryItemClassic getCurrentItem() {
+        return getItemAtIndex(mCurrentIndex);
+    }
+
+    public synchronized int getCurrentIndex() {
+        return mCurrentIndex;
+    }
+
+    public synchronized WebHistoryItemClassic getItemAtIndex(int index) {
+        if (index < 0 || index >= getSize()) {
+            return null;
+        }
+        return mArray.get(index);
+    }
+
+    public synchronized int getSize() {
+        return mArray.size();
+    }
+
+    /**
+     * Mark the back/forward list as having a pending clear. This is used on the
+     * UI side to mark the list as being invalid during the clearHistory method.
+     */
+    /*package*/ synchronized void setClearPending() {
+        mClearPending = true;
+    }
+
+    /**
+     * Return the status of the clear flag. This is used on the UI side to
+     * determine if the list is valid for checking things like canGoBack.
+     */
+    /*package*/ synchronized boolean getClearPending() {
+        return mClearPending;
+    }
+
+    /**
+     * Add a new history item to the list. This will remove all items after the
+     * current item and append the new item to the end of the list. Called from
+     * the WebCore thread only. Synchronized because the UI thread may be
+     * reading the array or the current index.
+     * @param item A new history item.
+     */
+    /*package*/ synchronized void addHistoryItem(WebHistoryItem item) {
+        // Update the current position because we are going to add the new item
+        // in that slot.
+        ++mCurrentIndex;
+        // If the current position is not at the end, remove all history items
+        // after the current item.
+        final int size = mArray.size();
+        final int newPos = mCurrentIndex;
+        if (newPos != size) {
+            for (int i = size - 1; i >= newPos; i--) {
+                final WebHistoryItem h = mArray.remove(i);
+            }
+        }
+        // Add the item to the list.
+        mArray.add((WebHistoryItemClassic) item);
+        if (mCallbackProxy != null) {
+            mCallbackProxy.onNewHistoryItem(item);
+        }
+    }
+
+    /**
+     * Clear the back/forward list. Called from the WebCore thread.
+     */
+    /*package*/ synchronized void close(int nativeFrame) {
+        // Clear the array first because nativeClose will call addHistoryItem
+        // with the current item.
+        mArray.clear();
+        mCurrentIndex = -1;
+        nativeClose(nativeFrame);
+        // Reset the clear flag
+        mClearPending = false;
+    }
+
+    /* Remove the item at the given index. Called by JNI only. */
+    private synchronized void removeHistoryItem(int index) {
+        // XXX: This is a special case. Since the callback is only triggered
+        // when removing the first item, we can assert that the index is 0.
+        // This lets us change the current index without having to query the
+        // native BackForwardList.
+        if (DebugFlags.WEB_BACK_FORWARD_LIST && (index != 0)) {
+            throw new AssertionError();
+        }
+        final WebHistoryItem h = mArray.remove(index);
+        // XXX: If we ever add another callback for removing history items at
+        // any index, this will no longer be valid.
+        mCurrentIndex--;
+    }
+
+    public synchronized WebBackForwardListClassic clone() {
+        WebBackForwardListClassic l = new WebBackForwardListClassic(null);
+        if (mClearPending) {
+            // If a clear is pending, return a copy with only the current item.
+            l.addHistoryItem(getCurrentItem());
+            return l;
+        }
+        l.mCurrentIndex = mCurrentIndex;
+        int size = getSize();
+        l.mArray = new ArrayList<WebHistoryItemClassic>(size);
+        for (int i = 0; i < size; i++) {
+            // Add a copy of each WebHistoryItem
+            l.mArray.add(mArray.get(i).clone());
+        }
+        return l;
+    }
+
+    /**
+     * Set the new history index.
+     * @param newIndex The new history index.
+     */
+    /*package*/ synchronized void setCurrentIndex(int newIndex) {
+        mCurrentIndex = newIndex;
+        if (mCallbackProxy != null) {
+            mCallbackProxy.onIndexChanged(getItemAtIndex(newIndex), newIndex);
+        }
+    }
+
+    /**
+     * Restore the history index.
+     */
+    /*package*/ static native synchronized void restoreIndex(int nativeFrame,
+            int index);
+
+    /* Close the native list. */
+    private static native void nativeClose(int nativeFrame);
+}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebBackForwardList.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebBackForwardList.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebBackForwardList.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebBackForwardList.java	2013-03-12 17:03:37.000000000 +0100
@@ -17,7 +17,6 @@
 package android.webkit;
 
 import java.io.Serializable;
-import java.util.ArrayList;
 
 /**
  * This class contains the back/forward list for a WebView.
@@ -25,22 +24,11 @@ import java.util.ArrayList;
  * inspect the entries in the list.
  */
 public class WebBackForwardList implements Cloneable, Serializable {
-    // Current position in the list.
-    private int mCurrentIndex;
-    // ArrayList of WebHistoryItems for maintaining our copy.
-    private ArrayList<WebHistoryItem> mArray;
-    // Flag to indicate that the list is invalid
-    private boolean mClearPending;
-    // CallbackProxy to issue client callbacks.
-    private final CallbackProxy mCallbackProxy;
-
-    /**
-     * Construct a back/forward list used by clients of WebView.
-     */
-    /*package*/ WebBackForwardList(CallbackProxy proxy) {
-        mCurrentIndex = -1;
-        mArray = new ArrayList<WebHistoryItem>();
-        mCallbackProxy = proxy;
+
+    /**
+     *  @hide
+     */
+    public WebBackForwardList() {
     }
 
     /**
@@ -49,7 +37,7 @@ public class WebBackForwardList implemen
      * @return The current history item.
      */
     public synchronized WebHistoryItem getCurrentItem() {
-        return getItemAtIndex(mCurrentIndex);
+        throw new MustOverrideException();
     }
 
     /**
@@ -58,7 +46,7 @@ public class WebBackForwardList implemen
      * @return The current index from 0...n or -1 if the list is empty.
      */
     public synchronized int getCurrentIndex() {
-        return mCurrentIndex;
+        throw new MustOverrideException();
     }
 
     /**
@@ -67,10 +55,7 @@ public class WebBackForwardList implemen
      * @param index The index to retrieve.
      */
     public synchronized WebHistoryItem getItemAtIndex(int index) {
-        if (index < 0 || index >= getSize()) {
-            return null;
-        }
-        return mArray.get(index);
+        throw new MustOverrideException();
     }
 
     /**
@@ -78,78 +63,7 @@ public class WebBackForwardList implemen
      * @return The size of the list.
      */
     public synchronized int getSize() {
-        return mArray.size();
-    }
-
-    /**
-     * Mark the back/forward list as having a pending clear. This is used on the
-     * UI side to mark the list as being invalid during the clearHistory method.
-     */
-    /*package*/ synchronized void setClearPending() {
-        mClearPending = true;
-    }
-
-    /**
-     * Return the status of the clear flag. This is used on the UI side to
-     * determine if the list is valid for checking things like canGoBack.
-     */
-    /*package*/ synchronized boolean getClearPending() {
-        return mClearPending;
-    }
-
-    /**
-     * Add a new history item to the list. This will remove all items after the
-     * current item and append the new item to the end of the list. Called from
-     * the WebCore thread only. Synchronized because the UI thread may be
-     * reading the array or the current index.
-     * @param item A new history item.
-     */
-    /*package*/ synchronized void addHistoryItem(WebHistoryItem item) {
-        // Update the current position because we are going to add the new item
-        // in that slot.
-        ++mCurrentIndex;
-        // If the current position is not at the end, remove all history items
-        // after the current item.
-        final int size = mArray.size();
-        final int newPos = mCurrentIndex;
-        if (newPos != size) {
-            for (int i = size - 1; i >= newPos; i--) {
-                final WebHistoryItem h = mArray.remove(i);
-            }
-        }
-        // Add the item to the list.
-        mArray.add(item);
-        if (mCallbackProxy != null) {
-            mCallbackProxy.onNewHistoryItem(item);
-        }
-    }
-
-    /**
-     * Clear the back/forward list. Called from the WebCore thread.
-     */
-    /*package*/ synchronized void close(int nativeFrame) {
-        // Clear the array first because nativeClose will call addHistoryItem
-        // with the current item.
-        mArray.clear();
-        mCurrentIndex = -1;
-        nativeClose(nativeFrame);
-        // Reset the clear flag
-        mClearPending = false;
-    }
-
-    /* Remove the item at the given index. Called by JNI only. */
-    private synchronized void removeHistoryItem(int index) {
-        // XXX: This is a special case. Since the callback is only triggered
-        // when removing the first item, we can assert that the index is 0.
-        // This lets us change the current index without having to query the
-        // native BackForwardList.
-        if (DebugFlags.WEB_BACK_FORWARD_LIST && (index != 0)) {
-            throw new AssertionError();
-        }
-        final WebHistoryItem h = mArray.remove(index);
-        // XXX: If we ever add another callback for removing history items at
-        // any index, this will no longer be valid.
-        mCurrentIndex--;
+        throw new MustOverrideException();
     }
 
     /**
@@ -158,39 +72,7 @@ public class WebBackForwardList implemen
      * webkit package classes.
      */
     protected synchronized WebBackForwardList clone() {
-        WebBackForwardList l = new WebBackForwardList(null);
-        if (mClearPending) {
-            // If a clear is pending, return a copy with only the current item.
-            l.addHistoryItem(getCurrentItem());
-            return l;
-        }
-        l.mCurrentIndex = mCurrentIndex;
-        int size = getSize();
-        l.mArray = new ArrayList<WebHistoryItem>(size);
-        for (int i = 0; i < size; i++) {
-            // Add a copy of each WebHistoryItem
-            l.mArray.add(mArray.get(i).clone());
-        }
-        return l;
+        throw new MustOverrideException();
     }
 
-    /**
-     * Set the new history index.
-     * @param newIndex The new history index.
-     */
-    /*package*/ synchronized void setCurrentIndex(int newIndex) {
-        mCurrentIndex = newIndex;
-        if (mCallbackProxy != null) {
-            mCallbackProxy.onIndexChanged(getItemAtIndex(newIndex), newIndex);
-        }
-    }
-
-    /**
-     * Restore the history index.
-     */
-    /*package*/ static native synchronized void restoreIndex(int nativeFrame,
-            int index);
-
-    /* Close the native list. */
-    private static native void nativeClose(int nativeFrame);
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebChromeClient.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebChromeClient.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebChromeClient.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebChromeClient.java	2013-03-12 17:03:37.000000000 +0100
@@ -245,8 +245,8 @@ public class WebChromeClient {
     }
 
    /**
-    * Tell the client that the quota has been reached for the Application Cache
-    * API and request a new quota. The client must respond by invoking the
+    * Notify the host application that the Application Cache has reached the
+    * maximum size. The client must respond by invoking the
     * {@link WebStorage.QuotaUpdater#updateQuota(long) updateQuota(long)}
     * method of the supplied {@link WebStorage.QuotaUpdater} instance. The
     * minimum value that can be set for the new quota is the current quota. The
@@ -255,7 +255,7 @@ public class WebChromeClient {
     * @param requiredStorage The amount of storage required by the Application
     *                        Cache operation that triggered this notification,
     *                        in bytes.
-    * @param quota The quota, in bytes
+    * @param quota the current maximum Application Cache size, in bytes
     * @param quotaUpdater An instance of {@link WebStorage.QuotaUpdater} which
     *                     must be used to inform the WebView of the new quota.
     */
@@ -297,7 +297,12 @@ public class WebChromeClient {
      * will continue to occur if the script does not finish at the next check
      * point.
      * @return boolean Whether the JavaScript execution should be interrupted.
+     * @deprecated This method is no longer supported and will not be invoked.
      */
+    // This method was only called when using the JSC javascript engine. V8 became
+    // the default JS engine with Froyo and support for building with JSC was
+    // removed in b/5495373. V8 does not have a mechanism for making a callback such
+    // as this.
     public boolean onJsTimeout() {
         return true;
     }
@@ -372,13 +377,6 @@ public class WebChromeClient {
     }
 
     /**
-     * Tell the client that the page being viewed is web app capable,
-     * i.e. has specified the fullscreen-web-app-capable meta tag.
-     * @hide
-     */
-    public void setInstallableWebApp() { }
-
-    /**
      * Tell the client that the page being viewed has an autofillable
      * form and the user would like to set a profile up.
      * @param msg A Message to send once the user has successfully
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebHistoryItemClassic.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebHistoryItemClassic.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebHistoryItemClassic.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebHistoryItemClassic.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import android.graphics.Bitmap;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/* package */ class WebHistoryItemClassic extends WebHistoryItem implements Cloneable {
+    // Global identifier count.
+    private static int sNextId = 0;
+    // Unique identifier.
+    private final int mId;
+    // A point to a native WebHistoryItem instance which contains the actual data
+    private int mNativeBridge;
+    // The favicon for this item.
+    private Bitmap mFavicon;
+    // The pre-flattened data used for saving the state.
+    private byte[] mFlattenedData;
+    // The apple-touch-icon url for use when adding the site to the home screen,
+    // as obtained from a <link> element in the page.
+    private String mTouchIconUrlFromLink;
+    // If no <link> is specified, this holds the default location of the
+    // apple-touch-icon.
+    private String mTouchIconUrlServerDefault;
+    // Custom client data that is not flattened or read by native code.
+    private Object mCustomData;
+
+    /**
+     * Basic constructor that assigns a unique id to the item. Called by JNI
+     * only.
+     */
+    private WebHistoryItemClassic(int nativeBridge) {
+        synchronized (WebHistoryItemClassic.class) {
+            mId = sNextId++;
+        }
+        mNativeBridge = nativeBridge;
+        nativeRef(mNativeBridge);
+    }
+
+    protected void finalize() throws Throwable {
+        if (mNativeBridge != 0) {
+            nativeUnref(mNativeBridge);
+            mNativeBridge = 0;
+        }
+    }
+
+    /**
+     * Construct a new WebHistoryItem with initial flattened data.
+     * @param data The pre-flattened data coming from restoreState.
+     */
+    /*package*/ WebHistoryItemClassic(byte[] data) {
+        mFlattenedData = data;
+        synchronized (WebHistoryItemClassic.class) {
+            mId = sNextId++;
+        }
+    }
+
+    /**
+     * Construct a clone of a WebHistoryItem from the given item.
+     * @param item The history item to clone.
+     */
+    private WebHistoryItemClassic(WebHistoryItemClassic item) {
+        mFlattenedData = item.mFlattenedData;
+        mId = item.mId;
+        mFavicon = item.mFavicon;
+        mNativeBridge = item.mNativeBridge;
+        if (mNativeBridge != 0) {
+            nativeRef(mNativeBridge);
+        }
+    }
+
+    @Deprecated
+    public int getId() {
+        return mId;
+    }
+
+    public String getUrl() {
+        if (mNativeBridge == 0) return null;
+        return nativeGetUrl(mNativeBridge);
+    }
+
+    public String getOriginalUrl() {
+        if (mNativeBridge == 0) return null;
+        return nativeGetOriginalUrl(mNativeBridge);
+    }
+
+    public String getTitle() {
+        if (mNativeBridge == 0) return null;
+        return nativeGetTitle(mNativeBridge);
+    }
+
+    public Bitmap getFavicon() {
+        if (mFavicon == null && mNativeBridge != 0) {
+            mFavicon = nativeGetFavicon(mNativeBridge);
+        }
+        return mFavicon;
+    }
+
+    /**
+     * Return the touch icon url.
+     * If no touch icon <link> tag was specified, returns
+     * <host>/apple-touch-icon.png. The DownloadTouchIcon class that
+     * attempts to retrieve the touch icon will handle the case where
+     * that file does not exist. An icon set by a <link> tag is always
+     * used in preference to an icon saved on the server.
+     * @hide
+     */
+    public String getTouchIconUrl() {
+        if (mTouchIconUrlFromLink != null) {
+            return mTouchIconUrlFromLink;
+        } else if (mTouchIconUrlServerDefault != null) {
+            return mTouchIconUrlServerDefault;
+        }
+
+        try {
+            URL url = new URL(getOriginalUrl());
+            mTouchIconUrlServerDefault = new URL(url.getProtocol(), url.getHost(), url.getPort(),
+                    "/apple-touch-icon.png").toString();
+        } catch (MalformedURLException e) {
+            return null;
+        }
+        return mTouchIconUrlServerDefault;
+    }
+
+    /**
+     * Return the custom data provided by the client.
+     * @hide
+     */
+    public Object getCustomData() {
+        return mCustomData;
+    }
+
+    /**
+     * Set the custom data field.
+     * @param data An Object containing any data the client wishes to associate
+     *             with the item.
+     * @hide
+     */
+    public void setCustomData(Object data) {
+        // NOTE: WebHistoryItems are used in multiple threads. However, the
+        // public facing apis are all getters with the exception of this one
+        // api. Since this api is exclusive to clients, we don't make any
+        // promises about thread safety.
+        mCustomData = data;
+    }
+
+    /**
+     * Set the favicon.
+     * @param icon A Bitmap containing the favicon for this history item.
+     * Note: The VM ensures 32-bit atomic read/write operations so we don't have
+     * to synchronize this method.
+     */
+    /*package*/ void setFavicon(Bitmap icon) {
+        mFavicon = icon;
+    }
+
+    /**
+     * Set the touch icon url. Will not overwrite an icon that has been
+     * set already from a <link> tag, unless the new icon is precomposed.
+     * @hide
+     */
+    /*package*/ void setTouchIconUrl(String url, boolean precomposed) {
+        if (precomposed || mTouchIconUrlFromLink == null) {
+            mTouchIconUrlFromLink = url;
+        }
+    }
+
+    /**
+     * Get the pre-flattened data.
+     * Note: The VM ensures 32-bit atomic read/write operations so we don't have
+     * to synchronize this method.
+     */
+    /*package*/ byte[] getFlattenedData() {
+        if (mNativeBridge != 0) {
+            return nativeGetFlattenedData(mNativeBridge);
+        }
+        return mFlattenedData;
+    }
+
+    /**
+     * Inflate this item.
+     * Note: The VM ensures 32-bit atomic read/write operations so we don't have
+     * to synchronize this method.
+     */
+    /*package*/ void inflate(int nativeFrame) {
+        mNativeBridge = inflate(nativeFrame, mFlattenedData);
+        mFlattenedData = null;
+    }
+
+    public synchronized WebHistoryItemClassic clone() {
+        return new WebHistoryItemClassic(this);
+    }
+
+    /* Natively inflate this item, this method is called in the WebCore thread.
+     */
+    private native int inflate(int nativeFrame, byte[] data);
+    private native void nativeRef(int nptr);
+    private native void nativeUnref(int nptr);
+    private native String nativeGetTitle(int nptr);
+    private native String nativeGetUrl(int nptr);
+    private native String nativeGetOriginalUrl(int nptr);
+    private native byte[] nativeGetFlattenedData(int nptr);
+    private native Bitmap nativeGetFavicon(int nptr);
+
+}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebHistoryItem.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebHistoryItem.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebHistoryItem.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebHistoryItem.java	2013-03-12 17:03:37.000000000 +0100
@@ -18,9 +18,6 @@ package android.webkit;
 
 import android.graphics.Bitmap;
 
-import java.net.MalformedURLException;
-import java.net.URL;
-
 /**
  * A convenience class for accessing fields in an entry in the back/forward list
  * of a WebView. Each WebHistoryItem is a snapshot of the requested history
@@ -28,67 +25,11 @@ import java.net.URL;
  * @see WebBackForwardList
  */
 public class WebHistoryItem implements Cloneable {
-    // Global identifier count.
-    private static int sNextId = 0;
-    // Unique identifier.
-    private final int mId;
-    // A point to a native WebHistoryItem instance which contains the actual data
-    private int mNativeBridge;
-    // The favicon for this item.
-    private Bitmap mFavicon;
-    // The pre-flattened data used for saving the state.
-    private byte[] mFlattenedData;
-    // The apple-touch-icon url for use when adding the site to the home screen,
-    // as obtained from a <link> element in the page.
-    private String mTouchIconUrlFromLink;
-    // If no <link> is specified, this holds the default location of the
-    // apple-touch-icon.
-    private String mTouchIconUrlServerDefault;
-    // Custom client data that is not flattened or read by native code.
-    private Object mCustomData;
-
-    /**
-     * Basic constructor that assigns a unique id to the item. Called by JNI
-     * only.
-     */
-    private WebHistoryItem(int nativeBridge) {
-        synchronized (WebHistoryItem.class) {
-            mId = sNextId++;
-        }
-        mNativeBridge = nativeBridge;
-        nativeRef(mNativeBridge);
-    }
-
-    protected void finalize() throws Throwable {
-        if (mNativeBridge != 0) {
-            nativeUnref(mNativeBridge);
-            mNativeBridge = 0;
-        }
-    }
-
-    /**
-     * Construct a new WebHistoryItem with initial flattened data.
-     * @param data The pre-flattened data coming from restoreState.
-     */
-    /*package*/ WebHistoryItem(byte[] data) {
-        mFlattenedData = data;
-        synchronized (WebHistoryItem.class) {
-            mId = sNextId++;
-        }
-    }
 
     /**
-     * Construct a clone of a WebHistoryItem from the given item.
-     * @param item The history item to clone.
-     */
-    private WebHistoryItem(WebHistoryItem item) {
-        mFlattenedData = item.mFlattenedData;
-        mId = item.mId;
-        mFavicon = item.mFavicon;
-        mNativeBridge = item.mNativeBridge;
-        if (mNativeBridge != 0) {
-            nativeRef(mNativeBridge);
-        }
+     * @hide
+     */
+    public WebHistoryItem() {
     }
 
     /**
@@ -97,10 +38,11 @@ public class WebHistoryItem implements C
      * same object.
      * @return The id for this item.
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public int getId() {
-        return mId;
+        throw new MustOverrideException();
     }
 
     /**
@@ -112,8 +54,7 @@ public class WebHistoryItem implements C
      * to synchronize this method.
      */
     public String getUrl() {
-        if (mNativeBridge == 0) return null;
-        return nativeGetUrl(mNativeBridge);
+        throw new MustOverrideException();
     }
 
     /**
@@ -123,8 +64,7 @@ public class WebHistoryItem implements C
      * @return The original url of this history item.
      */
     public String getOriginalUrl() {
-        if (mNativeBridge == 0) return null;
-        return nativeGetOriginalUrl(mNativeBridge);
+        throw new MustOverrideException();
     }
     
     /**
@@ -134,8 +74,7 @@ public class WebHistoryItem implements C
      * to synchronize this method.
      */
     public String getTitle() {
-        if (mNativeBridge == 0) return null;
-        return nativeGetTitle(mNativeBridge);
+        throw new MustOverrideException();
     }
 
     /**
@@ -145,119 +84,14 @@ public class WebHistoryItem implements C
      * to synchronize this method.
      */
     public Bitmap getFavicon() {
-        if (mFavicon == null && mNativeBridge != 0) {
-            mFavicon = nativeGetFavicon(mNativeBridge);
-        }
-        return mFavicon;
-    }
-
-    /**
-     * Return the touch icon url.
-     * If no touch icon <link> tag was specified, returns
-     * <host>/apple-touch-icon.png. The DownloadTouchIcon class that
-     * attempts to retrieve the touch icon will handle the case where
-     * that file does not exist. An icon set by a <link> tag is always
-     * used in preference to an icon saved on the server.
-     * @hide
-     */
-    public String getTouchIconUrl() {
-        if (mTouchIconUrlFromLink != null) {
-            return mTouchIconUrlFromLink;
-        } else if (mTouchIconUrlServerDefault != null) {
-            return mTouchIconUrlServerDefault;
-        }
-
-        try {
-            URL url = new URL(getOriginalUrl());
-            mTouchIconUrlServerDefault = new URL(url.getProtocol(), url.getHost(), url.getPort(),
-                    "/apple-touch-icon.png").toString();
-        } catch (MalformedURLException e) {
-            return null;
-        }
-        return mTouchIconUrlServerDefault;
-    }
-
-    /**
-     * Return the custom data provided by the client.
-     * @hide
-     */
-    public Object getCustomData() {
-        return mCustomData;
-    }
-
-    /**
-     * Set the custom data field.
-     * @param data An Object containing any data the client wishes to associate
-     *             with the item.
-     * @hide
-     */
-    public void setCustomData(Object data) {
-        // NOTE: WebHistoryItems are used in multiple threads. However, the
-        // public facing apis are all getters with the exception of this one
-        // api. Since this api is exclusive to clients, we don't make any
-        // promises about thread safety.
-        mCustomData = data;
-    }
-
-    /**
-     * Set the favicon.
-     * @param icon A Bitmap containing the favicon for this history item.
-     * Note: The VM ensures 32-bit atomic read/write operations so we don't have
-     * to synchronize this method.
-     */
-    /*package*/ void setFavicon(Bitmap icon) {
-        mFavicon = icon;
-    }
-
-    /**
-     * Set the touch icon url. Will not overwrite an icon that has been
-     * set already from a <link> tag, unless the new icon is precomposed.
-     * @hide
-     */
-    /*package*/ void setTouchIconUrl(String url, boolean precomposed) {
-        if (precomposed || mTouchIconUrlFromLink == null) {
-            mTouchIconUrlFromLink = url;
-        }
-    }
-
-    /**
-     * Get the pre-flattened data.
-     * Note: The VM ensures 32-bit atomic read/write operations so we don't have
-     * to synchronize this method.
-     */
-    /*package*/ byte[] getFlattenedData() {
-        if (mNativeBridge != 0) {
-            return nativeGetFlattenedData(mNativeBridge);
-        }
-        return mFlattenedData;
-    }
-
-    /**
-     * Inflate this item.
-     * Note: The VM ensures 32-bit atomic read/write operations so we don't have
-     * to synchronize this method.
-     */
-    /*package*/ void inflate(int nativeFrame) {
-        mNativeBridge = inflate(nativeFrame, mFlattenedData);
-        mFlattenedData = null;
+        throw new MustOverrideException();
     }
 
     /**
      * Clone the history item for use by clients of WebView.
      */
     protected synchronized WebHistoryItem clone() {
-        return new WebHistoryItem(this);
+        throw new MustOverrideException();
     }
 
-    /* Natively inflate this item, this method is called in the WebCore thread.
-     */
-    private native int inflate(int nativeFrame, byte[] data);
-    private native void nativeRef(int nptr);
-    private native void nativeUnref(int nptr);
-    private native String nativeGetTitle(int nptr);
-    private native String nativeGetUrl(int nptr);
-    private native String nativeGetOriginalUrl(int nptr);
-    private native byte[] nativeGetFlattenedData(int nptr);
-    private native Bitmap nativeGetFavicon(int nptr);
-
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebSettingsClassic.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebSettingsClassic.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebSettingsClassic.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebSettingsClassic.java	2013-03-12 17:03:37.000000000 +0100
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
- * Copyright (c) 2011, 2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,7 +35,7 @@ import java.util.Locale;
  */
 public class WebSettingsClassic extends WebSettings {
     // TODO: Keep this up to date
-    private static final String PREVIOUS_VERSION = "4.0.4";
+    private static final String PREVIOUS_VERSION = "4.1.1";
 
     // WebView associated with this WebSettings.
     private WebViewClassic mWebView;
@@ -88,7 +87,6 @@ public class WebSettingsClassic extends
     private long            mMaximumDecodedImageSize = 0; // 0 means default
     private boolean         mPrivateBrowsingEnabled = false;
     private boolean         mSyntheticLinksEnabled = true;
-    private boolean         mMediaPreloadEnabled = true;
     // HTML5 API flags
     private boolean         mAppCacheEnabled = false;
     private boolean         mDatabaseEnabled = false;
@@ -119,6 +117,7 @@ public class WebSettingsClassic extends
     private boolean         mNeedInitialFocus = true;
     private boolean         mNavDump = false;
     private boolean         mSupportZoom = true;
+    private boolean         mMediaPlaybackRequiresUserGesture = true;
     private boolean         mBuiltInZoomControls = false;
     private boolean         mDisplayZoomControls = true;
     private boolean         mAllowFileAccess = true;
@@ -377,6 +376,21 @@ public class WebSettingsClassic extends
         synchronized(sLockForLocaleSettings) {
             locale = sLocale;
         }
+        return getDefaultUserAgentForLocale(mContext, locale);
+    }
+
+    /**
+     * Returns the default User-Agent used by a WebView.
+     * An instance of WebView could use a different User-Agent if a call
+     * is made to {@link WebSettings#setUserAgent(int)} or
+     * {@link WebSettings#setUserAgentString(String)}.
+     *
+     * @param context a Context object used to access application assets
+     * @param locale The Locale to use in the User-Agent string.
+     * @see WebViewFactoryProvider#getDefaultUserAgent(Context)
+     * @see WebView#getDefaultUserAgent(Context)
+     */
+    public static String getDefaultUserAgentForLocale(Context context, Locale locale) {
         StringBuffer buffer = new StringBuffer();
         // Add version
         final String version = Build.VERSION.RELEASE;
@@ -422,10 +436,10 @@ public class WebSettingsClassic extends
         }
         final String cmversion = SystemProperties.get("ro.cm.version");
         if (cmversion != null && cmversion.length() > 0)
-            buffer.append("; CyanogenMod-" + cmversion.replaceAll("(.+?)-.*","$1"));
-        String mobile = mContext.getResources().getText(
+            buffer.append("; CyanogenMod-" + cmversion.replaceAll("([0-9\\.]+?)-.*","$1"));
+        String mobile = context.getResources().getText(
             com.android.internal.R.string.web_user_agent_target_content).toString();
-        final String base = mContext.getResources().getText(
+        final String base = context.getResources().getText(
                 com.android.internal.R.string.web_user_agent).toString();
         return String.format(base, buffer, mobile);
     }
@@ -466,6 +480,25 @@ public class WebSettingsClassic extends
     }
 
     /**
+     * @see android.webkit.WebSettings#setMediaPlaybackRequiresUserGesture(boolean)
+     */
+    @Override
+    public void setMediaPlaybackRequiresUserGesture(boolean support) {
+        if (mMediaPlaybackRequiresUserGesture != support) {
+            mMediaPlaybackRequiresUserGesture = support;
+            postSync();
+        }
+    }
+
+    /**
+     * @see android.webkit.WebSettings#getMediaPlaybackRequiresUserGesture()
+     */
+    @Override
+    public boolean getMediaPlaybackRequiresUserGesture() {
+        return mMediaPlaybackRequiresUserGesture;
+    }
+
+    /**
      * @see android.webkit.WebSettings#setBuiltInZoomControls(boolean)
      */
     @Override
@@ -637,34 +670,6 @@ public class WebSettingsClassic extends
     }
 
     /**
-     * @see android.webkit.WebSettings#setTextSize(android.webkit.WebSettingsClassic.TextSize)
-     */
-    @Override
-    public synchronized void setTextSize(TextSize t) {
-        setTextZoom(t.value);
-    }
-
-    /**
-     * @see android.webkit.WebSettings#getTextSize()
-     */
-    @Override
-    public synchronized TextSize getTextSize() {
-        TextSize closestSize = null;
-        int smallestDelta = Integer.MAX_VALUE;
-        for (TextSize size : TextSize.values()) {
-            int delta = Math.abs(mTextSize - size.value);
-            if (delta == 0) {
-                return size;
-            }
-            if (delta < smallestDelta) {
-                smallestDelta = delta;
-                closestSize = size;
-            }
-        }
-        return closestSize != null ? closestSize : TextSize.NORMAL;
-    }
-
-    /**
      * Set the double-tap zoom of the page in percent. Default is 100.
      * @param doubleTapZoom A percent value for increasing or decreasing the double-tap zoom.
      */
@@ -1122,6 +1127,7 @@ public class WebSettingsClassic extends
         if (mJavaScriptEnabled != flag) {
             mJavaScriptEnabled = flag;
             postSync();
+            mWebView.updateJavaScriptEnabled(flag);
         }
     }
 
@@ -1638,6 +1644,7 @@ public class WebSettingsClassic extends
     /**
      * Sets whether WebGL is enabled.
      * @param flag Set to true to enable WebGL.
+     * @hide
      */
     public synchronized void setWebGLEnabled(boolean flag) {
         if (mWebGLEnabled != flag) {
@@ -1660,13 +1667,6 @@ public class WebSettingsClassic extends
             postSync();
         }
     }
-
-    public synchronized void setMediaPreloadEnabled(boolean flag) {
-        if (mMediaPreloadEnabled != flag) {
-            mMediaPreloadEnabled = flag;
-            postSync();
-        }
-    }
 
     public synchronized void setAutoFillEnabled(boolean enabled) {
         // AutoFill is always disabled in private browsing mode.
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebSettings.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebSettings.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebSettings.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebSettings.java	2013-03-12 17:03:37.000000000 +0100
@@ -16,8 +16,7 @@
 
 package android.webkit;
 
-import android.os.Message;
-import android.os.Build;
+import android.content.Context;
 
 /**
  * Manages settings state for a WebView. When a WebView is first created, it
@@ -94,30 +93,38 @@ public abstract class WebSettings {
     }
 
     /**
-     * Default cache usage pattern. Use with {@link #setCacheMode}.
+     * Default cache usage mode. If the navigation type doesn't impose any
+     * specific behavior, use cached resources when they are available
+     * and not expired, otherwise load resources from the network.
+     * Use with {@link #setCacheMode}.
      */
     public static final int LOAD_DEFAULT = -1;
 
     /**
-     * Normal cache usage pattern. Use with {@link #setCacheMode}.
+     * Normal cache usage mode. Use with {@link #setCacheMode}.
+     *
+     * @deprecated This value is obsolete, as from API level
+     * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and onwards it has the
+     * same effect as {@link #LOAD_DEFAULT}.
      */
+    @Deprecated
     public static final int LOAD_NORMAL = 0;
 
     /**
-     * Use cache if content is there, even if expired (eg, history nav).
-     * If it is not in the cache, load from network.
+     * Use cached resources when they are available, even if they have expired.
+     * Otherwise load resources from the network.
      * Use with {@link #setCacheMode}.
      */
     public static final int LOAD_CACHE_ELSE_NETWORK = 1;
 
     /**
-     * Don't use the cache, load from network.
+     * Don't use the cache, load from the network.
      * Use with {@link #setCacheMode}.
      */
     public static final int LOAD_NO_CACHE = 2;
 
     /**
-     * Don't use the network, load from cache only.
+     * Don't use the network, load from the cache.
      * Use with {@link #setCacheMode}.
      */
     public static final int LOAD_CACHE_ONLY = 3;
@@ -153,9 +160,11 @@ public abstract class WebSettings {
     }
 
     /**
-     * Enables dumping the pages navigation cache to a text file.
+     * Enables dumping the pages navigation cache to a text file. The default
+     * is false.
      *
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public void setNavDump(boolean enabled) {
@@ -165,7 +174,10 @@ public abstract class WebSettings {
     /**
      * Gets whether dumping the navigation cache is enabled.
      *
+     * @return whether dumping the navigation cache is enabled
+     * @see #setNavDump
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public boolean getNavDump() {
@@ -196,6 +208,26 @@ public abstract class WebSettings {
     }
 
     /**
+     * Sets whether the WebView requires a user gesture to play media.
+     * The default is true.
+     *
+     * @param require whether the WebView requires a user gesture to play media
+     */
+    public void setMediaPlaybackRequiresUserGesture(boolean require) {
+        throw new MustOverrideException();
+    }
+
+    /**
+     * Gets whether the WebView requires a user gesture to play media.
+     *
+     * @return true if the WebView requires a user gesture to play media
+     * @see #setMediaPlaybackRequiresUserGesture
+     */
+    public boolean getMediaPlaybackRequiresUserGesture() {
+        throw new MustOverrideException();
+    }
+
+    /**
      * Sets whether the WebView should use its built-in zoom mechanisms. The
      * built-in zoom mechanisms comprise on-screen zoom controls, which are
      * displayed over the WebView's content, and the use of a pinch gesture to
@@ -285,14 +317,18 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets whether the WebView loads a page with overview mode.
+     * Sets whether the WebView loads pages in overview mode. The default is
+     * false.
      */
     public void setLoadWithOverviewMode(boolean overview) {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets whether this WebView loads pages with overview mode.
+     * Gets whether this WebView loads pages in overview mode.
+     *
+     * @return whether this WebView loads pages in overview mode
+     * @see #setLoadWithOverviewMode
      */
     public boolean getLoadWithOverviewMode() {
         throw new MustOverrideException();
@@ -304,7 +340,10 @@ public abstract class WebSettings {
      * If it is true, WebView will choose a solution to maximize the performance.
      * e.g. the WebView's content may not be updated during the transition.
      * If it is false, WebView will keep its fidelity. The default value is false.
+     *
+     * @deprecated This method is now obsolete, and will become a no-op in future.
      */
+    @Deprecated
     public void setEnableSmoothTransition(boolean enable) {
         throw new MustOverrideException();
     }
@@ -314,7 +353,10 @@ public abstract class WebSettings {
      * zooming.
      *
      * @see #setEnableSmoothTransition
+     *
+     * @deprecated This method is now obsolete, and will become a no-op in future.
      */
+    @Deprecated
     public boolean enableSmoothTransition() {
         throw new MustOverrideException();
     }
@@ -325,6 +367,7 @@ public abstract class WebSettings {
      * internal pattern. Default is true.
      *
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public void setUseWebViewBackgroundForOverscrollBackground(boolean view) {
@@ -337,6 +380,7 @@ public abstract class WebSettings {
      *
      * @see #setUseWebViewBackgroundForOverscrollBackground
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public boolean getUseWebViewBackgroundForOverscrollBackground() {
@@ -344,38 +388,45 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets whether the WebView is saving form data.
+     * Sets whether the WebView should save form data. The default is true,
+     * unless in private browsing mode, when the value is always false.
      */
     public void setSaveFormData(boolean save) {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets whether the WebView is saving form data and displaying prior
-     * entries/autofill++.  Always false in private browsing mode.
+     * Gets whether the WebView saves form data. Always false in private
+     * browsing mode.
+     *
+     * @return whether the WebView saves form data
+     * @see #setSaveFormData
      */
     public boolean getSaveFormData() {
         throw new MustOverrideException();
     }
 
     /**
-     * Stores whether the WebView is saving password.
+     * Sets whether the WebView should save passwords. The default is true.
      */
     public void setSavePassword(boolean save) {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets whether the WebView is saving password.
+     * Gets whether the WebView saves passwords.
+     *
+     * @return whether the WebView saves passwords
+     * @see #setSavePassword
      */
     public boolean getSavePassword() {
         throw new MustOverrideException();
     }
 
     /**
-     * Sets the text zoom of the page in percent. Default is 100.
+     * Sets the text zoom of the page in percent. The default is 100.
      *
-     * @param textZoom the percent value for increasing or decreasing the text
+     * @param textZoom the text zoom in percent
      */
     public synchronized void setTextZoom(int textZoom) {
         throw new MustOverrideException();
@@ -384,53 +435,65 @@ public abstract class WebSettings {
     /**
      * Gets the text zoom of the page in percent.
      *
-     * @return a percent value describing the text zoom
-     * @see #setTextSizeZoom
+     * @return the text zoom of the page in percent
+     * @see #setTextZoom
      */
     public synchronized int getTextZoom() {
         throw new MustOverrideException();
     }
 
     /**
-     * Sets the text size of the page.
+     * Sets the text size of the page. The default is {@link TextSize#NORMAL}.
      *
-     * @param t the TextSize value for increasing or decreasing the text
-     * @see WebSettings.TextSize
-     * @deprecated Use {@link #setTextZoom(int)} instead.
+     * @param t the text size as a {@link TextSize} value
+     * @deprecated Use {@link #setTextZoom} instead.
      */
     public synchronized void setTextSize(TextSize t) {
-        throw new MustOverrideException();
+        setTextZoom(t.value);
     }
 
     /**
      * Gets the text size of the page. If the text size was previously specified
-     * in percent using {@link #setTextZoom(int)}, this will return
-     * the closest matching {@link TextSize}.
+     * in percent using {@link #setTextZoom}, this will return the closest
+     * matching {@link TextSize}.
      *
-     * @return a TextSize enum value describing the text size
-     * @see WebSettings.TextSize
-     * @deprecated Use {@link #getTextZoom()} instead.
+     * @return the text size as a {@link TextSize} value
+     * @see #setTextSize
+     * @deprecated Use {@link #getTextZoom} instead.
      */
     public synchronized TextSize getTextSize() {
-        throw new MustOverrideException();
+        TextSize closestSize = null;
+        int smallestDelta = Integer.MAX_VALUE;
+        int textSize = getTextZoom();
+        for (TextSize size : TextSize.values()) {
+            int delta = Math.abs(textSize - size.value);
+            if (delta == 0) {
+                return size;
+            }
+            if (delta < smallestDelta) {
+                smallestDelta = delta;
+                closestSize = size;
+            }
+        }
+        return closestSize != null ? closestSize : TextSize.NORMAL;
     }
 
     /**
-     * Sets the default zoom density of the page. This should be called from UI
-     * thread.
+     * Sets the default zoom density of the page. This must be called from the UI
+     * thread. The default is {@link ZoomDensity#MEDIUM}.
      *
-     * @param zoom a ZoomDensity value
-     * @see WebSettings.ZoomDensity
+     * @param zoom the zoom density
      */
     public void setDefaultZoom(ZoomDensity zoom) {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets the default zoom density of the page. This should be called from UI
-     * thread.
-     * @return a ZoomDensity value
-     * @see WebSettings.ZoomDensity
+     * Gets the default zoom density of the page. This should be called from
+     * the UI thread.
+     *
+     * @return the zoom density
+     * @see #setDefaultZoom
      */
     public ZoomDensity getDefaultZoom() {
         throw new MustOverrideException();
@@ -438,6 +501,7 @@ public abstract class WebSettings {
 
     /**
      * Enables using light touches to make a selection and activate mouseovers.
+     * The default is false.
      */
     public void setLightTouchEnabled(boolean enabled) {
         throw new MustOverrideException();
@@ -445,6 +509,9 @@ public abstract class WebSettings {
 
     /**
      * Gets whether light touches are enabled.
+     *
+     * @return whether light touches are enabled
+     * @see #setLightTouchEnabled
      */
     public boolean getLightTouchEnabled() {
         throw new MustOverrideException();
@@ -455,6 +522,7 @@ public abstract class WebSettings {
      * it now has no effect.
      *
      * @deprecated This setting now has no effect.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public synchronized void setUseDoubleTree(boolean use) {
@@ -466,6 +534,7 @@ public abstract class WebSettings {
      * it now has no effect.
      *
      * @deprecated This setting now has no effect.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public synchronized boolean getUseDoubleTree() {
@@ -474,11 +543,17 @@ public abstract class WebSettings {
     }
 
     /**
-     * Tells the WebView about user-agent string.
+     * Sets the user-agent string using an integer code.
+     * <ul>
+     *   <li>0 means the WebView should use an Android user-agent string</li>
+     *   <li>1 means the WebView should use a desktop user-agent string</li>
+     * </ul>
+     * Other values are ignored. The default is an Android user-agent string,
+     * i.e. code value 0.
      *
-     * @param ua 0 if the WebView should use an Android user-agent string,
-     *           1 if the WebView should use a desktop user-agent string
-     * @deprecated Please use setUserAgentString instead.
+     * @param ua the integer code for the user-agent string
+     * @deprecated Please use {@link #setUserAgentString} instead.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public synchronized void setUserAgent(int ua) {
@@ -486,12 +561,18 @@ public abstract class WebSettings {
     }
 
     /**
-     * Gets the user-agent as an int.
+     * Gets the user-agent as an integer code.
+     * <ul>
+     *   <li>-1 means the WebView is using a custom user-agent string set with
+     *   {@link #setUserAgentString}</li>
+     *   <li>0 means the WebView should use an Android user-agent string</li>
+     *   <li>1 means the WebView should use a desktop user-agent string</li>
+     * </ul>
      *
-     * @return 0 if the WebView is using an Android user-agent string,
-     *         1 if the WebView is using a desktop user-agent string,
-     *         -1 if the WebView is using user defined user-agent string
-     * @deprecated Please use getUserAgentString instead.
+     * @return the integer code for the user-agent string
+     * @see #setUserAgent
+     * @deprecated Please use {@link #getUserAgentString} instead.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public synchronized int getUserAgent() {
@@ -499,7 +580,9 @@ public abstract class WebSettings {
     }
 
     /**
-     * Tells the WebView to use the wide viewport.
+     * Tells the WebView to use a wide viewport. The default is false.
+     *
+     * @param use whether to use a wide viewport
      */
     public synchronized void setUseWideViewPort(boolean use) {
         throw new MustOverrideException();
@@ -509,26 +592,28 @@ public abstract class WebSettings {
      * Gets whether the WebView is using a wide viewport.
      *
      * @return true if the WebView is using a wide viewport
+     * @see #setUseWideViewPort
      */
     public synchronized boolean getUseWideViewPort() {
         throw new MustOverrideException();
     }
 
     /**
-     * Tells the WebView whether it supports multiple windows. TRUE means
-     * that {@link WebChromeClient#onCreateWindow(WebView, boolean,
-     * boolean, Message)} is implemented by the host application.
+     * Sets whether the WebView whether supports multiple windows. If set to
+     * true, {@link WebChromeClient#onCreateWindow} must be implemented by the
+     * host application. The default is false.
+     *
+     * @param support whether to suport multiple windows
      */
     public synchronized void setSupportMultipleWindows(boolean support) {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets whether the WebView is supporting multiple windows.
+     * Gets whether the WebView supports multiple windows.
      *
-     * @return true if the WebView is supporting multiple windows. This means
-     *         that {@link WebChromeClient#onCreateWindow(WebView, boolean,
-     *         boolean, Message)} is implemented by the host application.
+     * @return true if the WebView supports multiple windows
+     * @see #setSupportMultipleWindows
      */
     public synchronized boolean supportMultipleWindows() {
         throw new MustOverrideException();
@@ -536,10 +621,9 @@ public abstract class WebSettings {
 
     /**
      * Sets the underlying layout algorithm. This will cause a relayout of the
-     * WebView. The default is NARROW_COLUMNS.
+     * WebView. The default is {@link LayoutAlgorithm#NARROW_COLUMNS}.
      *
-     * @param l a LayoutAlgorithm enum specifying the algorithm to use
-     * @see WebSettings.LayoutAlgorithm
+     * @param l the layout algorithm to use, as a {@link LayoutAlgorithm} value
      */
     public synchronized void setLayoutAlgorithm(LayoutAlgorithm l) {
         throw new MustOverrideException();
@@ -548,10 +632,8 @@ public abstract class WebSettings {
     /**
      * Gets the current layout algorithm.
      *
-     * @return a LayoutAlgorithm enum value describing the layout algorithm
-     *         being used
+     * @return the layout algorithm in use, as a {@link LayoutAlgorithm} value
      * @see #setLayoutAlgorithm
-     * @see WebSettings.LayoutAlgorithm
      */
     public synchronized LayoutAlgorithm getLayoutAlgorithm() {
         throw new MustOverrideException();
@@ -596,7 +678,7 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets the sans-serif font family name.
+     * Sets the sans-serif font family name. The default is "sans-serif".
      *
      * @param font a font family name
      */
@@ -608,6 +690,7 @@ public abstract class WebSettings {
      * Gets the sans-serif font family name.
      *
      * @return the sans-serif font family name as a string
+     * @see #setSansSerifFontFamily
      */
     public synchronized String getSansSerifFontFamily() {
         throw new MustOverrideException();
@@ -751,17 +834,6 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets whether the WebView should preload media resources.
-     *
-     * @param flag whether the WebView should preload media resources.
-     *
-     * @hide
-     */
-    public synchronized void setMediaPreloadEnabled(boolean flag) {
-        throw new MustOverrideException();
-    }
-
-    /**
      * Sets whether the WebView should load image resources. Note that this method
      * controls loading of all images, including those embedded using the data
      * URI scheme. Use {@link #setBlockNetworkImage} to control loading only
@@ -894,9 +966,9 @@ public abstract class WebSettings {
     public abstract void setAllowFileAccessFromFileURLs(boolean flag);
 
     /**
-     * Tells the WebView to enable plugins.
+     * Sets whether the WebView should enable plugins. The default is false.
      *
-     * @param flag true if the WebView should load plugins
+     * @param flag true if plugins should be enabled
      * @deprecated This method has been deprecated in favor of
      *             {@link #setPluginState}
      */
@@ -909,7 +981,8 @@ public abstract class WebSettings {
      * Tells the WebView to enable, disable, or have plugins on demand. On
      * demand mode means that if a plugin exists that can handle the embedded
      * content, a placeholder icon will be shown instead of the plugin. When
-     * the placeholder is clicked, the plugin will be enabled.
+     * the placeholder is clicked, the plugin will be enabled. The default is
+     * {@link PluginState#OFF}.
      *
      * @param state a PluginState value
      */
@@ -932,23 +1005,27 @@ public abstract class WebSettings {
 
     /**
      * Sets the path to where database storage API databases should be saved.
-     * Note that the WebCore Database Tracker only allows the path to be set once.
+     * In order for the database storage API to function correctly, this method
+     * must be called with a path to which the application can write. This
+     * method should only be called once: repeated calls are ignored.
      *
-     * @param databasePath a String path to the directory where databases should
-     *                     be saved. May be the empty string but should never
-     *                     be null.
+     * @param databasePath a path to the directory where databases should be
+     *                     saved.
      */
     // This will update WebCore when the Sync runs in the C++ side.
+    // Note that the WebCore Database Tracker only allows the path to be set
+    // once.
     public synchronized void setDatabasePath(String databasePath) {
         throw new MustOverrideException();
     }
 
     /**
-     * Sets the path where the Geolocation permissions database should be saved.
+     * Sets the path where the Geolocation databases should be saved. In order
+     * for Geolocation permissions and cached positions to be persisted, this
+     * method must be called with a path to which the application can write.
      *
-     * @param databasePath a String path to the directory where the Geolocation
-     *                     permissions database should be saved. May be the
-     *                     empty string but should never be null.
+     * @param databasePath a path to the directory where databases should be
+     *                     saved.
      */
     // This will update WebCore when the Sync runs in the C++ side.
     public synchronized void setGeolocationDatabasePath(String databasePath) {
@@ -956,7 +1033,10 @@ public abstract class WebSettings {
     }
 
     /**
-     * Tells the WebView to enable Application Caches API.
+     * Sets whether the Application Caches API should be enabled. The default
+     * is false. Note that in order for the Application Caches API to be
+     * enabled, a valid database path must also be supplied to
+     * {@link #setAppCachePath}.
      *
      * @param flag true if the WebView should enable Application Caches
      */
@@ -965,20 +1045,25 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets a custom path to the Application Caches files. The client
-     * must ensure it exists before this call.
+     * Sets the path to the Application Caches files. In order for the
+     * Application Caches API to be enabled, this method must be called with a
+     * path to which the application can write. This method should only be
+     * called once: repeated calls are ignored.
      *
      * @param appCachePath a String path to the directory containing
-     *                     Application Caches files. The appCache path can be
-     *                     the empty string but should not be null. Passing
-     *                     null for this parameter will result in a no-op.
+     *                     Application Caches files.
+     * @see setAppCacheEnabled
      */
     public synchronized void setAppCachePath(String appCachePath) {
         throw new MustOverrideException();
     }
 
     /**
-     * Sets the maximum size for the Application Caches content.
+     * Sets the maximum size for the Application Cache content. The passed size
+     * will be rounded to the nearest value that the database can support, so
+     * this should be viewed as a guide, not a hard limit. Setting the
+     * size to a value less than current database size does not cause the
+     * database to be trimmed. The default size is {@link Long#MAX_VALUE}.
      *
      * @param appCacheMaxSize the maximum size in bytes
      */
@@ -987,7 +1072,9 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets whether the database storage API is enabled.
+     * Sets whether the database storage API is enabled. The default value is
+     * false. See also {@link #setDatabasePath} for how to correctly set up the
+     * database storage API.
      *
      * @param flag true if the WebView should use the database storage API
      */
@@ -996,7 +1083,7 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets whether the DOM storage API is enabled.
+     * Sets whether the DOM storage API is enabled. The default value is false.
      *
      * @param flag true if the WebView should use the DOM storage API
      */
@@ -1008,15 +1095,16 @@ public abstract class WebSettings {
      * Gets whether the DOM Storage APIs are enabled.
      *
      * @return true if the DOM Storage APIs are enabled
+     * @see #setDomStorageEnabled
      */
     public synchronized boolean getDomStorageEnabled() {
         throw new MustOverrideException();
     }
     /**
-     * Gets the path to where database storage API databases are saved for
-     * the current WebView.
+     * Gets the path to where database storage API databases are saved.
      *
      * @return the String path to the database storage API databases
+     * @see #setDatabasePath
      */
     public synchronized String getDatabasePath() {
         throw new MustOverrideException();
@@ -1026,13 +1114,16 @@ public abstract class WebSettings {
      * Gets whether the database storage API is enabled.
      *
      * @return true if the database storage API is enabled
+     * @see #setDatabaseEnabled
      */
     public synchronized boolean getDatabaseEnabled() {
         throw new MustOverrideException();
     }
 
     /**
-     * Sets whether Geolocation is enabled.
+     * Sets whether Geolocation is enabled. The default is true. See also
+     * {@link #setGeolocationDatabasePath} for how to correctly set up
+     * Geolocation.
      *
      * @param flag whether Geolocation should be enabled
      */
@@ -1075,6 +1166,7 @@ public abstract class WebSettings {
      * Gets whether plugins are enabled.
      *
      * @return true if plugins are enabled
+     * @see #setPluginsEnabled
      * @deprecated This method has been replaced by {@link #getPluginState}
      */
     @Deprecated
@@ -1083,9 +1175,10 @@ public abstract class WebSettings {
     }
 
     /**
-     * Gets the current plugin state.
+     * Gets the current state regarding whether plugins are enabled.
      *
-     * @return a value corresponding to the enum PluginState
+     * @return the plugin state as a {@link PluginState} value
+     * @see #setPluginState
      */
     public synchronized PluginState getPluginState() {
         throw new MustOverrideException();
@@ -1146,8 +1239,8 @@ public abstract class WebSettings {
     }
 
     /**
-     * Sets the WebView's user-agent string. If the string "ua" is null or empty,
-     * it will use the system default user-agent string.
+     * Sets the WebView's user-agent string. If the string is null or empty,
+     * the system default value will be used.
      */
     public synchronized void setUserAgentString(String ua) {
         throw new MustOverrideException();
@@ -1155,14 +1248,29 @@ public abstract class WebSettings {
 
     /**
      * Gets the WebView's user-agent string.
+     *
+     * @return the WebView's user-agent string
+     * @see #setUserAgentString
      */
     public synchronized String getUserAgentString() {
         throw new MustOverrideException();
     }
 
     /**
+     * Returns the default User-Agent used by a WebView.
+     * An instance of WebView could use a different User-Agent if a call
+     * is made to {@link WebSettings#setUserAgentString(String)}.
+     *
+     * @param context a Context object used to access application assets
+     */
+    public static String getDefaultUserAgent(Context context) {
+        return WebViewFactory.getProvider().getStatics().getDefaultUserAgent(context);
+    }
+
+    /**
      * Tells the WebView whether it needs to set a node to have focus when
-     * {@link WebView#requestFocus(int, android.graphics.Rect)} is called.
+     * {@link WebView#requestFocus(int, android.graphics.Rect)} is called. The
+     * default value is true.
      *
      * @param flag whether the WebView needs to set a node
      */
@@ -1172,9 +1280,10 @@ public abstract class WebSettings {
 
     /**
      * Sets the priority of the Render thread. Unlike the other settings, this
-     * one only needs to be called once per process. The default is NORMAL.
+     * one only needs to be called once per process. The default value is
+     * {@link RenderPriority#NORMAL}.
      *
-     * @param priority a RenderPriority
+     * @param priority the priority
      */
     public synchronized void setRenderPriority(RenderPriority priority) {
         throw new MustOverrideException();
@@ -1182,20 +1291,25 @@ public abstract class WebSettings {
 
     /**
      * Overrides the way the cache is used. The way the cache is used is based
-     * on the navigation option. For a normal page load, the cache is checked
+     * on the navigation type. For a normal page load, the cache is checked
      * and content is re-validated as needed. When navigating back, content is
-     * not revalidated, instead the content is just pulled from the cache.
-     * This function allows the client to override this behavior.
+     * not revalidated, instead the content is just retrieved from the cache.
+     * This method allows the client to override this behavior by specifying
+     * one of {@link #LOAD_DEFAULT}, {@link #LOAD_NORMAL},
+     * {@link #LOAD_CACHE_ELSE_NETWORK}, {@link #LOAD_NO_CACHE} or
+     * {@link #LOAD_CACHE_ONLY}. The default value is {@link #LOAD_DEFAULT}.
      *
-     * @param mode one of the LOAD_ values
+     * @param mode the mode to use
      */
     public void setCacheMode(int mode) {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets the current setting for overriding the cache mode. For a full
-     * description, see the {@link #setCacheMode(int)} function.
+     * Gets the current setting for overriding the cache mode.
+     *
+     * @return the current setting for overriding the cache mode
+     * @see #setCacheMode
      */
     public int getCacheMode() {
         throw new MustOverrideException();
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebStorage.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebStorage.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebStorage.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebStorage.java	2013-03-12 17:03:37.000000000 +0100
@@ -23,17 +23,22 @@ import java.util.Map;
  * {@link WebView}. It manages the Application Cache API, the Web SQL Database
  * API and the HTML5 Web Storage API.
  *
- * The Web SQL Database API provides storage which is private to a given
- * origin, where an origin comprises the host, scheme and port of a URI.
- * Similarly, use of the Application Cache API can be attributed to an origin.
- * This class provides access to the storage use and quotas for these APIs for
- * a given origin. Origins are represented using {@link WebStorage.Origin}.
+ * The Application Cache API provides a mechanism to create and maintain an
+ * application cache to power offline Web applications. Use of the Application
+ * Cache API can be attributed to an origin {@link WebStorage.Origin}, however
+ * it is not possible to set per-origin quotas. Note that there can be only
+ * one application cache per application.
+ *
+ * The Web SQL Database API provides storage which is private to a given origin.
+ * Similar to the Application Cache, use of the Web SQL Database can be attributed
+ * to an origin. It is also possible to set per-origin quotas.
  */
 public class WebStorage {
 
     /**
      * Encapsulates a callback function which is used to provide a new quota
-     * for a JavaScript storage API. See
+     * for a JavaScript storage API.
+     * See
      * {@link WebChromeClient#onExceededDatabaseQuota} and
      * {@link WebChromeClient#onReachedMaxAppCacheSize}.
      */
@@ -54,6 +59,7 @@ public class WebStorage {
     /**
      * This class encapsulates information about the amount of storage
      * currently used by an origin for the JavaScript storage APIs.
+     * An origin comprises the host, scheme and port of a URI.
      * See {@link WebStorage} for details.
      */
     public static class Origin {
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebSyncManager.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebSyncManager.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebSyncManager.java	2013-03-12 17:09:11.254011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebSyncManager.java	2013-03-12 17:03:37.000000000 +0100
@@ -37,9 +37,6 @@ abstract class WebSyncManager implements
     // handler of the sync thread
     protected Handler mHandler;
     // database for the persistent storage
-    // Note that this remains uninitialised as it is unused. We cannot remove
-    // the member as it leaked into the public API via CookieSyncManager.
-    // TODO: hide this member, ditto for mHandler.
     protected WebViewDatabase mDataBase;
     // Ref count for calls to start/stop sync
     private int mStartSyncRefCount;
@@ -65,6 +62,7 @@ abstract class WebSyncManager implements
     protected WebSyncManager(Context context, String name) {
         mThreadName = name;
         if (context != null) {
+            mDataBase = WebViewDatabase.getInstance(context);
             mSyncThread = new Thread(this);
             mSyncThread.setName(mThreadName);
             mSyncThread.start();
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewClassic.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewClassic.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewClassic.java	2013-03-12 17:09:11.262011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewClassic.java	2013-03-12 17:03:37.000000000 +0100
@@ -1,6 +1,5 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
- * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +16,7 @@
 
 package android.webkit;
 
+import android.accessibilityservice.AccessibilityServiceInfo;
 import android.animation.ObjectAnimator;
 import android.annotation.Widget;
 import android.app.ActivityManager;
@@ -27,7 +27,6 @@ import android.content.ClipboardManager;
 import android.content.ComponentCallbacks2;
 import android.content.Context;
 import android.content.DialogInterface;
-import android.content.DialogInterface.OnCancelListener;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
@@ -56,6 +55,7 @@ import android.net.ProxyProperties;
 import android.net.Uri;
 import android.net.http.SslCertificate;
 import android.os.AsyncTask;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
@@ -69,7 +69,6 @@ import android.text.TextUtils;
 import android.util.DisplayMetrics;
 import android.util.EventLog;
 import android.util.Log;
-import android.view.Display;
 import android.view.Gravity;
 import android.view.HapticFeedbackConstants;
 import android.view.HardwareCanvas;
@@ -87,7 +86,6 @@ import android.view.ViewConfiguration;
 import android.view.ViewGroup;
 import android.view.ViewParent;
 import android.view.ViewRootImpl;
-import android.view.WindowManager;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityManager;
 import android.view.accessibility.AccessibilityNodeInfo;
@@ -118,6 +116,8 @@ import android.widget.Toast;
 
 import junit.framework.Assert;
 
+import java.io.BufferedWriter;
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -130,11 +130,10 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.Vector;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * Implements a backend provider for the {@link WebView} public API.
@@ -276,7 +275,6 @@ public final class WebViewClassic implem
             super.setComposingText(limitedText, newCursorPosition);
             updateSelection();
             if (limitedText != text) {
-                restartInput();
                 int lastCaret = start + limitedText.length();
                 finishComposingText();
                 setSelection(lastCaret, lastCaret);
@@ -377,28 +375,26 @@ public final class WebViewClassic implem
                     imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS;
                 }
             }
+            int action = EditorInfo.IME_ACTION_GO;
             switch (type) {
                 case WebTextView.NORMAL_TEXT_FIELD:
-                    imeOptions |= EditorInfo.IME_ACTION_GO;
                     break;
                 case WebTextView.TEXT_AREA:
                     inputType |= InputType.TYPE_TEXT_FLAG_MULTI_LINE
                             | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES
                             | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT;
-                    imeOptions |= EditorInfo.IME_ACTION_NONE;
+                    action = EditorInfo.IME_ACTION_NONE;
                     break;
                 case WebTextView.PASSWORD:
                     inputType |= EditorInfo.TYPE_TEXT_VARIATION_WEB_PASSWORD;
-                    imeOptions |= EditorInfo.IME_ACTION_GO;
                     break;
                 case WebTextView.SEARCH:
-                    imeOptions |= EditorInfo.IME_ACTION_SEARCH;
+                    action = EditorInfo.IME_ACTION_SEARCH;
                     break;
                 case WebTextView.EMAIL:
                     // inputType needs to be overwritten because of the different text variation.
                     inputType = InputType.TYPE_CLASS_TEXT
                             | InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS;
-                    imeOptions |= EditorInfo.IME_ACTION_GO;
                     break;
                 case WebTextView.NUMBER:
                     // inputType needs to be overwritten because of the different class.
@@ -406,23 +402,20 @@ public final class WebViewClassic implem
                             | InputType.TYPE_NUMBER_FLAG_SIGNED | InputType.TYPE_NUMBER_FLAG_DECIMAL;
                     // Number and telephone do not have both a Tab key and an
                     // action, so set the action to NEXT
-                    imeOptions |= EditorInfo.IME_ACTION_NEXT;
                     break;
                 case WebTextView.TELEPHONE:
                     // inputType needs to be overwritten because of the different class.
                     inputType = InputType.TYPE_CLASS_PHONE;
-                    imeOptions |= EditorInfo.IME_ACTION_NEXT;
                     break;
                 case WebTextView.URL:
                     // TYPE_TEXT_VARIATION_URI prevents Tab key from showing, so
                     // exclude it for now.
-                    imeOptions |= EditorInfo.IME_ACTION_GO;
                     inputType |= InputType.TYPE_TEXT_VARIATION_URI;
                     break;
                 default:
-                    imeOptions |= EditorInfo.IME_ACTION_GO;
                     break;
             }
+            imeOptions |= action;
             mHint = initData.mLabel;
             mInputType = inputType;
             mImeOptions = imeOptions;
@@ -680,6 +673,8 @@ public final class WebViewClassic implem
     // after resize.
     static private final int EDIT_RECT_BUFFER = 10;
 
+    static private final long SELECTION_HANDLE_ANIMATION_MS = 150;
+
     // true means redraw the screen all-the-time. Only with AUTO_REDRAW_HACK
     private boolean mAutoRedraw;
 
@@ -739,9 +734,16 @@ public final class WebViewClassic implem
             if (DebugFlags.WEB_VIEW) {
                 Log.d("WebView", "onTrimMemory: " + level);
             }
+            // When framework reset EGL context during high memory pressure, all
+            // the existing GL resources for the html5 video will be destroyed
+            // at native side.
+            // Here we just need to clean up the Surface Texture which is static.
+            if (level > TRIM_MEMORY_UI_HIDDEN) {
+                HTML5VideoInline.cleanupSurfaceTexture();
+                HTML5VideoView.release();
+            }
             WebViewClassic.nativeOnTrimMemory(level);
         }
-
     }
 
     // A final CallbackProxy shared by WebViewCore and BrowserFrame.
@@ -943,21 +945,20 @@ public final class WebViewClassic implem
     private Drawable mSelectHandleLeft;
     private Drawable mSelectHandleRight;
     private Drawable mSelectHandleCenter;
-    private Point mSelectHandleLeftOffset;
-    private Point mSelectHandleRightOffset;
-    private Point mSelectHandleCenterOffset;
-    private Point mSelectCursorLeft = new Point();
-    private int mSelectCursorLeftLayerId;
-    private QuadF mSelectCursorLeftTextQuad = new QuadF();
-    private Point mSelectCursorRight = new Point();
-    private int mSelectCursorRightLayerId;
-    private QuadF mSelectCursorRightTextQuad = new QuadF();
+    private Point mSelectOffset;
+    private Point mSelectCursorBase = new Point();
+    private Rect mSelectHandleBaseBounds = new Rect();
+    private int mSelectCursorBaseLayerId;
+    private QuadF mSelectCursorBaseTextQuad = new QuadF();
+    private Point mSelectCursorExtent = new Point();
+    private Rect mSelectHandleExtentBounds = new Rect();
+    private int mSelectCursorExtentLayerId;
+    private QuadF mSelectCursorExtentTextQuad = new QuadF();
     private Point mSelectDraggingCursor;
-    private Point mSelectDraggingOffset;
     private QuadF mSelectDraggingTextQuad;
     private boolean mIsCaretSelection;
-    static final int HANDLE_ID_LEFT = 0;
-    static final int HANDLE_ID_RIGHT = 1;
+    static final int HANDLE_ID_BASE = 0;
+    static final int HANDLE_ID_EXTENT = 1;
 
     // the color used to highlight the touch rectangles
     static final int HIGHLIGHT_COLOR = 0x6633b5e5;
@@ -973,9 +974,9 @@ public final class WebViewClassic implem
     private int mTouchHighlightY;
     private boolean mShowTapHighlight;
 
-    // The HTML5VideoViewManager is used to tell the Video to update layer tree at
+    // Basically this proxy is used to tell the Video to update layer tree at
     // SetBaseLayer time and to pause when WebView paused.
-    private HTML5VideoViewManager mHTML5VideoViewManager;
+    private HTML5VideoViewProxy mHTML5VideoViewProxy;
 
     // If we are using a set picture, don't send view updates to webkit
     private boolean mBlockWebkitViewMessages = false;
@@ -1031,7 +1032,6 @@ public final class WebViewClassic implem
     static final int AUTOFILL_COMPLETE                  = 134;
 
     static final int SCREEN_ON                          = 136;
-    static final int ENTER_FULLSCREEN_VIDEO             = 137;
     static final int UPDATE_ZOOM_DENSITY                = 139;
     static final int EXIT_FULLSCREEN_VIDEO              = 140;
 
@@ -1047,6 +1047,7 @@ public final class WebViewClassic implem
     static final int EDIT_TEXT_SIZE_CHANGED             = 150;
     static final int SHOW_CARET_HANDLE                  = 151;
     static final int UPDATE_CONTENT_BOUNDS              = 152;
+    static final int SCROLL_HANDLE_INTO_VIEW            = 153;
 
     private static final int FIRST_PACKAGE_MSG_ID = SCROLL_TO_MSG_ID;
     private static final int LAST_PACKAGE_MSG_ID = HIT_TEST_RESULT;
@@ -1307,6 +1308,12 @@ public final class WebViewClassic implem
         public WebViewDatabase getWebViewDatabase(Context context) {
             return WebViewDatabaseClassic.getInstance(context);
         }
+
+        @Override
+        public String getDefaultUserAgent(Context context) {
+            return WebSettingsClassic.getDefaultUserAgentForLocale(context,
+                    Locale.getDefault());
+        }
     }
 
     private void onHandleUiEvent(MotionEvent event, int eventType, int flags) {
@@ -1640,6 +1647,12 @@ public final class WebViewClassic implem
         mZoomManager.updateMultiTouchSupport(context);
     }
 
+    void updateJavaScriptEnabled(boolean enabled) {
+        if (isAccessibilityInjectionEnabled()) {
+            getAccessibilityInjector().updateJavaScriptEnabled(enabled);
+        }
+    }
+
     private void init() {
         OnTrimMemoryListener.init(mContext);
         mWebView.setWillNotDraw(false);
@@ -1651,7 +1664,7 @@ public final class WebViewClassic implem
         mTouchSlopSquare = slop * slop;
         slop = configuration.getScaledDoubleTapSlop();
         mDoubleTapSlopSquare = slop * slop;
-        final float density = mContext.getResources().getDisplayMetrics().density;
+        final float density = WebViewCore.getFixedDisplayDensity(mContext);
         // use one line height, 16 based on our current default font, for how
         // far we allow a touch be away from the edge of a link
         mNavSlop = (int) (16 * density);
@@ -1668,7 +1681,7 @@ public final class WebViewClassic implem
         // Initially use a size of two, since the user is likely to only hold
         // down two keys at a time (shift + another key)
         mKeysPressed = new Vector<Integer>(2);
-        mHTML5VideoViewManager = null;
+        mHTML5VideoViewProxy = null ;
     }
 
     @Override
@@ -1753,8 +1766,21 @@ public final class WebViewClassic implem
         event.setMaxScrollY(Math.max(convertedContentHeight - adjustedViewHeight, 0));
     }
 
-    private boolean isAccessibilityEnabled() {
-        return AccessibilityManager.getInstance(mContext).isEnabled();
+    private boolean isAccessibilityInjectionEnabled() {
+        final AccessibilityManager manager = AccessibilityManager.getInstance(mContext);
+        if (!manager.isEnabled()) {
+            return false;
+        }
+
+        // Accessibility scripts should be injected only when a speaking service
+        // is enabled. This may need to change later to accommodate Braille.
+        final List<AccessibilityServiceInfo> services = manager.getEnabledAccessibilityServiceList(
+                AccessibilityServiceInfo.FEEDBACK_SPOKEN);
+        if (services.isEmpty()) {
+            return false;
+        }
+
+        return true;
     }
 
     private AccessibilityInjector getAccessibilityInjector() {
@@ -1783,7 +1809,7 @@ public final class WebViewClassic implem
     }
 
     /* package */ void adjustDefaultZoomDensity(int zoomDensity) {
-        final float density = mContext.getResources().getDisplayMetrics().density
+        final float density = WebViewCore.getFixedDisplayDensity(mContext)
                 * 100 / zoomDensity;
         updateDefaultZoomDensity(density);
     }
@@ -1860,9 +1886,9 @@ public final class WebViewClassic implem
                             mSavePasswordDialog = null;
                         }
                     })
-                    .setOnCancelListener(new OnCancelListener() {
+                    .setOnDismissListener(new DialogInterface.OnDismissListener() {
                         @Override
-                        public void onCancel(DialogInterface dialog) {
+                        public void onDismiss(DialogInterface dialog) {
                             if (mResumeMsg != null) {
                                 resumeMsg.sendToTarget();
                                 mResumeMsg = null;
@@ -2067,14 +2093,18 @@ public final class WebViewClassic implem
         hideSoftKeyboard();
         clearActionModes();
         dismissFullScreenMode();
-        cancelSelectDialog();
+        cancelDialogs();
     }
 
-    private void cancelSelectDialog() {
+    private void cancelDialogs() {
         if (mListBoxDialog != null) {
             mListBoxDialog.cancel();
             mListBoxDialog = null;
         }
+        if (mSavePasswordDialog != null) {
+            mSavePasswordDialog.dismiss();
+            mSavePasswordDialog = null;
+        }
     }
 
     /**
@@ -2102,14 +2132,9 @@ public final class WebViewClassic implem
 
     private void destroyJava() {
         mCallbackProxy.blockMessages();
-        clearHelpers();
-        if (mListBoxDialog != null) {
-            mListBoxDialog.dismiss();
-            mListBoxDialog = null;
-        }
-        if (mSavePasswordDialog != null) {
-            mSavePasswordDialog.dismiss();
-            mSavePasswordDialog = null;
+        if (mAccessibilityInjector != null) {
+            mAccessibilityInjector.destroy();
+            mAccessibilityInjector = null;
         }
         if (mWebViewCore != null) {
             // Tell WebViewCore to destroy itself
@@ -2217,7 +2242,7 @@ public final class WebViewClassic implem
         }
         // We grab a copy of the back/forward list because a client of WebView
         // may have invalidated the history list by calling clearHistory.
-        WebBackForwardList list = copyBackForwardList();
+        WebBackForwardListClassic list = copyBackForwardList();
         final int currentIndex = list.getCurrentIndex();
         final int size = list.getSize();
         // We should fail saving the state if the list is empty or the index is
@@ -2231,7 +2256,7 @@ public final class WebViewClassic implem
         // arrays.
         ArrayList<byte[]> history = new ArrayList<byte[]>(size);
         for (int i = 0; i < size; i++) {
-            WebHistoryItem item = list.getItemAtIndex(i);
+            WebHistoryItemClassic item = list.getItemAtIndex(i);
             if (null == item) {
                 // FIXME: this shouldn't happen
                 // need to determine how item got set to null
@@ -2430,7 +2455,7 @@ public final class WebViewClassic implem
      */
     @Override
     public WebBackForwardList restoreState(Bundle inState) {
-        WebBackForwardList returnList = null;
+        WebBackForwardListClassic returnList = null;
         if (inState == null) {
             return returnList;
         }
@@ -2438,7 +2463,7 @@ public final class WebViewClassic implem
             mCertificate = SslCertificate.restoreState(
                 inState.getBundle("certificate"));
 
-            final WebBackForwardList list = mCallbackProxy.getBackForwardList();
+            final WebBackForwardListClassic list = mCallbackProxy.getBackForwardList();
             final int index = inState.getInt("index");
             // We can't use a clone of the list because we need to modify the
             // shared copy, so synchronize instead to prevent concurrent
@@ -2459,7 +2484,7 @@ public final class WebViewClassic implem
                         // the item and thus our history list cannot be rebuilt.
                         return null;
                     }
-                    WebHistoryItem item = new WebHistoryItem(data);
+                    WebHistoryItem item = new WebHistoryItemClassic(data);
                     list.addHistoryItem(item);
                 }
                 // Grab the most recent copy to return to the caller.
@@ -2475,6 +2500,9 @@ public final class WebViewClassic implem
             // Remove all pending messages because we are restoring previous
             // state.
             mWebViewCore.removeMessages();
+            if (isAccessibilityInjectionEnabled()) {
+                getAccessibilityInjector().addAccessibilityApisIfNecessary();
+            }
             // Send a restore state message.
             mWebViewCore.sendMessage(EventHub.RESTORE_STATE, index);
         }
@@ -2491,8 +2519,6 @@ public final class WebViewClassic implem
 
     private void loadUrlImpl(String url, Map<String, String> extraHeaders) {
         switchOutDrawHistory();
-        if (mHTML5VideoViewManager != null)
-            mHTML5VideoViewManager.suspend();
         WebViewCore.GetUrlData arg = new WebViewCore.GetUrlData();
         arg.mUrl = url;
         arg.mExtraHeaders = extraHeaders;
@@ -2626,8 +2652,6 @@ public final class WebViewClassic implem
     public void reload() {
         clearHelpers();
         switchOutDrawHistory();
-        if (mHTML5VideoViewManager != null)
-            mHTML5VideoViewManager.suspend();
         mWebViewCore.sendMessage(EventHub.RELOAD);
     }
 
@@ -2636,7 +2660,7 @@ public final class WebViewClassic implem
      */
     @Override
     public boolean canGoBack() {
-        WebBackForwardList l = mCallbackProxy.getBackForwardList();
+        WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
         synchronized (l) {
             if (l.getClearPending()) {
                 return false;
@@ -2659,7 +2683,7 @@ public final class WebViewClassic implem
      */
     @Override
     public boolean canGoForward() {
-        WebBackForwardList l = mCallbackProxy.getBackForwardList();
+        WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
         synchronized (l) {
             if (l.getClearPending()) {
                 return false;
@@ -2682,7 +2706,7 @@ public final class WebViewClassic implem
      */
     @Override
     public boolean canGoBackOrForward(int steps) {
-        WebBackForwardList l = mCallbackProxy.getBackForwardList();
+        WebBackForwardListClassic l = mCallbackProxy.getBackForwardList();
         synchronized (l) {
             if (l.getClearPending()) {
                 return false;
@@ -2707,8 +2731,6 @@ public final class WebViewClassic implem
 
     private void goBackOrForward(int steps, boolean ignoreSnapshot) {
         if (steps != 0) {
-            if (mHTML5VideoViewManager != null)
-                mHTML5VideoViewManager.suspend();
             clearHelpers();
             mWebViewCore.sendMessage(EventHub.GO_BACK_FORWARD, steps,
                     ignoreSnapshot ? 1 : 0);
@@ -3332,6 +3354,7 @@ public final class WebViewClassic implem
         }
         if (mTouchMode == TOUCH_DRAG_LAYER_MODE) {
             scrollLayerTo(scrollX, scrollY);
+            animateHandles();
             return;
         }
         mInOverScrollMode = false;
@@ -3352,6 +3375,8 @@ public final class WebViewClassic implem
 
         mWebViewPrivate.super_scrollTo(scrollX, scrollY);
 
+        animateHandles();
+
         if (mOverScrollGlow != null) {
             mOverScrollGlow.pullGlow(getScrollX(), getScrollY(), oldX, oldY, maxX, maxY);
         }
@@ -3398,7 +3423,7 @@ public final class WebViewClassic implem
      */
     @Override
     public String getTouchIconUrl() {
-        WebHistoryItem h = mCallbackProxy.getBackForwardList().getCurrentItem();
+        WebHistoryItemClassic h = mCallbackProxy.getBackForwardList().getCurrentItem();
         return h != null ? h.getTouchIconUrl() : null;
     }
 
@@ -3457,14 +3482,14 @@ public final class WebViewClassic implem
             mWebViewCore.sendMessage(EventHub.ON_PAUSE);
             // We want to pause the current playing video when switching out
             // from the current WebView/tab.
-            if (mHTML5VideoViewManager != null) {
-                mHTML5VideoViewManager.pauseAndDispatch();
+            if (mHTML5VideoViewProxy != null) {
+                mHTML5VideoViewProxy.pauseAndDispatch();
             }
             if (mNativeClass != 0) {
                 nativeSetPauseDrawing(mNativeClass, true);
             }
 
-            cancelSelectDialog();
+            cancelDialogs();
             WebCoreThreadWatchdog.pause();
         }
     }
@@ -3562,7 +3587,7 @@ public final class WebViewClassic implem
      * See {@link WebView#copyBackForwardList()}
      */
     @Override
-    public WebBackForwardList copyBackForwardList() {
+    public WebBackForwardListClassic copyBackForwardList() {
         return mCallbackProxy.getBackForwardList().clone();
     }
 
@@ -3570,7 +3595,8 @@ public final class WebViewClassic implem
      * See {@link WebView#setFindListener(WebView.FindListener)}.
      * @hide
      */
-     public void setFindListener(WebView.FindListener listener) {
+     @Override
+    public void setFindListener(WebView.FindListener listener) {
          mFindListener = listener;
      }
 
@@ -3593,6 +3619,7 @@ public final class WebViewClassic implem
         return findAllBody(find, false);
     }
 
+    @Override
     public void findAllAsync(String find) {
         findAllBody(find, true);
     }
@@ -3631,6 +3658,7 @@ public final class WebViewClassic implem
      *             If false and text is non-null, perform a find all.
      * @return boolean True if the find dialog is shown, false otherwise.
      */
+    @Override
     public boolean showFindDialog(String text, boolean showIme) {
         FindActionModeCallback callback = new FindActionModeCallback(mContext);
         if (mWebView.getParent() == null || mWebView.startActionMode(callback) == null) {
@@ -3848,17 +3876,14 @@ public final class WebViewClassic implem
             return;
         }
         if (mSelectingText) {
-            if (mSelectCursorLeftLayerId == mCurrentScrollingLayerId) {
-                mSelectCursorLeft.offset(dx, dy);
-                mSelectCursorLeftTextQuad.offset(dx, dy);
-            }
-            if (mSelectCursorRightLayerId == mCurrentScrollingLayerId) {
-                mSelectCursorRight.offset(dx, dy);
-                mSelectCursorRightTextQuad.offset(dx, dy);
-            }
-        } else if (mHandleAlpha.getAlpha() > 0) {
-            // stop fading as we're not going to move with the layer.
-            mHandleAlphaAnimator.end();
+            if (mSelectCursorBaseLayerId == mCurrentScrollingLayerId) {
+                mSelectCursorBase.offset(dx, dy);
+                mSelectCursorBaseTextQuad.offset(dx, dy);
+            }
+            if (mSelectCursorExtentLayerId == mCurrentScrollingLayerId) {
+                mSelectCursorExtent.offset(dx, dy);
+                mSelectCursorExtentTextQuad.offset(dx, dy);
+            }
         }
         if (mAutoCompletePopup != null &&
                 mCurrentScrollingLayerId == mEditTextLayerId) {
@@ -3951,9 +3976,7 @@ public final class WebViewClassic implem
         // null, and that will be the case
         mWebView.setCertificate(null);
 
-        // reset the flag since we set to true in if need after
-        // loading is see onPageFinished(Url)
-        if (isAccessibilityEnabled()) {
+        if (isAccessibilityInjectionEnabled()) {
             getAccessibilityInjector().onPageStarted(url);
         }
 
@@ -3968,7 +3991,7 @@ public final class WebViewClassic implem
     /* package */ void onPageFinished(String url) {
         mZoomManager.onPageFinished(url);
 
-        if (isAccessibilityEnabled()) {
+        if (isAccessibilityInjectionEnabled()) {
             getAccessibilityInjector().onPageFinished(url);
         }
     }
@@ -4099,12 +4122,22 @@ public final class WebViewClassic implem
      */
     @Override
     public void addJavascriptInterface(Object object, String name) {
+
         if (object == null) {
             return;
         }
         WebViewCore.JSInterfaceData arg = new WebViewCore.JSInterfaceData();
+
         arg.mObject = object;
         arg.mInterfaceName = name;
+
+        // starting with JELLY_BEAN_MR1, annotations are mandatory for enabling access to
+        // methods that are accessible from JS.
+        if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            arg.mRequireAnnotation = true;
+        } else {
+            arg.mRequireAnnotation = false;
+        }
         mWebViewCore.sendMessage(EventHub.ADD_JS_INTERFACE, arg);
     }
 
@@ -4461,8 +4494,8 @@ public final class WebViewClassic implem
             mWebViewCore.resumeWebKitDraw();
         }
 
-        if (mHTML5VideoViewManager != null) {
-            mHTML5VideoViewManager.setBaseLayer(layer);
+        if (mHTML5VideoViewProxy != null) {
+            mHTML5VideoViewProxy.setBaseLayer(layer);
         }
     }
 
@@ -4474,9 +4507,6 @@ public final class WebViewClassic implem
     }
 
     private void onZoomAnimationStart() {
-        if (!mSelectingText && mHandleAlpha.getAlpha() > 0) {
-            mHandleAlphaAnimator.end();
-        }
     }
 
     private void onZoomAnimationEnd() {
@@ -4509,34 +4539,63 @@ public final class WebViewClassic implem
 
     private class SelectionHandleAlpha {
         private int mAlpha = 0;
+        private int mTargetAlpha = 0;
+
         public void setAlpha(int alpha) {
             mAlpha = alpha;
-            if (mSelectHandleCenter != null) {
-                mSelectHandleCenter.setAlpha(alpha);
-                mSelectHandleLeft.setAlpha(alpha);
-                mSelectHandleRight.setAlpha(alpha);
-                // TODO: Use partial invalidate
-                invalidate();
-            }
+            // TODO: Use partial invalidate
+            invalidate();
         }
 
         public int getAlpha() {
             return mAlpha;
         }
 
+        public void setTargetAlpha(int alpha) {
+            mTargetAlpha = alpha;
+        }
+
+        public int getTargetAlpha() {
+            return mTargetAlpha;
+        }
+
     }
 
     private void startSelectingText() {
         mSelectingText = true;
         mShowTextSelectionExtra = true;
-        mHandleAlphaAnimator.setIntValues(255);
-        mHandleAlphaAnimator.start();
+        animateHandles();
+    }
+
+    private void animateHandle(boolean canShow, ObjectAnimator animator,
+            Point selectionPoint, int selectionLayerId,
+            SelectionHandleAlpha alpha) {
+        boolean isVisible = canShow && mSelectingText
+                && ((mSelectionStarted && mSelectDraggingCursor == selectionPoint)
+                || isHandleVisible(selectionPoint, selectionLayerId));
+        int targetValue = isVisible ? 255 : 0;
+        if (targetValue != alpha.getTargetAlpha()) {
+            alpha.setTargetAlpha(targetValue);
+            animator.setIntValues(targetValue);
+            animator.setDuration(SELECTION_HANDLE_ANIMATION_MS);
+            animator.start();
+        }
     }
+
+    private void animateHandles() {
+        boolean canShowBase = mSelectingText;
+        boolean canShowExtent = mSelectingText && !mIsCaretSelection;
+        animateHandle(canShowBase, mBaseHandleAlphaAnimator, mSelectCursorBase,
+                mSelectCursorBaseLayerId, mBaseAlpha);
+        animateHandle(canShowExtent, mExtentHandleAlphaAnimator,
+                mSelectCursorExtent, mSelectCursorExtentLayerId,
+                mExtentAlpha);
+    }
+
     private void endSelectingText() {
         mSelectingText = false;
         mShowTextSelectionExtra = false;
-        mHandleAlphaAnimator.setIntValues(0);
-        mHandleAlphaAnimator.start();
+        animateHandles();
     }
 
     private void ensureSelectionHandles() {
@@ -4547,55 +4606,76 @@ public final class WebViewClassic implem
                     com.android.internal.R.drawable.text_select_handle_left).mutate();
             mSelectHandleRight = mContext.getResources().getDrawable(
                     com.android.internal.R.drawable.text_select_handle_right).mutate();
-            mHandleAlpha.setAlpha(mHandleAlpha.getAlpha());
-            mSelectHandleCenterOffset = new Point(0,
-                    -mSelectHandleCenter.getIntrinsicHeight());
-            mSelectHandleLeftOffset = new Point(0,
+            // All handles have the same height, so we can save effort with
+            // this assumption.
+            mSelectOffset = new Point(0,
                     -mSelectHandleLeft.getIntrinsicHeight());
-            mSelectHandleRightOffset = new Point(
-                    -mSelectHandleLeft.getIntrinsicWidth() / 2,
-                    -mSelectHandleRight.getIntrinsicHeight());
         }
     }
 
+    private void drawHandle(Point point, int handleId, Rect bounds,
+            int alpha, Canvas canvas) {
+        int offset;
+        int width;
+        int height;
+        Drawable drawable;
+        boolean isLeft = nativeIsHandleLeft(mNativeClass, handleId);
+        if (isLeft) {
+            drawable = mSelectHandleLeft;
+            width = mSelectHandleLeft.getIntrinsicWidth();
+            height = mSelectHandleLeft.getIntrinsicHeight();
+            // Magic formula copied from TextView
+            offset = (width * 3) / 4;
+        } else {
+            drawable = mSelectHandleRight;
+            width = mSelectHandleRight.getIntrinsicWidth();
+            height = mSelectHandleRight.getIntrinsicHeight();
+            // Magic formula copied from TextView
+            offset = width / 4;
+        }
+        int x = contentToViewDimension(point.x);
+        int y = contentToViewDimension(point.y);
+        bounds.set(x - offset, y, x - offset + width, y + height);
+        drawable.setBounds(bounds);
+        drawable.setAlpha(alpha);
+        drawable.draw(canvas);
+    }
+
     private void drawTextSelectionHandles(Canvas canvas) {
-        if (mHandleAlpha.getAlpha() == 0) {
+        if (mBaseAlpha.getAlpha() == 0 && mExtentAlpha.getAlpha() == 0) {
             return;
         }
         ensureSelectionHandles();
-        if (mSelectingText) {
-            int[] handles = new int[4];
-            getSelectionHandles(handles);
-            int start_x = contentToViewDimension(handles[0]);
-            int start_y = contentToViewDimension(handles[1]);
-            int end_x = contentToViewDimension(handles[2]);
-            int end_y = contentToViewDimension(handles[3]);
-
-            if (mIsCaretSelection) {
-                // Caret handle is centered
-                start_x -= (mSelectHandleCenter.getIntrinsicWidth() / 2);
-                mSelectHandleCenter.setBounds(start_x, start_y,
-                        start_x + mSelectHandleCenter.getIntrinsicWidth(),
-                        start_y + mSelectHandleCenter.getIntrinsicHeight());
-            } else {
-                // Magic formula copied from TextView
-                start_x -= (mSelectHandleLeft.getIntrinsicWidth() * 3) / 4;
-                mSelectHandleLeft.setBounds(start_x, start_y,
-                        start_x + mSelectHandleLeft.getIntrinsicWidth(),
-                        start_y + mSelectHandleLeft.getIntrinsicHeight());
-                end_x -= mSelectHandleRight.getIntrinsicWidth() / 4;
-                mSelectHandleRight.setBounds(end_x, end_y,
-                        end_x + mSelectHandleRight.getIntrinsicWidth(),
-                        end_y + mSelectHandleRight.getIntrinsicHeight());
-            }
-        }
-
         if (mIsCaretSelection) {
+            // Caret handle is centered
+            int x = contentToViewDimension(mSelectCursorBase.x) -
+                    (mSelectHandleCenter.getIntrinsicWidth() / 2);
+            int y = contentToViewDimension(mSelectCursorBase.y);
+            mSelectHandleBaseBounds.set(x, y,
+                    x + mSelectHandleCenter.getIntrinsicWidth(),
+                    y + mSelectHandleCenter.getIntrinsicHeight());
+            mSelectHandleCenter.setBounds(mSelectHandleBaseBounds);
+            mSelectHandleCenter.setAlpha(mBaseAlpha.getAlpha());
             mSelectHandleCenter.draw(canvas);
         } else {
-            mSelectHandleLeft.draw(canvas);
-            mSelectHandleRight.draw(canvas);
+            drawHandle(mSelectCursorBase, HANDLE_ID_BASE,
+                    mSelectHandleBaseBounds, mBaseAlpha.getAlpha(), canvas);
+            drawHandle(mSelectCursorExtent, HANDLE_ID_EXTENT,
+                    mSelectHandleExtentBounds, mExtentAlpha.getAlpha(), canvas);
+        }
+    }
+
+    private boolean isHandleVisible(Point selectionPoint, int layerId) {
+        boolean isVisible = true;
+        if (mIsEditingText) {
+            isVisible = mEditTextContentBounds.contains(selectionPoint.x,
+                    selectionPoint.y);
+        }
+        if (isVisible) {
+            isVisible = nativeIsPointVisible(mNativeClass, layerId,
+                    selectionPoint.x, selectionPoint.y);
         }
+        return isVisible;
     }
 
     /**
@@ -4603,10 +4683,10 @@ public final class WebViewClassic implem
      * startX, startY, endX, endY
      */
     private void getSelectionHandles(int[] handles) {
-        handles[0] = mSelectCursorLeft.x;
-        handles[1] = mSelectCursorLeft.y;
-        handles[2] = mSelectCursorRight.x;
-        handles[3] = mSelectCursorRight.y;
+        handles[0] = mSelectCursorBase.x;
+        handles[1] = mSelectCursorBase.y;
+        handles[2] = mSelectCursorExtent.x;
+        handles[3] = mSelectCursorExtent.y;
     }
 
     // draw history
@@ -4841,6 +4921,43 @@ public final class WebViewClassic implem
     }
 
     /**
+     * Sets use of the Geolocation mock client. Also resets that client. Called
+     * by DRT on UI thread, need to proxy to WebCore thread.
+     *
+     * debug only
+     */
+    public void setUseMockGeolocation() {
+        mWebViewCore.sendMessage(EventHub.SET_USE_MOCK_GEOLOCATION);
+    }
+
+    /**
+     * Called by DRT on WebCore thread.
+     *
+     * debug only
+     */
+    public void setMockGeolocationPosition(double latitude, double longitude, double accuracy) {
+        mWebViewCore.setMockGeolocationPosition(latitude, longitude, accuracy);
+    }
+
+    /**
+     * Called by DRT on WebCore thread.
+     *
+     * debug only
+     */
+    public void setMockGeolocationError(int code, String message) {
+        mWebViewCore.setMockGeolocationError(code, message);
+    }
+
+    /**
+     * Called by DRT on WebCore thread.
+     *
+     * debug only
+     */
+    public void setMockGeolocationPermission(boolean allow) {
+        mWebViewCore.setMockGeolocationPermission(allow);
+    }
+
+    /**
      * Called by DRT on WebCore thread.
      *
      * debug only
@@ -4925,7 +5042,7 @@ public final class WebViewClassic implem
         }
 
         // See if the accessibility injector needs to handle this event.
-        if (isAccessibilityEnabled()
+        if (isAccessibilityInjectionEnabled()
                 && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
             return true;
         }
@@ -5032,7 +5149,7 @@ public final class WebViewClassic implem
         }
 
         // See if the accessibility injector needs to handle this event.
-        if (isAccessibilityEnabled()
+        if (isAccessibilityInjectionEnabled()
                 && getAccessibilityInjector().handleKeyEventIfNecessary(event)) {
             return true;
         }
@@ -5073,9 +5190,9 @@ public final class WebViewClassic implem
         ClipboardManager cm = (ClipboardManager)(mContext
                 .getSystemService(Context.CLIPBOARD_SERVICE));
         if (cm.hasPrimaryClip()) {
-            Point cursorPoint = new Point(contentToViewX(mSelectCursorLeft.x),
-                    contentToViewY(mSelectCursorLeft.y));
-            Point cursorTop = calculateCaretTop();
+            Point cursorPoint = new Point(contentToViewX(mSelectCursorBase.x),
+                    contentToViewY(mSelectCursorBase.y));
+            Point cursorTop = calculateBaseCaretTop();
             cursorTop.set(contentToViewX(cursorTop.x),
                     contentToViewY(cursorTop.y));
 
@@ -5119,17 +5236,22 @@ public final class WebViewClassic implem
         return scale;
     }
 
+    private Point calculateBaseCaretTop() {
+        return calculateCaretTop(mSelectCursorBase, mSelectCursorBaseTextQuad);
+    }
+
+    private Point calculateDraggingCaretTop() {
+        return calculateCaretTop(mSelectDraggingCursor, mSelectDraggingTextQuad);
+    }
+
     /**
      * Assuming arbitrary shape of a quadralateral forming text bounds, this
      * calculates the top of a caret.
      */
-    private Point calculateCaretTop() {
-        float scale = scaleAlongSegment(mSelectCursorLeft.x, mSelectCursorLeft.y,
-                mSelectCursorLeftTextQuad.p4, mSelectCursorLeftTextQuad.p3);
-        int x = Math.round(scaleCoordinate(scale,
-                mSelectCursorLeftTextQuad.p1.x, mSelectCursorLeftTextQuad.p2.x));
-        int y = Math.round(scaleCoordinate(scale,
-                mSelectCursorLeftTextQuad.p1.y, mSelectCursorLeftTextQuad.p2.y));
+    private static Point calculateCaretTop(Point base, QuadF quad) {
+        float scale = scaleAlongSegment(base.x, base.y, quad.p4, quad.p3);
+        int x = Math.round(scaleCoordinate(scale, quad.p1.x, quad.p2.x));
+        int y = Math.round(scaleCoordinate(scale, quad.p1.y, quad.p2.y));
         return new Point(x, y);
     }
 
@@ -5140,50 +5262,12 @@ public final class WebViewClassic implem
     }
 
     private void syncSelectionCursors() {
-        mSelectCursorLeftLayerId =
-                nativeGetHandleLayerId(mNativeClass, HANDLE_ID_LEFT,
-                        mSelectCursorLeft, mSelectCursorLeftTextQuad);
-        mSelectCursorRightLayerId =
-                nativeGetHandleLayerId(mNativeClass, HANDLE_ID_RIGHT,
-                        mSelectCursorRight, mSelectCursorRightTextQuad);
-    }
-
-    private void adjustSelectionCursors() {
-        if (mIsCaretSelection) {
-            syncSelectionCursors();
-            return; // no need to swap left and right handles.
-        }
-
-        boolean wasDraggingLeft = (mSelectDraggingCursor == mSelectCursorLeft);
-        int oldX = mSelectDraggingCursor.x;
-        int oldY = mSelectDraggingCursor.y;
-        int oldLeftX = mSelectCursorLeft.x;
-        int oldLeftY = mSelectCursorLeft.y;
-        int oldRightX = mSelectCursorRight.x;
-        int oldRightY = mSelectCursorRight.y;
-        syncSelectionCursors();
-
-        boolean rightChanged = (oldRightX != mSelectCursorRight.x
-                || oldRightY != mSelectCursorRight.y);
-        boolean leftChanged = (oldLeftX != mSelectCursorLeft.x
-                || oldLeftY != mSelectCursorLeft.y);
-        if (leftChanged && rightChanged) {
-            // Left and right switched places, so swap dragging cursor
-            boolean draggingLeft = !wasDraggingLeft;
-            mSelectDraggingCursor = (draggingLeft
-                    ? mSelectCursorLeft : mSelectCursorRight);
-            mSelectDraggingTextQuad = (draggingLeft
-                    ? mSelectCursorLeftTextQuad : mSelectCursorRightTextQuad);
-            mSelectDraggingOffset = (draggingLeft
-                    ? mSelectHandleLeftOffset : mSelectHandleRightOffset);
-        }
-        mSelectDraggingCursor.set(oldX, oldY);
-    }
-
-    private float distanceSquared(int x, int y, Point p) {
-        float dx = p.x - x;
-        float dy = p.y - y;
-        return (dx * dx) + (dy * dy);
+        mSelectCursorBaseLayerId =
+                nativeGetHandleLayerId(mNativeClass, HANDLE_ID_BASE,
+                        mSelectCursorBase, mSelectCursorBaseTextQuad);
+        mSelectCursorExtentLayerId =
+                nativeGetHandleLayerId(mNativeClass, HANDLE_ID_EXTENT,
+                        mSelectCursorExtent, mSelectCursorExtentTextQuad);
     }
 
     private boolean setupWebkitSelect() {
@@ -5197,19 +5281,20 @@ public final class WebViewClassic implem
         return true;
     }
 
-    private void updateWebkitSelection() {
-        int[] handles = null;
-        if (mIsCaretSelection) {
-            mSelectCursorRight.set(mSelectCursorLeft.x, mSelectCursorLeft.y);
-        }
-        if (mSelectingText) {
-            handles = new int[4];
-            getSelectionHandles(handles);
-        } else {
-            nativeSetTextSelection(mNativeClass, 0);
+    private void updateWebkitSelection(boolean isSnapped) {
+        int handleId = (mSelectDraggingCursor == mSelectCursorBase)
+                ? HANDLE_ID_BASE : HANDLE_ID_EXTENT;
+        int x = mSelectDraggingCursor.x;
+        int y = mSelectDraggingCursor.y;
+        if (isSnapped) {
+            // "center" the cursor in the snapping quad
+            Point top = calculateDraggingCaretTop();
+            x = Math.round((top.x + x) / 2);
+            y = Math.round((top.y + y) / 2);
         }
         mWebViewCore.removeMessages(EventHub.SELECT_TEXT);
-        mWebViewCore.sendMessageAtFrontOfQueue(EventHub.SELECT_TEXT, handles);
+        mWebViewCore.sendMessageAtFrontOfQueue(EventHub.SELECT_TEXT,
+                x, y, (Integer)handleId);
     }
 
     private void resetCaretTimer() {
@@ -5221,14 +5306,6 @@ public final class WebViewClassic implem
     }
 
     /**
-     * See {@link WebView#emulateShiftHeld()}
-     */
-    @Override
-    @Deprecated
-    public void emulateShiftHeld() {
-    }
-
-    /**
      * Select all of the text in this WebView.
      *
      * This is an implementation detail.
@@ -5315,16 +5392,6 @@ public final class WebViewClassic implem
     }
 
     /**
-     * This is an implementation detail.
-     */
-    public SearchBox getSearchBox() {
-        if ((mWebViewCore == null) || (mWebViewCore.getBrowserFrame() == null)) {
-            return null;
-        }
-        return mWebViewCore.getBrowserFrame().getSearchBox();
-    }
-
-    /**
      * Returns the currently highlighted text as a string.
      */
     String getSelection() {
@@ -5336,8 +5403,8 @@ public final class WebViewClassic implem
     public void onAttachedToWindow() {
         if (mWebView.hasWindowFocus()) setActive(true);
 
-        if (isAccessibilityEnabled()) {
-            getAccessibilityInjector().addAccessibilityApisIfNecessary();
+        if (isAccessibilityInjectionEnabled()) {
+            getAccessibilityInjector().toggleAccessibilityFeedback(true);
         }
 
         updateHwAccelerated();
@@ -5349,12 +5416,8 @@ public final class WebViewClassic implem
         mZoomManager.dismissZoomPicker();
         if (mWebView.hasWindowFocus()) setActive(false);
 
-        if (isAccessibilityEnabled()) {
-            getAccessibilityInjector().removeAccessibilityApisIfNecessary();
-        } else {
-            // Ensure the injector is cleared if we're detaching from the window
-            // and accessibility is disabled.
-            mAccessibilityInjector = null;
+        if (isAccessibilityInjectionEnabled()) {
+            getAccessibilityInjector().toggleAccessibilityFeedback(false);
         }
 
         updateHwAccelerated();
@@ -5569,24 +5632,24 @@ public final class WebViewClassic implem
                 Math.max(0, mEditTextContentBounds.top - buffer),
                 mEditTextContentBounds.right + buffer,
                 mEditTextContentBounds.bottom + buffer);
-        Point caretTop = calculateCaretTop();
+        Point caretTop = calculateBaseCaretTop();
         if (visibleRect.width() < mEditTextContentBounds.width()) {
             // The whole edit won't fit in the width, so use the caret rect
-            if (mSelectCursorLeft.x < caretTop.x) {
-                showRect.left = Math.max(0, mSelectCursorLeft.x - buffer);
+            if (mSelectCursorBase.x < caretTop.x) {
+                showRect.left = Math.max(0, mSelectCursorBase.x - buffer);
                 showRect.right = caretTop.x + buffer;
             } else {
                 showRect.left = Math.max(0, caretTop.x - buffer);
-                showRect.right = mSelectCursorLeft.x + buffer;
+                showRect.right = mSelectCursorBase.x + buffer;
             }
         }
         if (visibleRect.height() < mEditTextContentBounds.height()) {
             // The whole edit won't fit in the height, so use the caret rect
-            if (mSelectCursorLeft.y > caretTop.y) {
+            if (mSelectCursorBase.y > caretTop.y) {
                 showRect.top = Math.max(0, caretTop.y - buffer);
-                showRect.bottom = mSelectCursorLeft.y + buffer;
+                showRect.bottom = mSelectCursorBase.y + buffer;
             } else {
-                showRect.top = Math.max(0, mSelectCursorLeft.y - buffer);
+                showRect.top = Math.max(0, mSelectCursorBase.y - buffer);
                 showRect.bottom = caretTop.y + buffer;
             }
         }
@@ -5851,28 +5914,19 @@ public final class WebViewClassic implem
                         ensureSelectionHandles();
                         int shiftedY = y - getTitleHeight() + getScrollY();
                         int shiftedX = x + getScrollX();
-                        if (mSelectHandleCenter != null && mSelectHandleCenter.getBounds()
-                                .contains(shiftedX, shiftedY)) {
+                        if (mSelectHandleBaseBounds.contains(shiftedX, shiftedY)) {
                             mSelectionStarted = true;
-                            mSelectDraggingCursor = mSelectCursorLeft;
-                            mSelectDraggingOffset = mSelectHandleCenterOffset;
-                            mSelectDraggingTextQuad = mSelectCursorLeftTextQuad;
-                            mPrivateHandler.removeMessages(CLEAR_CARET_HANDLE);
-                            hidePasteButton();
-                        } else if (mSelectHandleLeft != null
-                                && mSelectHandleLeft.getBounds()
-                                    .contains(shiftedX, shiftedY)) {
-                            mSelectionStarted = true;
-                            mSelectDraggingOffset = mSelectHandleLeftOffset;
-                            mSelectDraggingCursor = mSelectCursorLeft;
-                            mSelectDraggingTextQuad = mSelectCursorLeftTextQuad;
-                        } else if (mSelectHandleRight != null
-                                && mSelectHandleRight.getBounds()
+                            mSelectDraggingCursor = mSelectCursorBase;
+                            mSelectDraggingTextQuad = mSelectCursorBaseTextQuad;
+                            if (mIsCaretSelection) {
+                                mPrivateHandler.removeMessages(CLEAR_CARET_HANDLE);
+                                hidePasteButton();
+                            }
+                        } else if (mSelectHandleExtentBounds
                                 .contains(shiftedX, shiftedY)) {
                             mSelectionStarted = true;
-                            mSelectDraggingOffset = mSelectHandleRightOffset;
-                            mSelectDraggingCursor = mSelectCursorRight;
-                            mSelectDraggingTextQuad = mSelectCursorRightTextQuad;
+                            mSelectDraggingCursor = mSelectCursorExtent;
+                            mSelectDraggingTextQuad = mSelectCursorExtentTextQuad;
                         } else if (mIsCaretSelection) {
                             selectionDone();
                         }
@@ -5917,9 +5971,9 @@ public final class WebViewClassic implem
                     }
                     if (deltaX != 0 || deltaY != 0) {
                         int handleX = contentX +
-                                viewToContentDimension(mSelectDraggingOffset.x);
+                                viewToContentDimension(mSelectOffset.x);
                         int handleY = contentY +
-                                viewToContentDimension(mSelectDraggingOffset.y);
+                                viewToContentDimension(mSelectOffset.y);
                         mSelectDraggingCursor.set(handleX, handleY);
                         boolean inCursorText =
                                 mSelectDraggingTextQuad.containsPoint(handleX, handleY);
@@ -5930,10 +5984,12 @@ public final class WebViewClassic implem
                         } else {
                             endScrollEdit();
                         }
+                        boolean snapped = false;
                         if (inCursorText || (mIsEditingText && !inEditBounds)) {
                             snapDraggingCursor();
+                            snapped = true;
                         }
-                        updateWebkitSelection();
+                        updateWebkitSelection(snapped);
                         if (!inCursorText && mIsEditingText && inEditBounds) {
                             // Visually snap even if we have moved the handle.
                             snapDraggingCursor();
@@ -6056,12 +6112,15 @@ public final class WebViewClassic implem
                 break;
             }
             case MotionEvent.ACTION_UP: {
-                endScrollEdit();
-                if (!mConfirmMove && mIsEditingText && mSelectionStarted &&
-                        mIsCaretSelection) {
-                    showPasteWindow();
-                    stopTouch();
-                    break;
+                if (mIsEditingText && mSelectionStarted) {
+                    endScrollEdit();
+                    mPrivateHandler.sendEmptyMessageDelayed(SCROLL_HANDLE_INTO_VIEW,
+                            TEXT_SCROLL_FIRST_SCROLL_MS);
+                    if (!mConfirmMove && mIsCaretSelection) {
+                        showPasteWindow();
+                        stopTouch();
+                        break;
+                    }
                 }
                 mLastTouchUpTime = eventTime;
                 if (mSentAutoScrollMessage) {
@@ -6168,6 +6227,10 @@ public final class WebViewClassic implem
         }
     }
 
+    private static int getSelectionCoordinate(int coordinate, int min, int max) {
+        return Math.max(Math.min(coordinate, max), min);
+    }
+
     private void beginScrollEdit() {
         if (mLastEditScroll == 0) {
             mLastEditScroll = SystemClock.uptimeMillis() -
@@ -6176,10 +6239,37 @@ public final class WebViewClassic implem
         }
     }
 
+    private void scrollDraggedSelectionHandleIntoView() {
+        if (mSelectDraggingCursor == null) {
+            return;
+        }
+        int x = mSelectDraggingCursor.x;
+        int y = mSelectDraggingCursor.y;
+        if (!mEditTextContentBounds.contains(x,y)) {
+            int left = Math.min(0, x - mEditTextContentBounds.left - EDIT_RECT_BUFFER);
+            int right = Math.max(0, x - mEditTextContentBounds.right + EDIT_RECT_BUFFER);
+            int deltaX = left + right;
+            int above = Math.min(0, y - mEditTextContentBounds.top - EDIT_RECT_BUFFER);
+            int below = Math.max(0, y - mEditTextContentBounds.bottom + EDIT_RECT_BUFFER);
+            int deltaY = above + below;
+            if (deltaX != 0 || deltaY != 0) {
+                int scrollX = getTextScrollX() + deltaX;
+                int scrollY = getTextScrollY() + deltaY;
+                scrollX = clampBetween(scrollX, 0, getMaxTextScrollX());
+                scrollY = clampBetween(scrollY, 0, getMaxTextScrollY());
+                scrollEditText(scrollX, scrollY);
+            }
+        }
+    }
+
     private void endScrollEdit() {
         mLastEditScroll = 0;
     }
 
+    private static int clampBetween(int value, int min, int max) {
+        return Math.max(min, Math.min(value, max));
+    }
+
     private static int getTextScrollDelta(float speed, long deltaT) {
         float distance = speed * deltaT;
         int intDistance = (int)Math.floor(distance);
@@ -6195,10 +6285,10 @@ public final class WebViewClassic implem
      */
     private void scrollEditWithCursor() {
         if (mLastEditScroll != 0) {
-            int x = viewToContentX(mLastTouchX + getScrollX() + mSelectDraggingOffset.x);
+            int x = viewToContentX(mLastTouchX + getScrollX() + mSelectOffset.x);
             float scrollSpeedX = getTextScrollSpeed(x, mEditTextContentBounds.left,
                     mEditTextContentBounds.right);
-            int y = viewToContentY(mLastTouchY + getScrollY() + mSelectDraggingOffset.y);
+            int y = viewToContentY(mLastTouchY + getScrollY() + mSelectOffset.y);
             float scrollSpeedY = getTextScrollSpeed(y, mEditTextContentBounds.top,
                     mEditTextContentBounds.bottom);
             if (scrollSpeedX == 0.0f && scrollSpeedY == 0.0f) {
@@ -6208,24 +6298,27 @@ public final class WebViewClassic implem
                 long timeSinceLastUpdate = currentTime - mLastEditScroll;
                 int deltaX = getTextScrollDelta(scrollSpeedX, timeSinceLastUpdate);
                 int deltaY = getTextScrollDelta(scrollSpeedY, timeSinceLastUpdate);
+                int scrollX = getTextScrollX() + deltaX;
+                scrollX = clampBetween(scrollX, 0, getMaxTextScrollX());
+                int scrollY = getTextScrollY() + deltaY;
+                scrollY = clampBetween(scrollY, 0, getMaxTextScrollY());
+
                 mLastEditScroll = currentTime;
-                if (deltaX == 0 && deltaY == 0) {
+                if (scrollX == getTextScrollX() && scrollY == getTextScrollY()) {
                     // By probability no text scroll this time. Try again later.
                     mPrivateHandler.sendEmptyMessageDelayed(SCROLL_EDIT_TEXT,
                             TEXT_SCROLL_FIRST_SCROLL_MS);
                 } else {
-                    int scrollX = getTextScrollX() + deltaX;
-                    scrollX = Math.min(getMaxTextScrollX(), scrollX);
-                    scrollX = Math.max(0, scrollX);
-                    int scrollY = getTextScrollY() + deltaY;
-                    scrollY = Math.min(getMaxTextScrollY(), scrollY);
-                    scrollY = Math.max(0, scrollY);
+                    int selectionX = getSelectionCoordinate(x,
+                            mEditTextContentBounds.left, mEditTextContentBounds.right);
+                    int selectionY = getSelectionCoordinate(y,
+                            mEditTextContentBounds.top, mEditTextContentBounds.bottom);
+                    int oldX = mSelectDraggingCursor.x;
+                    int oldY = mSelectDraggingCursor.y;
+                    mSelectDraggingCursor.set(selectionX, selectionY);
+                    updateWebkitSelection(false);
                     scrollEditText(scrollX, scrollY);
-                    int cursorX = mSelectDraggingCursor.x;
-                    int cursorY = mSelectDraggingCursor.y;
-                    mSelectDraggingCursor.set(x - deltaX, y - deltaY);
-                    updateWebkitSelection();
-                    mSelectDraggingCursor.set(cursorX, cursorY);
+                    mSelectDraggingCursor.set(oldX, oldY);
                 }
             }
         }
@@ -6281,10 +6374,10 @@ public final class WebViewClassic implem
                 // scrolling.  The rectangle is in document coordinates.
                 final int maxX = mScrollingLayerRect.right;
                 final int maxY = mScrollingLayerRect.bottom;
-                final int resultX = Math.max(0,
-                        Math.min(mScrollingLayerRect.left + contentX, maxX));
-                final int resultY = Math.max(0,
-                        Math.min(mScrollingLayerRect.top + contentY, maxY));
+                final int resultX = clampBetween(maxX, 0,
+                        mScrollingLayerRect.left + contentX);
+                final int resultY = clampBetween(maxY, 0,
+                        mScrollingLayerRect.top + contentY);
 
                 if (resultX != mScrollingLayerRect.left
                         || resultY != mScrollingLayerRect.top
@@ -6385,10 +6478,10 @@ public final class WebViewClassic implem
         int x = Math.round(newX);
         int y = Math.round(newY);
         if (mIsEditingText) {
-            x = Math.max(mEditTextContentBounds.left,
-                    Math.min(mEditTextContentBounds.right, x));
-            y = Math.max(mEditTextContentBounds.top,
-                    Math.min(mEditTextContentBounds.bottom, y));
+            x = clampBetween(x, mEditTextContentBounds.left,
+                    mEditTextContentBounds.right);
+            y = clampBetween(y, mEditTextContentBounds.top,
+                    mEditTextContentBounds.bottom);
         }
         mSelectDraggingCursor.set(x, y);
     }
@@ -6417,9 +6510,13 @@ public final class WebViewClassic implem
                                 mWebViewPrivate.getVerticalScrollFactor());
                         final int hdelta = (int) (hscroll *
                                 mWebViewPrivate.getHorizontalScrollFactor());
-                        if (pinScrollBy(hdelta, vdelta, false, 0)) {
-                            return true;
-                        }
+
+                        abortAnimation();
+                        int oldTouchMode = mTouchMode;
+                        startScrollingLayer(event.getX(), event.getY());
+                        doDrag(hdelta, vdelta);
+                        mTouchMode = oldTouchMode;
+                        return true;
                     }
                 }
             }
@@ -6451,9 +6548,12 @@ public final class WebViewClassic implem
     private long mTrackballUpTime = 0;
     private long mLastCursorTime = 0;
     private Rect mLastCursorBounds;
-    private SelectionHandleAlpha mHandleAlpha = new SelectionHandleAlpha();
-    private ObjectAnimator mHandleAlphaAnimator =
-            ObjectAnimator.ofInt(mHandleAlpha, "alpha", 0);
+    private SelectionHandleAlpha mBaseAlpha = new SelectionHandleAlpha();
+    private SelectionHandleAlpha mExtentAlpha = new SelectionHandleAlpha();
+    private ObjectAnimator mBaseHandleAlphaAnimator =
+            ObjectAnimator.ofInt(mBaseAlpha, "alpha", 0);
+    private ObjectAnimator mExtentHandleAlphaAnimator =
+            ObjectAnimator.ofInt(mExtentAlpha, "alpha", 0);
 
     // Set by default; BrowserActivity clears to interpret trackball data
     // directly for movement. Currently, the framework only passes
@@ -6463,6 +6563,7 @@ public final class WebViewClassic implem
     private DrawData mDelaySetPicture;
     private DrawData mLoadedPicture;
 
+    @Override
     public void setMapTrackballToArrowKeys(boolean setMap) {
         mMapTrackballToArrowKeys = setMap;
     }
@@ -6689,6 +6790,7 @@ public final class WebViewClassic implem
         }
     }
 
+    @Override
     public void flingScroll(int vx, int vy) {
         mScroller.fling(getScrollX(), getScrollY(), vx, vy, 0, computeMaxScrollX(), 0,
                 computeMaxScrollY(), mOverflingDistance, mOverflingDistance);
@@ -6941,6 +7043,8 @@ public final class WebViewClassic implem
 
     @Override
     public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
+        // Check if we are destroyed
+        if (mWebViewCore == null) return false;
         // FIXME: If a subwindow is showing find, and the user touches the
         // background window, it can steal focus.
         if (mFindIsUp) return false;
@@ -7250,11 +7354,7 @@ public final class WebViewClassic implem
                     // nativeCreate sets mNativeClass to a non-zero value
                     String drawableDir = BrowserFrame.getRawResFilename(
                             BrowserFrame.DRAWABLEDIR, mContext);
-                    WindowManager windowManager =
-                            (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
-                    Display display = windowManager.getDefaultDisplay();
-                    nativeCreate(msg.arg1, drawableDir,
-                            ActivityManager.isHighEndGfx(display));
+                    nativeCreate(msg.arg1, drawableDir, ActivityManager.isHighEndGfx());
                     if (mDelaySetPicture != null) {
                         setNewPicture(mDelaySetPicture, true);
                         mDelaySetPicture = null;
@@ -7340,18 +7440,9 @@ public final class WebViewClassic implem
                     mWebView.setKeepScreenOn(msg.arg1 == 1);
                     break;
 
-                case ENTER_FULLSCREEN_VIDEO:
-                    int layerId = msg.arg1;
-
-                    String url = (String) msg.obj;
-                    if (mHTML5VideoViewManager != null) {
-                        mHTML5VideoViewManager.enterFullscreenVideo(layerId, url);
-                    }
-                    break;
-
                 case EXIT_FULLSCREEN_VIDEO:
-                    if (mHTML5VideoViewManager != null) {
-                        mHTML5VideoViewManager.exitFullscreenVideo();
+                    if (mHTML5VideoViewProxy != null) {
+                        mHTML5VideoViewProxy.exitFullScreenVideo();
                     }
                     break;
 
@@ -7428,7 +7519,7 @@ public final class WebViewClassic implem
                     break;
 
                 case SELECTION_STRING_CHANGED:
-                    if (isAccessibilityEnabled()) {
+                    if (isAccessibilityInjectionEnabled()) {
                         getAccessibilityInjector()
                                 .handleSelectionChangedIfNecessary((String) msg.obj);
                     }
@@ -7487,7 +7578,7 @@ public final class WebViewClassic implem
                         mEditTextLayerId = initData.mNodeLayerId;
                         nativeMapLayerRect(mNativeClass, mEditTextLayerId,
                                 mEditTextContentBounds);
-                        mEditTextContent.set(initData.mContentRect);
+                        mEditTextContent.set(initData.mClientRect);
                         relocateAutoCompletePopup();
                     }
                     break;
@@ -7568,6 +7659,10 @@ public final class WebViewClassic implem
                     scrollEditWithCursor();
                     break;
 
+                case SCROLL_HANDLE_INTO_VIEW:
+                    scrollDraggedSelectionHandleIntoView();
+                    break;
+
                 default:
                     super.handleMessage(msg);
                     break;
@@ -7603,8 +7698,8 @@ public final class WebViewClassic implem
                         .contains(x, y);
             } else {
                 isPressingHandle =
-                        mSelectHandleLeft.getBounds().contains(x, y)
-                        || mSelectHandleRight.getBounds().contains(x, y);
+                        mSelectHandleBaseBounds.contains(x, y)
+                        || mSelectHandleExtentBounds.contains(x, y);
             }
             return isPressingHandle;
         }
@@ -7892,7 +7987,9 @@ public final class WebViewClassic implem
         int functor = 0;
         boolean forceInval = isPictureAfterFirstLayout;
         ViewRootImpl viewRoot = mWebView.getViewRootImpl();
-        if (mWebView.isHardwareAccelerated() && viewRoot != null) {
+        if (mWebView.isHardwareAccelerated()
+                && mWebView.getLayerType() != View.LAYER_TYPE_SOFTWARE
+                && viewRoot != null) {
             functor = nativeGetDrawGLFunction(mNativeClass);
             if (functor != 0) {
                 // force an invalidate if functor attach not successful
@@ -7951,8 +8048,10 @@ public final class WebViewClassic implem
 
         if (data.mSelectTextPtr != 0 &&
                 (data.mStart != data.mEnd ||
-                (mFieldPointer == nodePointer && mFieldPointer != 0))) {
-            mIsCaretSelection = (data.mStart == data.mEnd);
+                (mFieldPointer == nodePointer && mFieldPointer != 0) ||
+                (nodePointer == 0 && data.mStart == 0 && data.mEnd == 0))) {
+            mIsEditingText = (mFieldPointer == nodePointer) && nodePointer != 0;
+            mIsCaretSelection = (data.mStart == data.mEnd && nodePointer != 0);
             if (mIsCaretSelection &&
                     (mInputConnection == null ||
                     mInputConnection.getEditable().length() == 0)) {
@@ -7961,14 +8060,10 @@ public final class WebViewClassic implem
             } else {
                 if (!mSelectingText) {
                     setupWebkitSelect();
-                } else if (!mSelectionStarted) {
-                    syncSelectionCursors();
                 } else {
-                    adjustSelectionCursors();
-                    if (mSelectCallback != null) {
-                        mSelectCallback.setOpenUrlVisibility();
-                    }
+                    syncSelectionCursors();
                 }
+                animateHandles();
                 if (mIsCaretSelection) {
                     resetCaretTimer();
                 }
@@ -7984,8 +8079,10 @@ public final class WebViewClassic implem
         float maxScrollX = getMaxTextScrollX();
         float scrollPercentX = ((float)scrollX)/maxScrollX;
         mEditTextContent.offsetTo(-scrollX, -scrollY);
-        mWebViewCore.sendMessageAtFrontOfQueue(EventHub.SCROLL_TEXT_INPUT, 0,
+        mWebViewCore.removeMessages(EventHub.SCROLL_TEXT_INPUT);
+        mWebViewCore.sendMessage(EventHub.SCROLL_TEXT_INPUT, 0,
                 scrollY, (Float)scrollPercentX);
+        animateHandles();
     }
 
     private void beginTextBatch() {
@@ -8430,33 +8527,12 @@ public final class WebViewClassic implem
     }
 
     /**
-     * See {@link WebView#debugDump()}
-     */
-    @Override
-    @Deprecated
-    public void debugDump() {
-    }
-
-    /**
      * Enable the communication b/t the webView and VideoViewProxy
      *
      * only used by the Browser
      */
-    public void registerHTML5VideoViewProxy(HTML5VideoViewProxy proxy) {
-        if (mHTML5VideoViewManager == null)
-            mHTML5VideoViewManager = new HTML5VideoViewManager(this);
-        mHTML5VideoViewManager.registerProxy(proxy);
-    }
-
-    /**
-     * Clean up method for registerHTML5VideoViewProxy
-     *
-     * @hide only used by the Browser
-     */
-    public void unregisterHTML5VideoViewProxy(HTML5VideoViewProxy proxy) {
-        if (mHTML5VideoViewManager != null) {
-            mHTML5VideoViewManager.unregisterProxy(proxy);
-        }
+    public void setHTML5VideoViewProxy(HTML5VideoViewProxy proxy) {
+        mHTML5VideoViewProxy = proxy;
     }
 
     /**
@@ -8584,6 +8660,54 @@ public final class WebViewClassic implem
         WebViewCore.setShouldMonitorWebCoreThread();
     }
 
+    @Override
+    public void dumpViewHierarchyWithProperties(BufferedWriter out, int level) {
+        int layer = getBaseLayer();
+        if (layer != 0) {
+            try {
+                ByteArrayOutputStream stream = new ByteArrayOutputStream();
+                ViewStateSerializer.dumpLayerHierarchy(layer, stream, level);
+                stream.close();
+                byte[] buf = stream.toByteArray();
+                out.write(new String(buf, "ascii"));
+            } catch (IOException e) {}
+        }
+    }
+
+    @Override
+    public View findHierarchyView(String className, int hashCode) {
+        if (mNativeClass == 0) return null;
+        Picture pic = new Picture();
+        if (!nativeDumpLayerContentToPicture(mNativeClass, className, hashCode, pic)) {
+            return null;
+        }
+        return new PictureWrapperView(getContext(), pic, mWebView);
+    }
+
+    private static class PictureWrapperView extends View {
+        Picture mPicture;
+        WebView mWebView;
+
+        public PictureWrapperView(Context context, Picture picture, WebView parent) {
+            super(context);
+            mPicture = picture;
+            mWebView = parent;
+            setWillNotDraw(false);
+            setRight(mPicture.getWidth());
+            setBottom(mPicture.getHeight());
+        }
+
+        @Override
+        protected void onDraw(Canvas canvas) {
+            canvas.drawPicture(mPicture);
+        }
+
+        @Override
+        public boolean post(Runnable action) {
+            return mWebView.post(action);
+        }
+    }
+
     private native void     nativeCreate(int ptr, String drawableDir, boolean isHighEndGfx);
     private native void     nativeDebugDump();
     private static native void nativeDestroy(int ptr);
@@ -8604,6 +8728,8 @@ public final class WebViewClassic implem
             int scrollingLayer);
     private native int      nativeGetBaseLayer(int nativeInstance);
     private native void     nativeCopyBaseContentToPicture(Picture pict);
+    private native boolean     nativeDumpLayerContentToPicture(int nativeInstance,
+            String className, int layerId, Picture pict);
     private native boolean  nativeHasContent();
     private native void     nativeStopGL(int ptr);
     private native void     nativeDiscardAllTextures();
@@ -8647,4 +8773,7 @@ public final class WebViewClassic implem
     private static native int nativeSetHwAccelerated(int instance, boolean hwAccelerated);
     private static native void nativeFindMaxVisibleRect(int instance, int layerId,
             Rect visibleContentRect);
+    private static native boolean nativeIsHandleLeft(int instance, int handleId);
+    private static native boolean nativeIsPointVisible(int instance,
+            int layerId, int contentX, int contentY);
 }
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewClientClassicExt.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewClientClassicExt.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewClientClassicExt.java	1970-01-01 01:00:00.000000000 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewClientClassicExt.java	2013-03-12 17:03:37.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.webkit;
+
+import android.net.http.SslError;
+
+/**
+ * Adds WebViewClassic specific extension methods to the WebViewClient callback class.
+ * These are not part of the public WebView API, so the class is hidden.
+ * @hide
+ */
+public class WebViewClientClassicExt extends WebViewClient {
+
+    /**
+     * Notify the host application that an SSL error occurred while loading a
+     * resource, but the WebView chose to proceed anyway based on a
+     * decision retained from a previous response to onReceivedSslError().
+     */
+    public void onProceededAfterSslError(WebView view, SslError error) {
+    }
+
+    /**
+     * Notify the host application to handle a SSL client certificate
+     * request (display the request to the user and ask whether to
+     * proceed with a client certificate or not). The host application
+     * has to call either handler.cancel() or handler.proceed() as the
+     * connection is suspended and waiting for the response. The
+     * default behavior is to cancel, returning no client certificate.
+     *
+     * @param view The WebView that is initiating the callback.
+     * @param handler A ClientCertRequestHandler object that will
+     *            handle the user's response.
+     * @param host_and_port The host and port of the requesting server.
+     */
+    public void onReceivedClientCertRequest(WebView view,
+            ClientCertRequestHandler handler, String host_and_port) {
+        handler.cancel();
+    }
+}
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewClient.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewClient.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewClient.java	2013-03-12 17:09:11.262011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewClient.java	2013-03-12 17:03:37.000000000 +0100
@@ -204,43 +204,16 @@ public class WebViewClient {
     }
 
     /**
-     * Notify the host application that an SSL error occurred while loading a
-     * resource, but the WebView chose to proceed anyway based on a
-     * decision retained from a previous response to onReceivedSslError().
-     * @hide
-     */
-    public void onProceededAfterSslError(WebView view, SslError error) {
-    }
-
-    /**
-     * Notify the host application to handle a SSL client certificate
-     * request (display the request to the user and ask whether to
-     * proceed with a client certificate or not). The host application
-     * has to call either handler.cancel() or handler.proceed() as the
-     * connection is suspended and waiting for the response. The
-     * default behavior is to cancel, returning no client certificate.
-     *
-     * @param view The WebView that is initiating the callback.
-     * @param handler A ClientCertRequestHandler object that will
-     *            handle the user's response.
-     * @param host_and_port The host and port of the requesting server.
-     *
-     * @hide
-     */
-    public void onReceivedClientCertRequest(WebView view,
-            ClientCertRequestHandler handler, String host_and_port) {
-        handler.cancel();
-    }
-
-    /**
-     * Notify the host application to handle an authentication request. The
-     * default behavior is to cancel the request.
+     * Notifies the host application that the WebView received an HTTP
+     * authentication request. The host application can use the supplied
+     * {@link HttpAuthHandler} to set the WebView's response to the request.
+     * The default behavior is to cancel the request.
      *
-     * @param view The WebView that is initiating the callback.
-     * @param handler The HttpAuthHandler that will handle the user's response.
-     * @param host The host requiring authentication.
-     * @param realm A description to help store user credentials for future
-     *            visits.
+     * @param view the WebView that is initiating the callback
+     * @param handler the HttpAuthHandler used to set the WebView's response
+     * @param host the host requiring authentication
+     * @param realm the realm for which authentication is required
+     * @see Webview#getHttpAuthUsernamePassword
      */
     public void onReceivedHttpAuthRequest(WebView view,
             HttpAuthHandler handler, String host, String realm) {
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewCore.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewCore.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewCore.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewCore.java	2013-03-12 17:03:37.000000000 +0100
@@ -132,6 +132,8 @@ public final class WebViewCore {
     private int mRestoredX = 0;
     private int mRestoredY = 0;
 
+    private MockGeolocation mMockGeolocation = new MockGeolocation(this);
+
     private DeviceMotionAndOrientationManager mDeviceMotionAndOrientationManager =
             new DeviceMotionAndOrientationManager(this);
     private DeviceMotionService mDeviceMotionService;
@@ -441,7 +443,7 @@ public final class WebViewCore {
     }
 
     /**
-     * Notify the browser that the origin has exceeded it's database quota.
+     * Notify the embedding application that the origin has exceeded it's database quota.
      * @param url The URL that caused the overflow.
      * @param databaseIdentifier The identifier of the database.
      * @param quota The current quota for the origin.
@@ -466,12 +468,15 @@ public final class WebViewCore {
     }
 
     /**
-     * Notify the browser that the appcache has exceeded its max size.
+     * Notify the embedding application that the appcache has reached or exceeded its maximum
+     * allowed storage size.
+     *
      * @param requiredStorage is the amount of storage, in bytes, that would be
      * needed in order for the last appcache operation to succeed.
+     * @param maxSize maximum allowed Application Cache database size, in bytes.
      */
-    protected void reachedMaxAppCacheSize(long requiredStorage) {
-        mCallbackProxy.onReachedMaxAppCacheSize(requiredStorage, getUsedQuota(),
+    protected void reachedMaxAppCacheSize(long requiredStorage, long maxSize) {
+        mCallbackProxy.onReachedMaxAppCacheSize(requiredStorage, maxSize,
                 new WebStorage.QuotaUpdater() {
                     @Override
                     public void updateQuota(long newQuota) {
@@ -560,24 +565,6 @@ public final class WebViewCore {
     }
 
     /**
-     * Notify the webview that this is an installable web app.
-     */
-    protected void setInstallableWebApp() {
-        mCallbackProxy.setInstallableWebApp();
-    }
-
-    /**
-     * Notify the webview that we want to display the video layer fullscreen.
-     */
-    protected void enterFullscreenForVideoLayer(int layerId, String url) {
-        if (mWebViewClassic == null) return;
-        Message message = Message.obtain(mWebViewClassic.mPrivateHandler,
-                       WebViewClassic.ENTER_FULLSCREEN_VIDEO, layerId, 0);
-        message.obj = url;
-        message.sendToTarget();
-    }
-
-    /**
      * Notify the webview that we want to exit the video fullscreen.
      * This is called through JNI by webcore.
      */
@@ -619,8 +606,6 @@ public final class WebViewCore {
      */
     private native void nativeNotifyAnimationStarted(int nativeClass);
 
-    private native boolean nativeFocusBoundsChanged(int nativeClass);
-
     private native boolean nativeKey(int nativeClass, int keyCode,
             int unichar, int repeatCount, boolean isShift, boolean isAlt,
             boolean isSym, boolean isDown);
@@ -773,7 +758,7 @@ public final class WebViewCore {
                                 break;
 
                             case REDUCE_PRIORITY:
-                                // 3 is an adjustable number.
+                                // 10 is an adjustable number.
                                 Process.setThreadPriority(
                                         Process.THREAD_PRIORITY_DEFAULT + 10 *
                                         Process.THREAD_PRIORITY_LESS_FAVORABLE);
@@ -839,6 +824,7 @@ public final class WebViewCore {
     static class JSInterfaceData {
         Object mObject;
         String mInterfaceName;
+        boolean mRequireAnnotation;
     }
 
     static class JSKeyData {
@@ -960,7 +946,7 @@ public final class WebViewCore {
         public int mMaxLength;
         public Rect mContentBounds;
         public int mNodeLayerId;
-        public Rect mContentRect;
+        public Rect mClientRect;
     }
 
     // mAction of TouchEventData can be MotionEvent.getAction() which uses the
@@ -1199,6 +1185,7 @@ public final class WebViewCore {
         static final int SET_INITIAL_FOCUS = 224;
 
         static final int SAVE_VIEW_STATE = 225;
+        static final int SET_USE_MOCK_GEOLOCATION = 226;
 
         // Private handler for WebCore messages.
         private Handler mHandler;
@@ -1291,6 +1278,7 @@ public final class WebViewCore {
                                 mBrowserFrame = null;
                                 mSettings.onDestroyed();
                                 mNativeClass = 0;
+                                WebCoreThreadWatchdog.unregisterWebView(mWebViewClassic);
                                 mWebViewClassic = null;
                             }
                             break;
@@ -1306,13 +1294,8 @@ public final class WebViewCore {
                             } else {
                                 xPercent = ((Float) msg.obj).floatValue();
                             }
-                            Rect contentBounds = new Rect();
                             nativeScrollFocusedTextInput(mNativeClass, xPercent,
-                                    msg.arg2, contentBounds);
-                            Message.obtain(
-                                    mWebViewClassic.mPrivateHandler,
-                                    WebViewClassic.UPDATE_CONTENT_BOUNDS,
-                                    contentBounds).sendToTarget();
+                                    msg.arg2);
                             break;
 
                         case LOAD_URL: {
@@ -1508,7 +1491,7 @@ public final class WebViewCore {
                         case ADD_JS_INTERFACE:
                             JSInterfaceData jsData = (JSInterfaceData) msg.obj;
                             mBrowserFrame.addJavascriptInterface(jsData.mObject,
-                                    jsData.mInterfaceName);
+                                    jsData.mInterfaceName, jsData.mRequireAnnotation);
                             break;
 
                         case REMOVE_JS_INTERFACE:
@@ -1660,6 +1643,10 @@ public final class WebViewCore {
                                     (Set<String>) msg.obj);
                             break;
 
+                        case SET_USE_MOCK_GEOLOCATION:
+                            setUseMockGeolocation();
+                            break;
+
                         case SET_USE_MOCK_DEVICE_ORIENTATION:
                             setUseMockDeviceOrientation();
                             break;
@@ -1708,13 +1695,9 @@ public final class WebViewCore {
                             nativeInsertText(mNativeClass, (String) msg.obj);
                             break;
                         case SELECT_TEXT: {
-                            int[] args = (int[]) msg.obj;
-                            if (args == null) {
-                                nativeClearTextSelection(mNativeClass);
-                            } else {
-                                nativeSelectText(mNativeClass, args[0],
-                                        args[1], args[2], args[3]);
-                            }
+                            int handleId = (Integer) msg.obj;
+                            nativeSelectText(mNativeClass, handleId,
+                                    msg.arg1, msg.arg2);
                             break;
                         }
                         case SELECT_WORD_AT: {
@@ -2000,7 +1983,6 @@ public final class WebViewCore {
             mEventHub.sendMessageAtFrontOfQueue(
                     Message.obtain(null, EventHub.DESTROY));
             mEventHub.blockMessages();
-            WebCoreThreadWatchdog.unregisterWebView(mWebViewClassic);
         }
     }
 
@@ -2139,8 +2121,8 @@ public final class WebViewCore {
         return width;
     }
 
-    // Utility method for exceededDatabaseQuota and reachedMaxAppCacheSize
-    // callbacks. Computes the sum of database quota for all origins.
+    // Utility method for exceededDatabaseQuota callback. Computes the sum
+    // of WebSQL database quota for all origins.
     private long getUsedQuota() {
         WebStorageClassic webStorage = WebStorageClassic.getInstance();
         Collection<WebStorage.Origin> origins = webStorage.getOriginsSync();
@@ -2192,7 +2174,6 @@ public final class WebViewCore {
         // only non-null if it is for the first picture set after the first layout
         ViewState mViewState;
         boolean mFirstLayoutForNonStandardLoad;
-        boolean mFocusSizeChanged;
     }
 
     DrawData mLastDrawData = null;
@@ -2247,7 +2228,6 @@ public final class WebViewCore {
 
     private void webkitDraw(DrawData draw) {
         if (mWebViewClassic != null) {
-            draw.mFocusSizeChanged = nativeFocusBoundsChanged(mNativeClass);
             draw.mViewSize = new Point(mCurrentViewWidth, mCurrentViewHeight);
             if (mSettings.getUseWideViewPort()) {
                 draw.mMinPrefWidth = Math.max(
@@ -2330,7 +2310,6 @@ public final class WebViewCore {
                     Log.w(LOGTAG, "Cannot pauseUpdatePicture, core destroyed or not initialized!");
                     return;
                 }
-                core.nativeSetIsPaused(core.mNativeClass, true);
                 core.mDrawIsPaused = true;
             }
         }
@@ -2348,7 +2327,6 @@ public final class WebViewCore {
                     Log.w(LOGTAG, "Cannot resumeUpdatePicture, core destroyed!");
                     return;
                 }
-                core.nativeSetIsPaused(core.mNativeClass, false);
                 core.mDrawIsPaused = false;
                 // always redraw on resume to reenable gif animations
                 core.mDrawIsScheduled = false;
@@ -2363,13 +2341,13 @@ public final class WebViewCore {
     //////////////////////////////////////////////////////////////////////////
 
     private void restoreState(int index) {
-        WebBackForwardList list = mCallbackProxy.getBackForwardList();
+        WebBackForwardListClassic list = mCallbackProxy.getBackForwardList();
         int size = list.getSize();
         for (int i = 0; i < size; i++) {
             list.getItemAtIndex(i).inflate(mBrowserFrame.mNativeFrame);
         }
         mBrowserFrame.mLoadInitFromJava = true;
-        list.restoreIndex(mBrowserFrame.mNativeFrame, index);
+        WebBackForwardListClassic.restoreIndex(mBrowserFrame.mNativeFrame, index);
         mBrowserFrame.mLoadInitFromJava = false;
     }
 
@@ -2501,6 +2479,13 @@ public final class WebViewCore {
         setupViewport(true);
     }
 
+    static float getFixedDisplayDensity(Context context) {
+        // We make bad assumptions about multiplying and dividing density by 100,
+        // force them to be true with this hack
+        float density = context.getResources().getDisplayMetrics().density;
+        return ((int) (density * 100)) / 100.0f;
+    }
+
     private void setupViewport(boolean updateViewState) {
         if (mWebViewClassic == null || mSettings == null) {
             // We've been destroyed or are being destroyed, return early
@@ -2545,11 +2530,13 @@ public final class WebViewCore {
         // adjust the default scale to match the densityDpi
         float adjust = 1.0f;
         if (mViewportDensityDpi == -1) {
-            adjust = mContext.getResources().getDisplayMetrics().density;
+            adjust = getFixedDisplayDensity(mContext);
         } else if (mViewportDensityDpi > 0) {
             adjust = (float) mContext.getResources().getDisplayMetrics().densityDpi
                     / mViewportDensityDpi;
+            adjust = ((int) (adjust * 100)) / 100.0f;
         }
+
         // Remove any update density messages in flight.
         // If the density is indeed different from WebView's default scale,
         // a new message will be queued.
@@ -2787,14 +2774,11 @@ public final class WebViewCore {
     }
 
     // called by JNI
-    private void updateTextfield(int ptr, boolean changeToPassword,
-            String text, int textGeneration) {
+    private void updateTextfield(int ptr, String text, int textGeneration) {
         if (mWebViewClassic != null) {
-            Message msg = Message.obtain(mWebViewClassic.mPrivateHandler,
+            Message.obtain(mWebViewClassic.mPrivateHandler,
                     WebViewClassic.UPDATE_TEXTFIELD_TEXT_MSG_ID, ptr,
-                    textGeneration, text);
-            msg.getData().putBoolean("password", changeToPassword);
-            msg.sendToTarget();
+                    textGeneration, text).sendToTarget();
         }
     }
 
@@ -2855,7 +2839,7 @@ public final class WebViewCore {
      * Scroll the focused textfield to (xPercent, y) in document space
      */
     private native void nativeScrollFocusedTextInput(int nativeClass,
-            float xPercent, int y, Rect contentBounds);
+            float xPercent, int y);
 
     // these must be in document space (i.e. not scaled/zoomed).
     private native void nativeSetScrollOffset(int nativeClass,
@@ -3063,6 +3047,22 @@ public final class WebViewCore {
         mDeviceMotionAndOrientationManager.setUseMock();
     }
 
+    private void setUseMockGeolocation() {
+        mMockGeolocation.setUseMock();
+    }
+
+    public void setMockGeolocationPosition(double latitude, double longitude, double accuracy) {
+        mMockGeolocation.setPosition(latitude, longitude, accuracy);
+    }
+
+    public void setMockGeolocationError(int code, String message) {
+        mMockGeolocation.setError(code, message);
+    }
+
+    public void setMockGeolocationPermission(boolean allow) {
+        mMockGeolocation.setPermission(allow);
+    }
+
     public void setMockDeviceOrientation(boolean canProvideAlpha, double alpha,
             boolean canProvideBeta, double beta, boolean canProvideGamma, double gamma) {
         mDeviceMotionAndOrientationManager.setMockOrientation(canProvideAlpha, alpha,
@@ -3089,7 +3089,6 @@ public final class WebViewCore {
         sShouldMonitorWebCoreThread = true;
     }
 
-    private native void nativeSetIsPaused(int nativeClass, boolean isPaused);
     private native void nativePause(int nativeClass);
     private native void nativeResume(int nativeClass);
     private native void nativeFreeMemory(int nativeClass);
@@ -3135,7 +3134,7 @@ public final class WebViewCore {
     private native String nativeGetText(int nativeClass,
             int startX, int startY, int endX, int endY);
     private native void nativeSelectText(int nativeClass,
-            int startX, int startY, int endX, int endY);
+            int handleId, int x, int y);
     private native void nativeClearTextSelection(int nativeClass);
     private native boolean nativeSelectWordAt(int nativeClass, int x, int y);
     private native void nativeSelectAll(int nativeClass);
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewDatabaseClassic.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewDatabaseClassic.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewDatabaseClassic.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewDatabaseClassic.java	2013-03-12 17:03:37.000000000 +0100
@@ -52,6 +52,7 @@ final class WebViewDatabaseClassic exten
     //          implemented for b/5265606.
 
     private static WebViewDatabaseClassic sInstance = null;
+    private static final Object sInstanceLock = new Object();
 
     private static SQLiteDatabase sDatabase = null;
 
@@ -99,7 +100,8 @@ final class WebViewDatabaseClassic exten
     // Initially true until the background thread completes.
     private boolean mInitialized = false;
 
-    WebViewDatabaseClassic(final Context context) {
+    private WebViewDatabaseClassic(final Context context) {
+        JniUtil.setContext(context);
         new Thread() {
             @Override
             public void run() {
@@ -110,11 +112,13 @@ final class WebViewDatabaseClassic exten
         // Singleton only, use getInstance()
     }
 
-    public static synchronized WebViewDatabaseClassic getInstance(Context context) {
-        if (sInstance == null) {
-            sInstance = new WebViewDatabaseClassic(context);
+    public static WebViewDatabaseClassic getInstance(Context context) {
+        synchronized (sInstanceLock) {
+            if (sInstance == null) {
+                sInstance = new WebViewDatabaseClassic(context);
+            }
+            return sInstance;
         }
-        return sInstance;
     }
 
     private synchronized void init(Context context) {
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewDatabase.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewDatabase.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewDatabase.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewDatabase.java	2013-03-12 17:03:37.000000000 +0100
@@ -23,13 +23,15 @@ import android.content.Context;
  * application has stored any of the following types of browsing data and
  * to clear any such stored data for all WebViews in the application.
  * <ul>
- *  <li>Username/password pairs entered into web forms</li>
+ *  <li>Username/password pairs for web forms</li>
  *  <li>HTTP authentication username/password pairs</li>
  *  <li>Data entered into text fields (e.g. for autocomplete suggestions)</li>
  * </ul>
  */
 public class WebViewDatabase {
-    // TODO: deprecate/hide this.
+    /**
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
+     */
     protected static final String LOGTAG = "webviewdatabase";
 
     /**
@@ -38,55 +40,70 @@ public class WebViewDatabase {
     protected WebViewDatabase() {
     }
 
-    public static synchronized WebViewDatabase getInstance(Context context) {
+    public static WebViewDatabase getInstance(Context context) {
         return WebViewFactory.getProvider().getWebViewDatabase(context);
     }
 
     /**
-     * Gets whether there are any username/password combinations
-     * from web pages saved.
+     * Gets whether there are any saved username/password pairs for web forms.
+     * Note that these are unrelated to HTTP authentication credentials.
      *
-     * @return true if there are any username/passwords used in web
-     *         forms saved
+     * @return true if there are any saved username/password pairs
+     * @see WebView#savePassword
+     * @see clearUsernamePassword
      */
     public boolean hasUsernamePassword() {
         throw new MustOverrideException();
     }
 
     /**
-     * Clears any username/password combinations saved from web forms.
+     * Clears any saved username/password pairs for web forms.
+     * Note that these are unrelated to HTTP authentication credentials.
+     *
+     * @see WebView#savePassword
+     * @see hasUsernamePassword
      */
     public void clearUsernamePassword() {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets whether there are any HTTP authentication username/password combinations saved.
+     * Gets whether there are any saved credentials for HTTP authentication.
      *
-     * @return true if there are any HTTP authentication username/passwords saved
+     * @return whether there are any saved credentials
+     * @see Webview#getHttpAuthUsernamePassword
+     * @see Webview#setHttpAuthUsernamePassword
+     * @see clearHttpAuthUsernamePassword
      */
     public boolean hasHttpAuthUsernamePassword() {
         throw new MustOverrideException();
     }
 
     /**
-     * Clears any HTTP authentication username/passwords that are saved.
+     * Clears any saved credentials for HTTP authentication.
+     *
+     * @see Webview#getHttpAuthUsernamePassword
+     * @see Webview#setHttpAuthUsernamePassword
+     * @see hasHttpAuthUsernamePassword
      */
     public void clearHttpAuthUsernamePassword() {
         throw new MustOverrideException();
     }
 
     /**
-     * Gets whether there is any previously-entered form data saved.
+     * Gets whether there is any saved data for web forms.
      *
-     * @return true if there is form data saved
+     * @return whether there is any saved data for web forms
+     * @see clearFormData
      */
     public boolean hasFormData() {
         throw new MustOverrideException();
     }
 
     /**
-     * Clears any stored previously-entered form data.
+     * Clears any saved data for web forms.
+     *
+     * @see hasFormData
      */
     public void clearFormData() {
         throw new MustOverrideException();
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewFactory.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewFactory.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewFactory.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewFactory.java	2013-03-12 17:03:37.000000000 +0100
@@ -16,14 +16,23 @@
 
 package android.webkit;
 
+import android.os.Build;
+import android.os.StrictMode;
+import android.os.SystemProperties;
 import android.util.Log;
 
+import dalvik.system.PathClassLoader;
+
 /**
  * Top level factory, used creating all the main WebView implementation classes.
  */
 class WebViewFactory {
     // Default Provider factory class name.
-    private static final String DEFAULT_WEB_VIEW_FACTORY = "android.webkit.WebViewClassic$Factory";
+    // TODO: When the Chromium powered WebView is ready, it should be the default factory class.
+    private static final String DEFAULT_WEBVIEW_FACTORY = "android.webkit.WebViewClassic$Factory";
+    private static final String CHROMIUM_WEBVIEW_FACTORY =
+            "com.android.webviewchromium.WebViewChromiumFactoryProvider";
+    private static final String CHROMIUM_WEBVIEW_JAR = "/system/framework/webviewchromium.jar";
 
     private static final String LOGTAG = "WebViewFactory";
 
@@ -32,24 +41,54 @@ class WebViewFactory {
     // Cache the factory both for efficiency, and ensure any one process gets all webviews from the
     // same provider.
     private static WebViewFactoryProvider sProviderInstance;
+    private static final Object sProviderLock = new Object();
 
-    static synchronized WebViewFactoryProvider getProvider() {
-        // For now the main purpose of this function (and the factory abstraction) is to keep
-        // us honest and minimize usage of WebViewClassic internals when binding the proxy.
-        if (sProviderInstance != null) return sProviderInstance;
-
-        sProviderInstance = getFactoryByName(DEFAULT_WEB_VIEW_FACTORY);
-        if (sProviderInstance == null) {
-            if (DEBUG) Log.v(LOGTAG, "Falling back to explicit linkage");
-            sProviderInstance = new WebViewClassic.Factory();
+    static WebViewFactoryProvider getProvider() {
+        synchronized (sProviderLock) {
+            // For now the main purpose of this function (and the factory abstraction) is to keep
+            // us honest and minimize usage of WebViewClassic internals when binding the proxy.
+            if (sProviderInstance != null) return sProviderInstance;
+
+            // For debug builds, we allow a system property to specify that we should use the
+            // Chromium powered WebView. This enables us to switch between implementations
+            // at runtime. For user (release) builds, don't allow this.
+            if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean("webview.use_chromium", false)) {
+                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
+                try {
+                    sProviderInstance = loadChromiumProvider();
+                    if (DEBUG) Log.v(LOGTAG, "Loaded Chromium provider: " + sProviderInstance);
+                } finally {
+                    StrictMode.setThreadPolicy(oldPolicy);
+                }
+            }
+
+            if (sProviderInstance == null) {
+                if (DEBUG) Log.v(LOGTAG, "Falling back to default provider: "
+                        + DEFAULT_WEBVIEW_FACTORY);
+                sProviderInstance = getFactoryByName(DEFAULT_WEBVIEW_FACTORY,
+                        WebViewFactory.class.getClassLoader());
+                if (sProviderInstance == null) {
+                    if (DEBUG) Log.v(LOGTAG, "Falling back to explicit linkage");
+                    sProviderInstance = new WebViewClassic.Factory();
+                }
+            }
+            return sProviderInstance;
         }
-        return sProviderInstance;
     }
 
-    private static WebViewFactoryProvider getFactoryByName(String providerName) {
+    // TODO: This allows us to have the legacy and Chromium WebView coexist for development
+    // and side-by-side testing. After transition, remove this when no longer required.
+    private static WebViewFactoryProvider loadChromiumProvider() {
+        ClassLoader clazzLoader = new PathClassLoader(CHROMIUM_WEBVIEW_JAR, null,
+                WebViewFactory.class.getClassLoader());
+        return getFactoryByName(CHROMIUM_WEBVIEW_FACTORY, clazzLoader);
+    }
+
+    private static WebViewFactoryProvider getFactoryByName(String providerName,
+            ClassLoader loader) {
         try {
             if (DEBUG) Log.v(LOGTAG, "attempt to load class " + providerName);
-            Class<?> c = Class.forName(providerName);
+            Class<?> c = Class.forName(providerName, true, loader);
             if (DEBUG) Log.v(LOGTAG, "instantiating factory");
             return (WebViewFactoryProvider) c.newInstance();
         } catch (ClassNotFoundException e) {
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewFactoryProvider.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewFactoryProvider.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewFactoryProvider.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewFactoryProvider.java	2013-03-12 17:03:37.000000000 +0100
@@ -42,6 +42,12 @@ public interface WebViewFactoryProvider
          * {@link android.webkit.WebView#disablePlatformNotifications()}
          */
         void setPlatformNotificationsEnabled(boolean enable);
+
+        /**
+         * Implements the API method:
+         * {@link android.webkit.WebSettings#getDefaultUserAgent(Context) }
+         */
+        String getDefaultUserAgent(Context context);
     }
 
     Statics getStatics();
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebView.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebView.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebView.java	2013-03-12 17:09:11.258011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebView.java	2013-03-12 17:03:37.000000000 +0100
@@ -35,8 +35,8 @@ import android.util.Log;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.View;
+import android.view.ViewDebug;
 import android.view.ViewGroup;
-import android.view.ViewGroup.LayoutParams;
 import android.view.ViewTreeObserver;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityNodeInfo;
@@ -44,6 +44,7 @@ import android.view.inputmethod.EditorIn
 import android.view.inputmethod.InputConnection;
 import android.widget.AbsoluteLayout;
 
+import java.io.BufferedWriter;
 import java.io.File;
 import java.util.Map;
 
@@ -163,10 +164,7 @@ import java.util.Map;
  *
  * <p>For obvious security reasons, your application has its own
  * cache, cookie store etc.&mdash;it does not share the Browser
- * application's data. Cookies are managed on a separate thread, so
- * operations like index building don't block the UI
- * thread. Follow the instructions in {@link android.webkit.CookieSyncManager}
- * if you want to use cookies in your application.
+ * application's data.
  * </p>
  *
  * <p>By default, requests by the HTML to open new windows are
@@ -263,7 +261,7 @@ import java.util.Map;
 @Widget
 public class WebView extends AbsoluteLayout
         implements ViewTreeObserver.OnGlobalFocusChangeListener,
-        ViewGroup.OnHierarchyChangeListener {
+        ViewGroup.OnHierarchyChangeListener, ViewDebug.HierarchyHandler {
 
     private static final String LOGTAG = "webview_proxy";
 
@@ -312,15 +310,15 @@ public class WebView extends AbsoluteLay
         /**
          * Notifies the listener about progress made by a find operation.
          *
-         * @param numberOfMatches how many matches have been found
          * @param activeMatchOrdinal the zero-based ordinal of the currently selected match
+         * @param numberOfMatches how many matches have been found
          * @param isDoneCounting whether the find operation has actually completed. The listener
          *                       may be notified multiple times while the
          *                       operation is underway, and the numberOfMatches
          *                       value should not be considered final unless
          *                       isDoneCounting is true.
          */
-        public void onFindResultReceived(int numberOfMatches, int activeMatchOrdinal,
+        public void onFindResultReceived(int activeMatchOrdinal, int numberOfMatches,
             boolean isDoneCounting);
     }
 
@@ -332,16 +330,12 @@ public class WebView extends AbsoluteLay
     @Deprecated
     public interface PictureListener {
         /**
-         * Notifies the listener that the picture has changed.
+         * Used to provide notification that the WebView's picture has changed.
+         * See {@link WebView#capturePicture} for details of the picture.
          *
          * @param view the WebView that owns the picture
          * @param picture the new picture
-         * @deprecated Due to internal changes, the picture does not include
-         *             composited layers such as fixed position elements or
-         *             scrollable divs. While the PictureListener API can still
-         *             be used to detect changes in the WebView content, you
-         *             are advised against its usage until a replacement is
-         *             provided in a future Android release.
+         * @deprecated Deprecated due to internal changes.
          */
         @Deprecated
         public void onNewPicture(WebView view, Picture picture);
@@ -475,7 +469,13 @@ public class WebView extends AbsoluteLay
      * @param defStyle the default style resource ID
      * @param privateBrowsing whether this WebView will be initialized in
      *                        private mode
+     *
+     * @deprecated Private browsing is no longer supported directly via 
+     * WebView and will be removed in a future release. Prefer using
+     * {@link WebSettings}, {@link WebViewDatabase}, {@link CookieManager}
+     * and {@link WebStorage} for fine-grained control of privacy data.
      */
+    @Deprecated
     public WebView(Context context, AttributeSet attrs, int defStyle,
             boolean privateBrowsing) {
         this(context, attrs, defStyle, null, privateBrowsing);
@@ -555,6 +555,7 @@ public class WebView extends AbsoluteLay
      * Gets the visible height (in pixels) of the embedded title bar (if any).
      *
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     public int getVisibleTitleHeight() {
         checkThread();
@@ -574,7 +575,11 @@ public class WebView extends AbsoluteLay
 
     /**
      * Sets the SSL certificate for the main top-level page.
+     *
+     * @deprecated Calling this function has no useful effect, and will be
+     * ignored in future releases.
      */
+    @Deprecated
     public void setCertificate(SslCertificate certificate) {
         checkThread();
         mProvider.setCertificate(certificate);
@@ -585,12 +590,16 @@ public class WebView extends AbsoluteLay
     //-------------------------------------------------------------------------
 
     /**
-     * Saves the username and password for a particular host in this WebView's
-     * internal database.
+     * Sets a username and password pair for the specified host. This data is
+     * used by the Webview to autocomplete username and password fields in web
+     * forms. Note that this is unrelated to the credentials used for HTTP
+     * authentication.
      *
      * @param host the host that required the credentials
      * @param username the username for the given host
      * @param password the password for the given host
+     * @see WebViewDatabase#clearUsernamePassword
+     * @see WebViewDatabase#hasUsernamePassword
      */
     public void savePassword(String host, String username, String password) {
         checkThread();
@@ -598,13 +607,17 @@ public class WebView extends AbsoluteLay
     }
 
     /**
-     * Sets the HTTP authentication credentials for a given host and realm.
-     *
-     * @param host the host for the credentials
-     * @param realm the realm for the credentials
-     * @param username the username for the password. If it is null, it means
-     *                 password can't be saved.
+     * Stores HTTP authentication credentials for a given host and realm. This
+     * method is intended to be used with
+     * {@link WebViewClient#onReceivedHttpAuthRequest}.
+     *
+     * @param host the host to which the credentials apply
+     * @param realm the realm to which the credentials apply
+     * @param username the username
      * @param password the password
+     * @see getHttpAuthUsernamePassword
+     * @see WebViewDatabase#hasHttpAuthUsernamePassword
+     * @see WebViewDatabase#clearHttpAuthUsernamePassword
      */
     public void setHttpAuthUsernamePassword(String host, String realm,
             String username, String password) {
@@ -613,13 +626,18 @@ public class WebView extends AbsoluteLay
     }
 
     /**
-     * Retrieves the HTTP authentication username and password for a given
-     * host and realm pair
-     *
-     * @param host the host for which the credentials apply
-     * @param realm the realm for which the credentials apply
-     * @return String[] if found. String[0] is username, which can be null and
-     *         String[1] is password. Return null if it can't find anything.
+     * Retrieves HTTP authentication credentials for a given host and realm.
+     * This method is intended to be used with
+     * {@link WebViewClient#onReceivedHttpAuthRequest}.
+     *
+     * @param host the host to which the credentials apply
+     * @param realm the realm to which the credentials apply
+     * @return the credentials as a String array, if found. The first element
+     *         is the username and the second element is the password. Null if
+     *         no credentials are found.
+     * @see setHttpAuthUsernamePassword
+     * @see WebViewDatabase#hasHttpAuthUsernamePassword
+     * @see WebViewDatabase#clearHttpAuthUsernamePassword
      */
     public String[] getHttpAuthUsernamePassword(String host, String realm) {
         checkThread();
@@ -641,6 +659,7 @@ public class WebView extends AbsoluteLay
      * Notifications are enabled by default.
      *
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public static void enablePlatformNotifications() {
@@ -653,6 +672,7 @@ public class WebView extends AbsoluteLay
      * Notifications are enabled by default.
      *
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public static void disablePlatformNotifications() {
@@ -677,14 +697,11 @@ public class WebView extends AbsoluteLay
      * {@link android.app.Activity#onSaveInstanceState}. Please note that this
      * method no longer stores the display data for this WebView. The previous
      * behavior could potentially leak files if {@link #restoreState} was never
-     * called. See {@link #savePicture} and {@link #restorePicture} for saving
-     * and restoring the display data.
+     * called.
      *
      * @param outState the Bundle to store this WebView's state
      * @return the same copy of the back/forward list used to save the state. If
      *         saveState fails, the returned list will be null.
-     * @see #savePicture
-     * @see #restorePicture
      */
     public WebBackForwardList saveState(Bundle outState) {
         checkThread();
@@ -699,6 +716,7 @@ public class WebView extends AbsoluteLay
      *             overwritten with this WebView's picture data.
      * @return true if the picture was successfully saved
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public boolean savePicture(Bundle b, final File dest) {
@@ -715,6 +733,7 @@ public class WebView extends AbsoluteLay
      * @param src the file where the picture data was stored
      * @return true if the picture was successfully restored
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public boolean restorePicture(Bundle b, File src) {
@@ -723,19 +742,16 @@ public class WebView extends AbsoluteLay
     }
 
     /**
-     * Restores the state of this WebView from the given map used in
-     * {@link android.app.Activity#onRestoreInstanceState}. This method should
-     * be called to restore the state of this WebView before using the object. If
+     * Restores the state of this WebView from the given Bundle. This method is
+     * intended for use in {@link android.app.Activity#onRestoreInstanceState}
+     * and should be called to restore the state of this WebView. If
      * it is called after this WebView has had a chance to build state (load
      * pages, create a back/forward list, etc.) there may be undesirable
      * side-effects. Please note that this method no longer restores the
-     * display data for this WebView. See {@link #savePicture} and {@link
-     * #restorePicture} for saving and restoring the display data.
+     * display data for this WebView.
      *
      * @param inState the incoming Bundle of state
      * @return the restored back/forward list or null if restoreState failed
-     * @see #savePicture
-     * @see #restorePicture
      */
     public WebBackForwardList restoreState(Bundle inState) {
         checkThread();
@@ -791,11 +807,13 @@ public class WebView extends AbsoluteLay
      * #loadDataWithBaseURL(String,String,String,String,String)
      * loadDataWithBaseURL()} with an appropriate base URL.
      * <p>
-     * If the value of the encoding parameter is 'base64', then the data must
-     * be encoded as base64. Otherwise, the data must use ASCII encoding for
+     * The encoding parameter specifies whether the data is base64 or URL
+     * encoded. If the data is base64 encoded, the value of the encoding
+     * parameter must be 'base64'. For all other values of the parameter,
+     * including null, it is assumed that the data uses ASCII encoding for
      * octets inside the range of safe URL characters and use the standard %xx
-     * hex encoding of URLs for octets outside that range. For example,
-     * '#', '%', '\', '?' should be replaced by %23, %25, %27, %3f respectively.
+     * hex encoding of URLs for octets outside that range. For example, '#',
+     * '%', '\', '?' should be replaced by %23, %25, %27, %3f respectively.
      * <p>
      * The 'data' scheme URL formed by this method uses the default US-ASCII
      * charset. If you need need to set a different charset, you should form a
@@ -986,13 +1004,18 @@ public class WebView extends AbsoluteLay
     }
 
     /**
-     * Gets a new picture that captures the current display of this WebView.
-     * This is a copy of the display, and will be unaffected if this WebView
-     * later loads a different URL.
-     *
-     * @return a picture containing the current contents of this WebView. Note
-     *         this picture is of the entire document, and is not restricted to
-     *         the bounds of the view.
+     * Gets a new picture that captures the current contents of this WebView.
+     * The picture is of the entire document being displayed, and is not
+     * limited to the area currently displayed by this WebView. Also, the
+     * picture is a static copy and is unaffected by later changes to the
+     * content being displayed.
+     * <p>
+     * Note that due to internal changes, for API levels between
+     * {@link android.os.Build.VERSION_CODES#HONEYCOMB} and
+     * {@link android.os.Build.VERSION_CODES#ICE_CREAM_SANDWICH} inclusive, the
+     * picture does not include fixed position elements or scrollable divs.
+     *
+     * @return a picture that captures the current contents of this WebView
      */
     public Picture capturePicture() {
         checkThread();
@@ -1003,7 +1026,13 @@ public class WebView extends AbsoluteLay
      * Gets the current scale of this WebView.
      *
      * @return the current scale
+     *
+     * @deprecated This method is prone to inaccuracy due to race conditions
+     * between the web rendering and UI threads; prefer
+     * {@link WebViewClient#onScaleChanged}.
      */
+    @Deprecated
+    @ViewDebug.ExportedProperty(category = "webview")
     public float getScale() {
         checkThread();
         return mProvider.getScale();
@@ -1094,6 +1123,7 @@ public class WebView extends AbsoluteLay
      *
      * @return the URL for the current page
      */
+    @ViewDebug.ExportedProperty(category = "webview")
     public String getUrl() {
         checkThread();
         return mProvider.getUrl();
@@ -1108,6 +1138,7 @@ public class WebView extends AbsoluteLay
      *
      * @return the URL that was originally requested for the current page
      */
+    @ViewDebug.ExportedProperty(category = "webview")
     public String getOriginalUrl() {
         checkThread();
         return mProvider.getOriginalUrl();
@@ -1119,6 +1150,7 @@ public class WebView extends AbsoluteLay
      *
      * @return the title for the current page
      */
+    @ViewDebug.ExportedProperty(category = "webview")
     public String getTitle() {
         checkThread();
         return mProvider.getTitle();
@@ -1161,6 +1193,7 @@ public class WebView extends AbsoluteLay
      *
      * @return the height of the HTML content
      */
+    @ViewDebug.ExportedProperty(category = "webview")
     public int getContentHeight() {
         checkThread();
         return mProvider.getContentHeight();
@@ -1172,6 +1205,7 @@ public class WebView extends AbsoluteLay
      * @return the width of the HTML content
      * @hide
      */
+    @ViewDebug.ExportedProperty(category = "webview")
     public int getContentWidth() {
         return mProvider.getContentWidth();
     }
@@ -1246,8 +1280,10 @@ public class WebView extends AbsoluteLay
     }
 
     /**
-     * Makes sure that clearing the form data removes the adapter from the
-     * currently focused textfield if there is one.
+     * Removes the autocomplete popup from the currently focused form field, if
+     * present. Note this only affects the display of the autocomplete popup,
+     * it does not remove any saved form data from this WebView's store. To do
+     * that, use {@link WebViewDatabase#clearFormData}.
      */
     public void clearFormData() {
         checkThread();
@@ -1297,12 +1333,11 @@ public class WebView extends AbsoluteLay
     }
 
     /**
-     * Highlights and scrolls to the next match found by {@link #findAll} or
+     * Highlights and scrolls to the next match found by
      * {@link #findAllAsync}, wrapping around page boundaries as necessary.
-     * Notifies any registered {@link FindListener}. If neither
-     * {@link #findAll} nor {@link #findAllAsync(String)} has been called yet,
-     * or if {@link #clearMatches} has been called since the last find
-     * operation, this function does nothing.
+     * Notifies any registered {@link FindListener}. If {@link #findAllAsync(String)}
+     * has not been called yet, or if {@link #clearMatches} has been called since the
+     * last find operation, this function does nothing.
      *
      * @param forward the direction to search
      * @see #setFindListener
@@ -1331,8 +1366,7 @@ public class WebView extends AbsoluteLay
     /**
      * Finds all instances of find on the page and highlights them,
      * asynchronously. Notifies any registered {@link FindListener}.
-     * Successive calls to this or {@link #findAll} will cancel any
-     * pending searches.
+     * Successive calls to this will cancel any pending searches.
      *
      * @param find the string to find.
      * @see #setFindListener
@@ -1381,13 +1415,12 @@ public class WebView extends AbsoluteLay
      * @return the address, or if no address is found, null
      */
     public static String findAddress(String addr) {
-        checkThread();
         return getFactory().getStatics().findAddress(addr);
     }
 
     /**
      * Clears the highlighting surrounding text matches created by
-     * {@link #findAll} or {@link #findAllAsync}.
+     * {@link #findAllAsync}.
      */
     public void clearMatches() {
         checkThread();
@@ -1457,10 +1490,22 @@ public class WebView extends AbsoluteLay
     /**
      * Injects the supplied Java object into this WebView. The object is
      * injected into the JavaScript context of the main frame, using the
-     * supplied name. This allows the Java object's public methods to be
-     * accessed from JavaScript. Note that that injected objects will not
+     * supplied name. This allows the Java object's methods to be
+     * accessed from JavaScript. For applications targeted to API
+     * level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
+     * and above, only public methods that are annotated with
+     * {@link android.webkit.JavascriptInterface} can be accessed from JavaScript.
+     * For applications targeted to API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN} or below,
+     * all public methods (including the inherited ones) can be accessed, see the
+     * important security note below for implications.
+     * <p> Note that injected objects will not
      * appear in JavaScript until the page is next (re)loaded. For example:
-     * <pre> webView.addJavascriptInterface(new Object(), "injectedObject");
+     * <pre>
+     * class JsObject {
+     *    {@literal @}JavascriptInterface
+     *    public String toString() { return "injectedObject"; }
+     * }
+     * webView.addJavascriptInterface(new JsObject(), "injectedObject");
      * webView.loadData("<!DOCTYPE html><title></title>", "text/html", null);
      * webView.loadUrl("javascript:alert(injectedObject.toString())");</pre>
      * <p>
@@ -1468,7 +1513,9 @@ public class WebView extends AbsoluteLay
      * <ul>
      * <li> This method can be used to allow JavaScript to control the host
      * application. This is a powerful feature, but also presents a security
-     * risk, particularly as JavaScript could use reflection to access an
+     * risk for applications targeted to API level
+     * {@link android.os.Build.VERSION_CODES#JELLY_BEAN} or below, because
+     * JavaScript could use reflection to access an
      * injected object's public fields. Use of this method in a WebView
      * containing untrusted content could allow an attacker to manipulate the
      * host application in unintended ways, executing Java code with the
@@ -1477,6 +1524,7 @@ public class WebView extends AbsoluteLay
      * <li> JavaScript interacts with Java object on a private, background
      * thread of this WebView. Care is therefore required to maintain thread
      * safety.</li>
+     * <li> The Java object's fields are not accessible.</li>
      * </ul>
      *
      * @param object the Java object to inject into this WebView's JavaScript
@@ -1539,11 +1587,11 @@ public class WebView extends AbsoluteLay
      * functionality; it will be deprecated in the future.
      *
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public void emulateShiftHeld() {
         checkThread();
-        mProvider.emulateShiftHeld();
     }
 
     /**
@@ -1574,6 +1622,10 @@ public class WebView extends AbsoluteLay
     public void onGlobalFocusChanged(View oldFocus, View newFocus) {
     }
 
+    /**
+     * @deprecated Only the default case, true, will be supported in a future version.
+     */
+    @Deprecated
     public void setMapTrackballToArrowKeys(boolean setMap) {
         checkThread();
         mProvider.setMapTrackballToArrowKeys(setMap);
@@ -1607,7 +1659,12 @@ public class WebView extends AbsoluteLay
      * Gets whether this WebView can be zoomed in.
      *
      * @return true if this WebView can be zoomed in
+     *
+     * @deprecated This method is prone to inaccuracy due to race conditions
+     * between the web rendering and UI threads; prefer
+     * {@link WebViewClient#onScaleChanged}.
      */
+    @Deprecated
     public boolean canZoomIn() {
         checkThread();
         return mProvider.canZoomIn();
@@ -1617,7 +1674,12 @@ public class WebView extends AbsoluteLay
      * Gets whether this WebView can be zoomed out.
      *
      * @return true if this WebView can be zoomed out
+     *
+     * @deprecated This method is prone to inaccuracy due to race conditions
+     * between the web rendering and UI threads; prefer
+     * {@link WebViewClient#onScaleChanged}.
      */
+    @Deprecated
     public boolean canZoomOut() {
         checkThread();
         return mProvider.canZoomOut();
@@ -1645,11 +1707,29 @@ public class WebView extends AbsoluteLay
 
     /**
      * @deprecated This method is now obsolete.
+     * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
      */
     @Deprecated
     public void debugDump() {
         checkThread();
-        mProvider.debugDump();
+    }
+
+    /**
+     * See {@link ViewDebug.HierarchyHandler#dumpViewHierarchyWithProperties(BufferedWriter, int)}
+     * @hide
+     */
+    @Override
+    public void dumpViewHierarchyWithProperties(BufferedWriter out, int level) {
+        mProvider.dumpViewHierarchyWithProperties(out, level);
+    }
+
+    /**
+     * See {@link ViewDebug.HierarchyHandler#findHierarchyView(String, int)}
+     * @hide
+     */
+    @Override
+    public View findHierarchyView(String className, int hashCode) {
+        return mProvider.findHierarchyView(className, hashCode);
     }
 
     //-------------------------------------------------------------------------
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewProvider.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewProvider.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/WebViewProvider.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/WebViewProvider.java	2013-03-12 17:03:37.000000000 +0100
@@ -37,6 +37,7 @@ import android.view.inputmethod.InputCon
 import android.webkit.WebView.HitTestResult;
 import android.webkit.WebView.PictureListener;
 
+import java.io.BufferedWriter;
 import java.io.File;
 import java.util.Map;
 
@@ -220,8 +221,6 @@ public interface WebViewProvider {
 
     public WebSettings getSettings();
 
-    public void emulateShiftHeld();
-
     public void setMapTrackballToArrowKeys(boolean setMap);
 
     public void flingScroll(int vx, int vy);
@@ -236,7 +235,9 @@ public interface WebViewProvider {
 
     public boolean zoomOut();
 
-    public void debugDump();
+    public void dumpViewHierarchyWithProperties(BufferedWriter out, int level);
+
+    public View findHierarchyView(String className, int hashCode);
 
     //-------------------------------------------------------------------------
     // Provider glue methods
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/ZoomControlEmbedded.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/ZoomControlEmbedded.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/ZoomControlEmbedded.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/ZoomControlEmbedded.java	2013-03-12 17:03:37.000000000 +0100
@@ -90,7 +90,7 @@ class ZoomControlEmbedded implements Zoo
             View controls = mZoomButtonsController.getZoomControls();
             ViewGroup.LayoutParams params = controls.getLayoutParams();
             if (params instanceof FrameLayout.LayoutParams) {
-                ((FrameLayout.LayoutParams) params).gravity = Gravity.RIGHT;
+                ((FrameLayout.LayoutParams) params).gravity = Gravity.END;
             }
         }
         return mZoomButtonsController;
diff -rupN /home/marcel/android/system/frameworks/base/core/java/android/webkit/ZoomManager.java /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/ZoomManager.java
--- /home/marcel/android/system/frameworks/base/core/java/android/webkit/ZoomManager.java	2013-03-12 17:09:11.266011099 +0100
+++ /home/marcel/Downloads/android_frameworks_base/core/java/android/webkit/ZoomManager.java	2013-03-12 17:03:37.000000000 +0100
@@ -287,6 +287,7 @@ class ZoomManager {
         if (!exceedsMinScaleIncrement(mMinZoomScale, mMaxZoomScale)) {
             mMaxZoomScale = mMinZoomScale;
         }
+        sanitizeMinMaxScales();
     }
 
     public final float getScale() {
@@ -909,6 +910,14 @@ class ZoomManager {
         }
     }
 
+    private void sanitizeMinMaxScales() {
+        if (mMinZoomScale > mMaxZoomScale) {
+            Log.w(LOGTAG, "mMinZoom > mMaxZoom!!! " + mMinZoomScale + " > " + mMaxZoomScale,
+                    new Exception());
+            mMaxZoomScale = mMinZoomScale;
+        }
+    }
+
     public void onSizeChanged(int w, int h, int ow, int oh) {
         // reset zoom and anchor to the top left corner of the screen
         // unless we are already zooming
@@ -933,6 +942,7 @@ class ZoomManager {
             if (mInitialScale > 0 && mInitialScale < mMinZoomScale) {
                 mMinZoomScale = mInitialScale;
             }
+            sanitizeMinMaxScales();
         }
 
         dismissZoomPicker();
@@ -1004,6 +1014,7 @@ class ZoomManager {
         } else {
             mMaxZoomScale = viewState.mMaxScale;
         }
+        sanitizeMinMaxScales();
     }
 
     /**
@@ -1033,6 +1044,7 @@ class ZoomManager {
         if (!mMinZoomScaleFixed || settings.getUseWideViewPort()) {
             mMinZoomScale = newZoomOverviewScale;
             mMaxZoomScale = Math.max(mMaxZoomScale, mMinZoomScale);
+            sanitizeMinMaxScales();
         }
         // fit the content width to the current view for the first new picture
         // after first layout.
@@ -1113,6 +1125,7 @@ class ZoomManager {
             mMinZoomScale = (mInitialScale > 0) ?
                     Math.min(mInitialScale, overviewScale) : overviewScale;
             mMaxZoomScale = Math.max(mMaxZoomScale, mMinZoomScale);
+            sanitizeMinMaxScales();
         }
 
         if (!mWebView.drawHistory()) {
