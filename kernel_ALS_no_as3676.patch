From e997643dfa51c93e9ad7741c96bc4fec8345a728 Mon Sep 17 00:00:00 2001
From: Alin Jerpelea <jerpelea@gmail.com>
Date: Wed, 3 Apr 2013 20:15:31 +0300
Subject: [PATCH] mogami: export als values to userspace

Change-Id: I92a9d74daefd06ede308ebbad540bac7cff2c80f
---
 drivers/leds/leds-as3676.c |   52 +++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 51 insertions(+), 1 deletion(-)

diff --git a/drivers/leds/leds-as3676.c b/drivers/leds/leds-as3676.c
index 56c0d06..172370a 100644
--- a/drivers/leds/leds-as3676.c
+++ b/drivers/leds/leds-as3676.c
@@ -20,6 +20,7 @@
 
 #define AS3676_NAME "as3676"
 
+
 enum as3676_cmode {
 	AS3676_CMODE_IMMEDIATE,
 	AS3676_CMODE_SCHEDULED,
@@ -372,6 +373,8 @@ static u8 as3676_restore_regs[] = {
  * you *could* but it would be really really stupid */
 #define AS3676_INTERFACE_MAX AS3676_SINK_MAX
 
+#define AS3676_ADC_READ_RETRY_NUM  10
+
 static const struct as3676_als_config as3676_default_config = {
 	.gain = AS3676_GAIN_1,
 	.filter_up = AS3676_FILTER_1HZ,
@@ -1393,8 +1396,48 @@ static ssize_t as3676_mode_store(struct device *dev,
 	return size;
 }
 
-static DEVICE_ATTR(max_current, 0600, as3676_max_current_show, as3676_max_current_store);
+static ssize_t as3676_adc_als_value_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct as3676_record *rd = dev_get_drvdata(dev);
+	struct as3676_interface *intf;
+	struct led_classdev *led_cdev = dev_get_drvdata(&rd->client->dev);
+	u32 adc_result;
+	u8 val;
+	int i;
+
+	intf = container_of(led_cdev, struct as3676_interface, cdev);
+
+	as3676_lock(rd);
+	val = reg_get(rd, AS3676_ADC_CTRL);
+	as3676_unlock(rd);
+	if ((val & 0x3F) != AS3676_ALS_SOURCE_GPIO2) {
+		dev_err(&rd->client->dev, "als source failed\n");
+		return -EFAULT;
+	}
+
+	for (i = 0; i < AS3676_ADC_READ_RETRY_NUM; i++) {
+		adc_result = i2c_smbus_read_byte_data(rd->client, 0x27);
+		if (!(adc_result & 0x80))
+			break;
+		/* Wait for the end of the next ADC conversion cycle */
+		udelay(10);
+	}
+	if (i >= AS3676_ADC_READ_RETRY_NUM) {
+		dev_err(&rd->client->dev, "adc_result failed\n");
+		return -EFAULT;
+	}
+
+	adc_result = (adc_result & 0x7F) << 3;
+	adc_result |= i2c_smbus_read_byte_data(rd->client, 0x28) & 0x07;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", adc_result);
+}
+
+static DEVICE_ATTR(max_current, 0600, as3676_max_current_show,
+					as3676_max_current_store);
 static DEVICE_ATTR(mode, 0200, NULL, as3676_mode_store);
+static DEVICE_ATTR(adc_als_value, 0444, as3676_adc_als_value_show, NULL);
 
 static void dummy_kobj_release(struct kobject *kobj)
 { }
@@ -1587,6 +1630,8 @@ static int __devexit as3676_remove(struct i2c_client *client)
 
 		kobject_put(&intf->kobj);
 	}
+	device_remove_file(&client->dev, &dev_attr_adc_als_value);
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	unregister_early_suspend(&rd->early_suspend);
 #endif
@@ -1718,6 +1763,11 @@ static int __devinit as3676_probe(struct i2c_client *client,
 				"create dev_attr_mode failed\n");
 	}
 
+	err = device_create_file(&client->dev, &dev_attr_adc_als_value);
+	if (err)
+		dev_err(&client->dev,
+			"create dev_attr_adc_als_value failed\n");
+
 	/* Enable charge pump and connect all leds to it */
 	/* TODO: double check that these are appropriate according to pdata */
 	reg_set(rd, AS3676_REG_CTRL, 0x05);
-- 
1.7.10.4

