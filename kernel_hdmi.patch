diff --git a/drivers/video/hdmi/ep932/.DDC_If.o.cmd b/drivers/video/hdmi/ep932/.DDC_If.o.cmd
new file mode 100644
index 0000000..26fb05b
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.DDC_If.o.cmd
@@ -0,0 +1,466 @@
+cmd_drivers/video/hdmi/ep932/DDC_If.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.DDC_If.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(DDC_If)"  -D"KBUILD_MODNAME=KBUILD_STR(DDC_If)"  -c -o drivers/video/hdmi/ep932/DDC_If.o drivers/video/hdmi/ep932/DDC_If.c
+
+deps_drivers/video/hdmi/ep932/DDC_If.o := \
+  drivers/video/hdmi/ep932/DDC_If.c \
+    $(wildcard include/config/hdmi/ep932/socket/i2c.h) \
+  drivers/video/hdmi/ep932/DDC_If.h \
+  drivers/video/hdmi/ep932/EP932api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+    $(wildcard include/config/mmu.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/discontigmem.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/linkage.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+    $(wildcard include/config/pm.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/type.h \
+
+drivers/video/hdmi/ep932/DDC_If.o: $(deps_drivers/video/hdmi/ep932/DDC_If.o)
+
+$(deps_drivers/video/hdmi/ep932/DDC_If.o):
diff --git a/drivers/video/hdmi/ep932/.EP932Controller.o.cmd b/drivers/video/hdmi/ep932/.EP932Controller.o.cmd
new file mode 100644
index 0000000..1a1e2fb
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.EP932Controller.o.cmd
@@ -0,0 +1,472 @@
+cmd_drivers/video/hdmi/ep932/EP932Controller.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.EP932Controller.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(EP932Controller)"  -D"KBUILD_MODNAME=KBUILD_STR(EP932Controller)"  -c -o drivers/video/hdmi/ep932/EP932Controller.o drivers/video/hdmi/ep932/EP932Controller.c
+
+deps_drivers/video/hdmi/ep932/EP932Controller.o := \
+  drivers/video/hdmi/ep932/EP932Controller.c \
+  drivers/video/hdmi/ep932/EP932api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+    $(wildcard include/config/mmu.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/discontigmem.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/linkage.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+    $(wildcard include/config/pm.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/type.h \
+  drivers/video/hdmi/ep932/Edid.h \
+  drivers/video/hdmi/ep932/DDC_If.h \
+  drivers/video/hdmi/ep932/EP932Controller.h \
+  drivers/video/hdmi/ep932/EP932ERegDef.h \
+  drivers/video/hdmi/ep932/EP932_If.h \
+  drivers/video/hdmi/ep932/EP932RegDef.h \
+  drivers/video/hdmi/ep932/HDCP.h \
+  drivers/video/hdmi/ep932/EP932SettingsData.h \
+
+drivers/video/hdmi/ep932/EP932Controller.o: $(deps_drivers/video/hdmi/ep932/EP932Controller.o)
+
+$(deps_drivers/video/hdmi/ep932/EP932Controller.o):
diff --git a/drivers/video/hdmi/ep932/.EP932SettingsData.o.cmd b/drivers/video/hdmi/ep932/.EP932SettingsData.o.cmd
new file mode 100644
index 0000000..423c065
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.EP932SettingsData.o.cmd
@@ -0,0 +1,9 @@
+cmd_drivers/video/hdmi/ep932/EP932SettingsData.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.EP932SettingsData.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(EP932SettingsData)"  -D"KBUILD_MODNAME=KBUILD_STR(EP932SettingsData)"  -c -o drivers/video/hdmi/ep932/EP932SettingsData.o drivers/video/hdmi/ep932/EP932SettingsData.c
+
+deps_drivers/video/hdmi/ep932/EP932SettingsData.o := \
+  drivers/video/hdmi/ep932/EP932SettingsData.c \
+  drivers/video/hdmi/ep932/EP932SettingsData.h \
+
+drivers/video/hdmi/ep932/EP932SettingsData.o: $(deps_drivers/video/hdmi/ep932/EP932SettingsData.o)
+
+$(deps_drivers/video/hdmi/ep932/EP932SettingsData.o):
diff --git a/drivers/video/hdmi/ep932/.EP932_If.o.cmd b/drivers/video/hdmi/ep932/.EP932_If.o.cmd
new file mode 100644
index 0000000..9371609
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.EP932_If.o.cmd
@@ -0,0 +1,469 @@
+cmd_drivers/video/hdmi/ep932/EP932_If.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.EP932_If.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(EP932_If)"  -D"KBUILD_MODNAME=KBUILD_STR(EP932_If)"  -c -o drivers/video/hdmi/ep932/EP932_If.o drivers/video/hdmi/ep932/EP932_If.c
+
+deps_drivers/video/hdmi/ep932/EP932_If.o := \
+  drivers/video/hdmi/ep932/EP932_If.c \
+    $(wildcard include/config/hdmi/ep932/i2c.h) \
+  drivers/video/hdmi/ep932/EP932_If.h \
+  drivers/video/hdmi/ep932/EP932api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+    $(wildcard include/config/mmu.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/discontigmem.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/linkage.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+    $(wildcard include/config/pm.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/type.h \
+  drivers/video/hdmi/ep932/EP932RegDef.h \
+  drivers/video/hdmi/ep932/DDC_If.h \
+  drivers/video/hdmi/ep932/EP932SettingsData.h \
+
+drivers/video/hdmi/ep932/EP932_If.o: $(deps_drivers/video/hdmi/ep932/EP932_If.o)
+
+$(deps_drivers/video/hdmi/ep932/EP932_If.o):
diff --git a/drivers/video/hdmi/ep932/.EP932api.o.cmd b/drivers/video/hdmi/ep932/.EP932api.o.cmd
new file mode 100644
index 0000000..5e620b7
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.EP932api.o.cmd
@@ -0,0 +1,482 @@
+cmd_drivers/video/hdmi/ep932/EP932api.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.EP932api.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(EP932api)"  -D"KBUILD_MODNAME=KBUILD_STR(EP932api)"  -c -o drivers/video/hdmi/ep932/EP932api.o drivers/video/hdmi/ep932/EP932api.c
+
+deps_drivers/video/hdmi/ep932/EP932api.o := \
+  drivers/video/hdmi/ep932/EP932api.c \
+    $(wildcard include/config/hdmi/ep932/reset.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/stddef.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+    $(wildcard include/config/smp.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/delay.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/generic/gpio.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/gpio.h \
+  arch/arm/mach-imapx200/include/mach/gpio.h \
+    $(wildcard include/config/imap/gpio/space.h) \
+  include/asm-generic/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/gpio/sysfs.h) \
+    $(wildcard include/config/have/gpio/lib.h) \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio_api.h \
+  drivers/video/hdmi/ep932/EP932Controller.h \
+  drivers/video/hdmi/ep932/EP932ERegDef.h \
+  drivers/video/hdmi/ep932/EP932_If.h \
+  drivers/video/hdmi/ep932/EP932api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+    $(wildcard include/config/mmu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/discontigmem.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+    $(wildcard include/config/pm.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/type.h \
+  drivers/video/hdmi/ep932/EP932RegDef.h \
+  drivers/video/hdmi/ep932/HDCP.h \
+
+drivers/video/hdmi/ep932/EP932api.o: $(deps_drivers/video/hdmi/ep932/EP932api.o)
+
+$(deps_drivers/video/hdmi/ep932/EP932api.o):
diff --git a/drivers/video/hdmi/ep932/.Edid.o.cmd b/drivers/video/hdmi/ep932/.Edid.o.cmd
new file mode 100644
index 0000000..7d01476
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.Edid.o.cmd
@@ -0,0 +1,465 @@
+cmd_drivers/video/hdmi/ep932/Edid.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.Edid.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(Edid)"  -D"KBUILD_MODNAME=KBUILD_STR(Edid)"  -c -o drivers/video/hdmi/ep932/Edid.o drivers/video/hdmi/ep932/Edid.c
+
+deps_drivers/video/hdmi/ep932/Edid.o := \
+  drivers/video/hdmi/ep932/Edid.c \
+  drivers/video/hdmi/ep932/Edid.h \
+  drivers/video/hdmi/ep932/EP932api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+    $(wildcard include/config/mmu.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/discontigmem.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/linkage.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+    $(wildcard include/config/pm.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/type.h \
+
+drivers/video/hdmi/ep932/Edid.o: $(deps_drivers/video/hdmi/ep932/Edid.o)
+
+$(deps_drivers/video/hdmi/ep932/Edid.o):
diff --git a/drivers/video/hdmi/ep932/.HDCP.o.cmd b/drivers/video/hdmi/ep932/.HDCP.o.cmd
new file mode 100644
index 0000000..918463b
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.HDCP.o.cmd
@@ -0,0 +1,468 @@
+cmd_drivers/video/hdmi/ep932/HDCP.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.HDCP.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(HDCP)"  -D"KBUILD_MODNAME=KBUILD_STR(HDCP)"  -c -o drivers/video/hdmi/ep932/HDCP.o drivers/video/hdmi/ep932/HDCP.c
+
+deps_drivers/video/hdmi/ep932/HDCP.o := \
+  drivers/video/hdmi/ep932/HDCP.c \
+  drivers/video/hdmi/ep932/HDCP.h \
+  drivers/video/hdmi/ep932/EP932_If.h \
+  drivers/video/hdmi/ep932/EP932api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+    $(wildcard include/config/mmu.h) \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/discontigmem.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/linkage.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+    $(wildcard include/config/pm.h) \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/type.h \
+  drivers/video/hdmi/ep932/EP932RegDef.h \
+  drivers/video/hdmi/ep932/DDC_If.h \
+
+drivers/video/hdmi/ep932/HDCP.o: $(deps_drivers/video/hdmi/ep932/HDCP.o)
+
+$(deps_drivers/video/hdmi/ep932/HDCP.o):
diff --git a/drivers/video/hdmi/ep932/.built-in.o.cmd b/drivers/video/hdmi/ep932/.built-in.o.cmd
new file mode 100644
index 0000000..792adec
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.built-in.o.cmd
@@ -0,0 +1 @@
+cmd_drivers/video/hdmi/ep932/built-in.o :=  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-ld -EL    -r -o drivers/video/hdmi/ep932/built-in.o drivers/video/hdmi/ep932/imap_HDMI.o drivers/video/hdmi/ep932/EP932api.o drivers/video/hdmi/ep932/DDC_If.o drivers/video/hdmi/ep932/EP932Controller.o drivers/video/hdmi/ep932/Edid.o drivers/video/hdmi/ep932/EP932_If.o drivers/video/hdmi/ep932/EP932SettingsData.o drivers/video/hdmi/ep932/HDCP.o 
diff --git a/drivers/video/hdmi/ep932/.imap_HDMI.o.cmd b/drivers/video/hdmi/ep932/.imap_HDMI.o.cmd
new file mode 100644
index 0000000..d92e4b0
--- /dev/null
+++ b/drivers/video/hdmi/ep932/.imap_HDMI.o.cmd
@@ -0,0 +1,569 @@
+cmd_drivers/video/hdmi/ep932/imap_HDMI.o := /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/arm-eabi-gcc -Wp,-MD,drivers/video/hdmi/ep932/.imap_HDMI.o.d  -nostdinc -isystem /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include -Iinclude  -I/home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include -include include/linux/autoconf.h -D__KERNEL__ -mlittle-endian -Iarch/arm/mach-imapx200/include -Iarch/arm/plat-imap/include -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -Os -marm -mabi=aapcs-linux -mno-thumb-interwork -funwind-tables -D__LINUX_ARM_ARCH__=6 -march=armv6k -mtune=arm1136j-s -msoft-float -Uarm -Wframe-larger-than=1024 -fno-stack-protector -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fno-dwarf2-cfi-asm -fconserve-stack   -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(imap_HDMI)"  -D"KBUILD_MODNAME=KBUILD_STR(imap_HDMI)"  -c -o drivers/video/hdmi/ep932/imap_HDMI.o drivers/video/hdmi/ep932/imap_HDMI.c
+
+deps_drivers/video/hdmi/ep932/imap_HDMI.o := \
+  drivers/video/hdmi/ep932/imap_HDMI.c \
+    $(wildcard include/config/fake/pm.h) \
+    $(wildcard include/config/ig/lcd/backlight.h) \
+    $(wildcard include/config/hdmi/ep932/power.h) \
+    $(wildcard include/config/hdmi/ep932/int.h) \
+    $(wildcard include/config/ui/map/color.h) \
+    $(wildcard include/config/double/display/mode.h) \
+    $(wildcard include/config/panauision/mode.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/hdmi/ep932/i2c.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/sysfs.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/stddef.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/enable/warn/deprecated.h) \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arch/supports/optimized/inlining.h) \
+    $(wildcard include/config/optimize/inlining.h) \
+  include/linux/compiler-gcc4.h \
+  include/linux/poison.h \
+  include/linux/prefetch.h \
+  include/linux/types.h \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/lbdaf.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/linux/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/posix_types.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/processor.h \
+    $(wildcard include/config/mmu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+    $(wildcard include/config/arm/thumb.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hwcap.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/system.h \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+    $(wildcard include/config/cpu/32v6k.h) \
+  include/linux/linkage.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/linkage.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+    $(wildcard include/config/x86.h) \
+  include/linux/typecheck.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irqflags.h \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/stat.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/spinlock/sleep.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/ring/buffer.h) \
+    $(wildcard include/config/numa.h) \
+  /home/infotm-sqa/helen_p7901/trunk/android-2.2_release/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin/../lib/gcc/arm-eabi/4.4.0/include/stdarg.h \
+  include/linux/bitops.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+    $(wildcard include/config/generic/find/last/bit.h) \
+    $(wildcard include/config/generic/find/next/bit.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bitops.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/ratelimit.h \
+  include/linux/param.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/param.h \
+    $(wildcard include/config/hz.h) \
+  include/linux/dynamic_debug.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/debug/bugverbose.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/div64.h \
+  include/linux/seqlock.h \
+  include/linux/spinlock.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+    $(wildcard include/config/preempt.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  include/linux/thread_info.h \
+    $(wildcard include/config/compat.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/arm/thumbee.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+  include/linux/stringify.h \
+  include/linux/bottom_half.h \
+  include/linux/spinlock_types.h \
+  include/linux/spinlock_types_up.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+    $(wildcard include/config/generic/hardirqs.h) \
+  include/linux/spinlock_up.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/atomic.h \
+  include/asm-generic/atomic-long.h \
+  include/linux/spinlock_api_up.h \
+  include/linux/math64.h \
+  include/linux/kmod.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/kmemcheck.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/debug/vm.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/arch/populates/node/map.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/cgroup/mem/res/ctlr.h) \
+    $(wildcard include/config/have/memory/present.h) \
+    $(wildcard include/config/need/node/memmap/size.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/have/arch/early/pfn/to/nid.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/nodes/span/other/nodes.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/wait.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/current.h \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+  include/linux/init.h \
+    $(wildcard include/config/hotplug.h) \
+  include/linux/nodemask.h \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/string.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/bounds.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v3.h) \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/glue.h \
+    $(wildcard include/config/cpu/arm610.h) \
+    $(wildcard include/config/cpu/arm710.h) \
+    $(wildcard include/config/cpu/abrt/lv4t.h) \
+    $(wildcard include/config/cpu/abrt/ev4.h) \
+    $(wildcard include/config/cpu/abrt/ev4t.h) \
+    $(wildcard include/config/cpu/abrt/ev5tj.h) \
+    $(wildcard include/config/cpu/abrt/ev5t.h) \
+    $(wildcard include/config/cpu/abrt/ev6.h) \
+    $(wildcard include/config/cpu/abrt/ev7.h) \
+    $(wildcard include/config/cpu/pabrt/legacy.h) \
+    $(wildcard include/config/cpu/pabrt/v6.h) \
+    $(wildcard include/config/cpu/pabrt/v7.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/memory.h \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/dram/base.h) \
+  include/linux/const.h \
+  arch/arm/mach-imapx200/include/mach/memory.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+  include/asm-generic/getorder.h \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+  include/linux/notifier.h \
+  include/linux/errno.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/errno.h \
+  include/asm-generic/errno.h \
+  include/asm-generic/errno-base.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/generic/spinlock.h) \
+  include/linux/rwsem-spinlock.h \
+  include/linux/srcu.h \
+  include/linux/topology.h \
+    $(wildcard include/config/sched/smt.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+    $(wildcard include/config/disable/obsolete/cpumask/functions.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/use/generic/smp/helpers.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/topology.h \
+  include/asm-generic/topology.h \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/elf.h \
+  include/linux/elf-em.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/elf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/user.h \
+  include/linux/kobject.h \
+  include/linux/sysfs.h \
+  include/linux/kref.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/tracepoint.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/tree/preempt/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+  include/linux/completion.h \
+  include/linux/rcutree.h \
+    $(wildcard include/config/no/hz.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/local.h \
+  include/asm-generic/local.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/have/legacy/per/cpu/area.h) \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+    $(wildcard include/config/debug/kmemleak.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/slab.h \
+    $(wildcard include/config/slab/debug.h) \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+    $(wildcard include/config/debug/slab.h) \
+  include/linux/slub_def.h \
+    $(wildcard include/config/slub/stats.h) \
+    $(wildcard include/config/slub/debug.h) \
+    $(wildcard include/config/kmemtrace.h) \
+  include/linux/workqueue.h \
+  include/linux/timer.h \
+    $(wildcard include/config/timer/stats.h) \
+    $(wildcard include/config/debug/objects/timers.h) \
+  include/linux/ktime.h \
+    $(wildcard include/config/ktime/scalar.h) \
+  include/linux/jiffies.h \
+  include/linux/timex.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/timex.h \
+  arch/arm/mach-imapx200/include/mach/timex.h \
+    $(wildcard include/config/cpu/s3c6400.h) \
+    $(wildcard include/config/cpu/s3c6410.h) \
+    $(wildcard include/config/cpu/s3c2450.h) \
+    $(wildcard include/config/cpu/s3c2416.h) \
+    $(wildcard include/config/cpu/s3c2443.h) \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects/free.h) \
+  include/linux/kmemtrace.h \
+  include/trace/events/kmem.h \
+  include/trace/define_trace.h \
+  include/linux/kmemleak.h \
+  include/linux/pfn.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/percpu.h \
+  include/asm-generic/percpu.h \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+  include/trace/events/module.h \
+  include/linux/delay.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/delay.h \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+  include/linux/i2c-id.h \
+  include/linux/mod_devicetable.h \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/devtmpfs.h) \
+  include/linux/ioport.h \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/pm/runtime.h) \
+  include/linux/semaphore.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/sched.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/detect/softlockup.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/inotify/user.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/user/sched.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/cc/stackprotector.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/have/unstable/sched/clock.h) \
+    $(wildcard include/config/stack/growsup.h) \
+    $(wildcard include/config/debug/stack/usage.h) \
+    $(wildcard include/config/group/sched.h) \
+    $(wildcard include/config/mm/owner.h) \
+  include/linux/capability.h \
+    $(wildcard include/config/security/file/capabilities.h) \
+  include/linux/rbtree.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/want/page/debug/flags.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/proc/fs.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+  include/linux/auxvec.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/auxvec.h \
+  include/linux/prio_tree.h \
+  include/linux/page-debug-flags.h \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/page/debug/something/else.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/cputime.h \
+  include/asm-generic/cputime.h \
+  include/linux/sem.h \
+  include/linux/ipc.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ipcbuf.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sembuf.h \
+  include/linux/signal.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/signal.h \
+  include/asm-generic/signal-defs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/sigcontext.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/siginfo.h \
+  include/asm-generic/siginfo.h \
+  include/linux/path.h \
+  include/linux/pid.h \
+  include/linux/proportions.h \
+  include/linux/percpu_counter.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+  include/linux/rculist.h \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/pi/list.h) \
+  include/linux/resource.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/latencytop.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+    $(wildcard include/config/security.h) \
+  include/linux/key.h \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/linux/selinux.h \
+    $(wildcard include/config/security/selinux.h) \
+  include/linux/aio.h \
+  include/linux/aio_abi.h \
+  include/linux/uio.h \
+  include/linux/kthread.h \
+  include/linux/err.h \
+  include/linux/platform_device.h \
+  include/linux/fs.h \
+    $(wildcard include/config/dnotify.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/inotify.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/debug/writecount.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/fs/xip.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/limits.h \
+  include/linux/ioctl.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/radix-tree.h \
+  include/linux/fiemap.h \
+  include/linux/quota.h \
+  include/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/nfs.h \
+  include/linux/sunrpc/msg_prot.h \
+  include/linux/inet.h \
+  include/linux/fcntl.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/fcntl.h \
+  include/asm-generic/fcntl.h \
+  include/linux/cdev.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/debug/shirq.h) \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/linux/hardirq.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/ftrace/nmi/enter.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hardirq.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irq.h \
+  arch/arm/mach-imapx200/include/mach/irqs.h \
+  include/linux/irq_cpustat.h \
+  include/linux/poll.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/poll.h \
+  include/asm-generic/poll.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/uaccess.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/unified.h \
+    $(wildcard include/config/arm/asm/unified.h) \
+  include/linux/fb.h \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/backlight.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/io.h \
+  arch/arm/mach-imapx200/include/mach/io.h \
+  arch/arm/mach-imapx200/include/mach/hardware.h \
+    $(wildcard include/config/no/multiword/io.h) \
+  arch/arm/mach-imapx200/include/mach/imap_addr.h \
+  arch/arm/plat-imap/include/plat/imapx.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sysmgr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_dma.h \
+  arch/arm/mach-imapx200/include/mach/imapx_nand.h \
+  arch/arm/mach-imapx200/include/mach/imapx_sdio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cf.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbhost.h \
+  arch/arm/mach-imapx200/include/mach/imapx_usbotg.h \
+  arch/arm/mach-imapx200/include/mach/imapx_intr.h \
+  arch/arm/mach-imapx200/include/mach/imapx_cam.h \
+  arch/arm/mach-imapx200/include/mach/imapx_lcd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_mac.h \
+  arch/arm/mach-imapx200/include/mach/imapx_graphic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_venc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_vdec.h \
+  arch/arm/mach-imapx200/include/mach/imapx_timer.h \
+  arch/arm/mach-imapx200/include/mach/imapx_pwm.h \
+  arch/arm/mach-imapx200/include/mach/imapx_wdog.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iic.h \
+  arch/arm/mach-imapx200/include/mach/imapx_rtc.h \
+  arch/arm/mach-imapx200/include/mach/imapx_iis.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ac97.h \
+  arch/arm/mach-imapx200/include/mach/imapx_spi.h \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio.h \
+  arch/arm/mach-imapx200/include/mach/imapx_uart.h \
+  arch/arm/mach-imapx200/include/mach/imapx_keybd.h \
+  arch/arm/mach-imapx200/include/mach/imapx_ps2.h \
+  arch/arm/mach-imapx200/include/mach/imapx_idsp.h \
+  arch/arm/mach-imapx200/include/mach/imapx_base_reg.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/generic/gpio.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/gpio.h \
+  arch/arm/mach-imapx200/include/mach/gpio.h \
+    $(wildcard include/config/imap/gpio/space.h) \
+  include/asm-generic/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/gpio/sysfs.h) \
+    $(wildcard include/config/have/gpio/lib.h) \
+  arch/arm/mach-imapx200/include/mach/imapx_gpio_api.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/mach/irq.h \
+  include/linux/irq.h \
+    $(wildcard include/config/s390.h) \
+    $(wildcard include/config/irq/per/cpu.h) \
+    $(wildcard include/config/irq/release/method.h) \
+    $(wildcard include/config/intr/remap.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/sparse/irq.h) \
+    $(wildcard include/config/numa/irq/desc.h) \
+    $(wildcard include/config/generic/hardirqs/no//do/irq.h) \
+    $(wildcard include/config/cpumasks/offstack.h) \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  /home/infotm-sqa/android_release/android-linux-2.6.32.9-union-release/arch/arm/include/asm/hw_irq.h \
+  drivers/video/hdmi/ep932/../../infotm/imapfb.h \
+    $(wildcard include/config/fb/imap/num.h) \
+    $(wildcard include/config/lcd/enable/irq.h) \
+  drivers/video/hdmi/ep932/imap_HDMI.h \
+  drivers/video/hdmi/ep932/EP932api.h \
+  drivers/video/hdmi/ep932/type.h \
+  drivers/video/hdmi/ep932/EP932Controller.h \
+  drivers/video/hdmi/ep932/EP932ERegDef.h \
+  drivers/video/hdmi/ep932/EP932_If.h \
+  drivers/video/hdmi/ep932/EP932RegDef.h \
+  drivers/video/hdmi/ep932/HDCP.h \
+
+drivers/video/hdmi/ep932/imap_HDMI.o: $(deps_drivers/video/hdmi/ep932/imap_HDMI.o)
+
+$(deps_drivers/video/hdmi/ep932/imap_HDMI.o):
diff --git a/drivers/video/hdmi/ep932/DDC_If.c b/drivers/video/hdmi/ep932/DDC_If.c
new file mode 100644
index 0000000..013baf3
--- /dev/null
+++ b/drivers/video/hdmi/ep932/DDC_If.c
@@ -0,0 +1,474 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED
+
+--------------------------------------------------------------------------------
+
+  File        :  DDC_If.c
+
+  Description :  EP932E DDC Interface
+
+\******************************************************************************/
+
+#include "DDC_If.h"
+
+//--------------------------------------------------------------------------------------------------
+
+#define HDCP_RX_ADDR          0x74     // HDCP RX Address
+#define EDID_ADDR       		0x50//0xA0     // EDID Address
+#define EDID_SEGMENT_PTR		0x60
+
+#define HDCP_RX_BKSV_ADDR       0x00     // HDCP RX, BKSV Register Address
+#define HDCP_RX_RI_ADDR         0x08     // HDCP RX, RI Register Address
+#define HDCP_RX_AKSV_ADDR       0x10     // HDCP RX, AKSV Register Address
+#define HDCP_RX_AINFO_ADDR      0x15     // HDCP RX, AINFO Register Address
+#define HDCP_RX_AN_ADDR         0x18     // HDCP RX, AN Register Address
+#define HDCP_RX_SHA1_HASH_ADDR  0x20     // HDCP RX, SHA-1 Hash Value Start Address
+#define HDCP_RX_BCAPS_ADDR      0x40     // HDCP RX, BCAPS Register Address
+#define HDCP_RX_BSTATUS_ADDR    0x41     // HDCP RX, BSTATUS Register Address
+#define HDCP_RX_KSV_FIFO_ADDR   0x43     // HDCP RX, KSV FIFO Start Address
+
+//--------------------------------------------------------------------------------------------------
+
+// Private Data
+
+//int i, j;
+SMBUS_STATUS status;
+
+unsigned char DDC_Data[128];
+unsigned char TempBit;
+
+// Private Functions
+SMBUS_STATUS DDC_Write(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size);
+SMBUS_STATUS DDC_Read(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size);
+//SMBUS_STATUS DDC_NoStop(unsigned char IICAddr, unsigned char ByteAddr, void *Data, unsigned int Size);
+//==================================================================================================
+//
+// Public Function Implementation
+//
+
+//--------------------------------------------------------------------------------------------------
+// Hardware Interface
+
+
+//--------------------------------------------------------------------------------------------------
+//
+// Downstream HDCP Control
+//
+
+unsigned char Downstream_Rx_read_BKSV(unsigned char *pBKSV)
+{
+	int i, j;
+	status = DDC_Read(HDCP_RX_ADDR, HDCP_RX_BKSV_ADDR, pBKSV, 5);
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: BKSV read - DN DDC %d\r\n", (int)status));
+		return 0;
+	}
+
+	i = 0;
+	j = 0;
+	while (i < 5) {
+		TempBit = 1;
+		while (TempBit) {
+			if (pBKSV[i] & TempBit) j++;
+			TempBit <<= 1;
+		}
+		i++;
+	}
+	if(j != 20) {
+		DBG_printf(("ERROR: BKSV read - Key Wrong\r\n"));
+		DBG_printf(("ERROR: BKSV=0x%02X,0x%02X,0x%02X,0x%02X,0x%02X\r\n", (unsigned int)pBKSV[0], (unsigned int)pBKSV[1], (unsigned int)pBKSV[2], (unsigned int)pBKSV[3], (unsigned int)pBKSV[4]));
+		return 0;
+	}
+	return 1;
+}
+
+unsigned char Downstream_Rx_BCAPS(void)
+{
+	DDC_Read(HDCP_RX_ADDR, HDCP_RX_BCAPS_ADDR, DDC_Data, 1);
+	return DDC_Data[0];
+}
+
+void Downstream_Rx_write_AINFO(char ainfo)
+{
+	DDC_Write(HDCP_RX_ADDR, HDCP_RX_AINFO_ADDR, &ainfo, 1);
+}
+
+void Downstream_Rx_write_AN(unsigned char *pAN)
+{
+	DDC_Write(HDCP_RX_ADDR, HDCP_RX_AN_ADDR, pAN, 8);
+}
+
+void Downstream_Rx_write_AKSV(unsigned char *pAKSV)
+{
+	DDC_Write(HDCP_RX_ADDR, HDCP_RX_AKSV_ADDR, pAKSV, 5);
+}
+
+unsigned char Downstream_Rx_read_RI(unsigned char *pRI)
+{
+	// Short Read
+	status = DDC_Read(HDCP_RX_ADDR, HDCP_RX_RI_ADDR, pRI, 2);
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: Rx Ri read - MCU IIC %d\r\n", (int)status));
+		return 0;
+	}
+	return 1;
+}
+
+void Downstream_Rx_read_BSTATUS(unsigned char *pBSTATUS)
+{
+	DDC_Read(HDCP_RX_ADDR, HDCP_RX_BSTATUS_ADDR, pBSTATUS, 2);
+}
+
+void Downstream_Rx_read_SHA1_HASH(unsigned char *pSHA)
+{
+	DDC_Read(HDCP_RX_ADDR, HDCP_RX_SHA1_HASH_ADDR, pSHA, 20);
+}
+
+// Retrive a 5 byte KSV at "Index" from FIFO
+unsigned char Downstream_Rx_read_KSV_FIFO(unsigned char *pBKSV, unsigned char Index, unsigned char DevCount)
+{
+	int i, j;
+
+	// Try not to re-read the previous KSV
+	if(Index == 0) { // Start
+		// Support a max 25 device count because of DDC_Data[] size is 128 byte
+		status = DDC_Read(HDCP_RX_ADDR, HDCP_RX_KSV_FIFO_ADDR, DDC_Data, min(DevCount, 25));
+	}
+	memcpy(pBKSV, DDC_Data+(Index*5), 5);
+
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: KSV FIFO read - DN DDC %d\r\n", (int)status));
+		return 0;
+	}
+
+	i = 0;
+	j = 0;
+	while (i < 5) {
+		TempBit = 1;
+		while (TempBit) {
+			if (pBKSV[i] & TempBit) j++;
+			TempBit <<= 1;
+		}
+		i++;
+	}
+	if(j != 20) {
+		DBG_printf(("ERROR: KSV FIFO read - Key Wrong\r\n"));
+		return 0;
+	}
+	return 1;
+}
+
+
+//--------------------------------------------------------------------------------------------------
+//
+// Downstream EDID Control
+//
+
+unsigned char Downstream_Rx_poll_EDID(void)
+{
+	// Read the EDID test
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with CSI2C ?????????????????????????????
+	// Without the Segment address implementation, it works normally.
+	// But, this must be implemented for ATC test.
+	//DDC_Data[0] = 0;	// Segment Pointer Address
+	//SMBUS_master_rw_synchronous(DDC_Bus, EDID_SEGMENT_PTR, DDC_Data, 1, SMBUS_SkipStop);
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+
+	// Base Address and Read 1
+	status = DDC_Read(EDID_ADDR, 0, DDC_Data, 1);
+
+	if(status != SMBUS_STATUS_Success) // can't read EDID
+	{
+		return 2;
+	}
+	if(DDC_Data[0] != 0x00)				// EDID header fail
+	{
+		return 2;
+	}
+	return 0;							// Read EDID success
+
+}
+
+EDID_STATUS Downstream_Rx_read_EDID(unsigned char *pEDID)
+{
+	int i;
+	unsigned char seg_ptr, BlockCount, Block1Found, ChkSum, sys_ram[2];
+
+	// =========================================================
+	// I. Read the block 0
+
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with CSI2C ?????????????????????????????
+	// Without the Segment address implementation, it works normally.
+	// But, this must be implemented for ATC test.
+	//DDC_Data[0] = 0;	// Segment Pointer Address
+	//SMBUS_master_rw_synchronous(DDC_Bus, EDID_SEGMENT_PTR, DDC_Data, 1, SMBUS_SkipStop);
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+
+	// Base Address and Read 128
+	//sys_ram[0] = 0;
+	//DDC_NoStop(EDID_SEGMENT_PTR, 0, sys_ram, 1);	// skip stop 
+
+	status = DDC_Read(EDID_ADDR, 0, pEDID, 128);
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: EDID b0 read - DN DDC %d\r\n", (int)status));
+		return status;
+	}
+	DBG_printf(("EDID b0 read:"));
+	for(i=0; i<128; ++i) {
+		if(i%16 == 0) DBG_printf(("\r\n"));
+		if(i%8 == 0) DBG_printf((" "));
+		DBG_printf(("0x%02X, ", (int)pEDID[i] ));
+	}
+	DBG_printf(("\r\n"));
+
+	if( (pEDID[0] != 0x00) ||
+	    (pEDID[1] != 0xFF) ||
+	    (pEDID[2] != 0xFF) ||
+	    (pEDID[3] != 0xFF) ||
+	    (pEDID[4] != 0xFF) ||
+	    (pEDID[5] != 0xFF) ||
+	    (pEDID[5] != 0xFF) ||
+	    (pEDID[7] != 0x00))
+	{
+		//return EDID_STATUS_NoAct;
+	}
+
+	// Check EDID
+	if(pEDID[126] > 8) {
+		DBG_printf(("ERROR: EDID Check failed, pEDID[126]=0x%02X > 8\n\r", (int)pEDID[126] ));
+		return EDID_STATUS_ExtensionOverflow;
+	}
+
+	// =========================================================
+	// II. Read other blocks and find Timing Extension Block
+
+	BlockCount = pEDID[126];
+	Block1Found = 0;
+	for (seg_ptr = 1; seg_ptr <= BlockCount; ++seg_ptr) {
+
+		/////////////////////////////////////////////////////////////////////////////////////////////////
+		// How to implement this with Customer's I2C ?????????????????????????????
+		// Without the Segment address implementation, it works normally.
+		// But, this must be implemented for ATC test.
+		//DDC_Data[0] = seg_ptr >> 1;	// Segment Pointer Address
+		//SMBUS_master_rw_synchronous(DDC_Bus, EDID_SEGMENT_PTR, DDC_Data, 1, SMBUS_SkipStop);
+		/////////////////////////////////////////////////////////////////////////////////////////////////
+
+		// Base Address and Read 128
+		//sys_ram[0] = seg_ptr >> 1;	// Segment Pointer Address
+		//DDC_NoStop(EDID_SEGMENT_PTR, 0, sys_ram, 1);	// skip stop 
+
+		status = DDC_Read(EDID_ADDR, (seg_ptr & 0x01) << 7, DDC_Data, 128);
+		if(status != SMBUS_STATUS_Success) {
+			DBG_printf(("ERROR: EDID bi read - DN DDC %d\r\n", (int)status));
+			return status;
+		}
+
+		if(DDC_Data[0] == 0x02 && Block1Found == 0) {
+			Block1Found = 1;
+			memcpy(&pEDID[128], DDC_Data, 128);
+		}
+
+		DBG_printf(("EDID b%d read:", (int)seg_ptr));
+		for(i=0; i<128; ++i) {
+			if(i%16 == 0) DBG_printf(("\r\n"));
+			if(i%8 == 0) DBG_printf((" "));
+			DBG_printf(("0x%02X, ", (int)DDC_Data[i] ));
+		}
+		DBG_printf(("\r\n"));
+	}
+
+	// Check CheckSum
+	ChkSum = 0;
+	for(i=0; i<((Block1Found)?256:128); ++i) {
+		ChkSum += pEDID[i];
+	}
+	if(ChkSum != 0) {
+		return EDID_STATUS_ChecksumError;
+	}
+	if(Block1Found) {
+		pEDID[126] = 1;
+	}
+	else {
+		pEDID[126] = 0;
+	}
+	return EDID_STATUS_Success;
+}
+
+//==================================================================================================
+//
+// Private Functions
+//
+
+SMBUS_STATUS DDC_Write(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size)
+{
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with Customer's I2C ?????????????????????????????
+	// return 0; for success
+	// return 2; for No_ACK
+	// return 4; for Arbitration
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+#if 0
+	int result = 1;
+	int i;
+ 	unsigned long to, tn;
+	to = get_ticks();
+
+	// need to use customer's I2C  function
+	//result = I2C_WriteReg_EP932M(IICAddr, ByteAddr, Data, Size);
+
+	if(iic_init(0,1,IICAddr,0,1,0)== 0)
+		return 1;
+
+	for(i = 0;i < Size;i++)
+	{
+		while(iic_write(0,ByteAddr+i,Data[i]) == 0)
+		{
+			 tn = get_ticks();
+			 if(tn > to + 500000) break;
+		}
+	}
+	return 0;
+#endif
+
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(Size + 1, GFP_KERNEL);
+	unsigned int i;
+
+	buf[0] = ByteAddr;
+	for(i=0;i<Size;i++)
+		buf[i + 1] = Data[i];
+
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = Size + 1,
+			.buf            = buf,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[DDC_Write]: unable to allocate memory for EDID.\n");
+		return -1; 
+	}
+
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_EP932_SOCKET_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[DDC_Write]: can't get i2c adapter\n");
+
+		return -1; 
+	}
+
+	if (i2c_transfer(adapter, msgs, 1) != 1)
+		return -1; 
+
+	kfree(buf);
+
+	return 0;
+
+}
+
+SMBUS_STATUS DDC_Read(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size)
+{
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with CSI2C ?????????????????????????????
+	// return 0; for success
+	// return 2; for No_ACK
+	// return 4; for Arbitration
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+#if 0
+	int result = 1;
+	int i;
+ 	unsigned long to, tn;
+	to = get_ticks();
+
+	// need to use customer's I2C  function
+	//result = I2C_ReadReg_EP932M(IICAddr, ByteAddr, Data, Size);
+	if(iic_init(0,1,IICAddr,0,1,0)== 0)
+		return 1;
+
+	for(i=0;i<Size;i++)
+	{
+		while(iic_read(0,ByteAddr+i,&Data[i]) == 0)
+		{
+			 tn = get_ticks();
+			 if(tn > to + 500000) break;
+		}
+	}
+
+	return 0;
+#endif
+
+	struct i2c_adapter *adapter;
+	unsigned int i;
+	unsigned char *buf = kmalloc(Size, GFP_KERNEL);
+	struct i2c_msg msgs1[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = 1,
+			.buf            = &ByteAddr,
+		}
+	};
+
+	struct i2c_msg msgs2[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = I2C_M_RD,
+			.len            = Size,
+			.buf            = Data,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[DDC_Read]: unable to allocate memory for EDID.\n");
+		return -1; 
+	}
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_EP932_SOCKET_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[DDC_Read]: can't get i2c adapter\n");
+
+		return -1; 
+	}
+
+	if (i2c_transfer(adapter, msgs1, 1) != 1)
+		return -1; 
+
+	if (i2c_transfer(adapter, msgs2, 1) != 1)
+		return -1; 
+
+	kfree(buf);
+
+	return 0;
+
+}
+
+/*
+SMBUS_STATUS DDC_NoStop(unsigned char IICAddr, unsigned char ByteAddr, void *Data, unsigned int Size)
+{
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with CSI2C ?????????????????????????????
+	// return 0; for success
+	// return 2; for No_ACK
+	// return 4; for Arbitration
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	int result = 1;
+	
+	// need to use customer's I2C  function
+	//result = I2C_ReadReg_EP932M(IICAddr, ByteAddr, Data, Size);
+	
+	return result;
+}
+*/
diff --git a/drivers/video/hdmi/ep932/DDC_If.h b/drivers/video/hdmi/ep932/DDC_If.h
new file mode 100644
index 0000000..2ec10c4
--- /dev/null
+++ b/drivers/video/hdmi/ep932/DDC_If.h
@@ -0,0 +1,83 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+  File        :  DDC_If.h 
+
+  Description :  Head file of DDC Interface  
+
+\******************************************************************************/
+
+#ifndef DDC_IF_H
+#define DDC_IF_H
+
+//#include "type.h"
+
+//#include "EPcsapi.h"
+#include "EP932api.h"
+
+//==================================================================================================
+//
+// Protected Data Member
+//
+extern SMBUS_STATUS status;
+extern unsigned char DDC_Data[128]; // The DDC Buffer
+
+// EDID status error code
+typedef enum {
+	// Master
+	EDID_STATUS_Success = 0x00,
+	EDID_STATUS_Pending,//	SMBUS_STATUS_Abort,
+	EDID_STATUS_NoAct = 0x02,
+	EDID_STATUS_TimeOut,
+	EDID_STATUS_ArbitrationLoss = 0x04,
+	EDID_STATUS_ExtensionOverflow,
+	EDID_STATUS_ChecksumError
+} EDID_STATUS;
+
+
+//==================================================================================================
+//
+// Public Functions
+//
+
+//--------------------------------------------------------------------------------------------------
+//
+// General
+//
+
+// All Interface Inital
+//extern void DDC_If_Initial(CSI2C_HANDLE E_handle, CSI2C_HANDLE H_handle);
+
+
+//--------------------------------------------------------------------------------------------------
+//
+// Downstream HDCP Control Interface
+//
+
+extern unsigned char Downstream_Rx_read_BKSV(unsigned char *pBKSV);
+extern unsigned char Downstream_Rx_BCAPS(void);
+extern void Downstream_Rx_write_AINFO(char ainfo);
+extern void Downstream_Rx_write_AN(unsigned char *pAN);
+extern void Downstream_Rx_write_AKSV(unsigned char *pAKSV);
+extern unsigned char Downstream_Rx_read_RI(unsigned char *pRI);
+extern void Downstream_Rx_read_BSTATUS(unsigned char *pBSTATUS);
+extern void Downstream_Rx_read_SHA1_HASH(unsigned char *pSHA);
+extern unsigned char Downstream_Rx_read_KSV_FIFO(unsigned char *pBKSV, unsigned char Index, unsigned char DevCount);
+
+
+//--------------------------------------------------------------------------------------------------
+//
+// Downstream EDID Control Interface
+//
+
+extern unsigned char Downstream_Rx_poll_EDID(void);
+extern EDID_STATUS Downstream_Rx_read_EDID(unsigned char *pEDID);
+
+
+#endif // DDC_IF_H
+
+
diff --git a/drivers/video/hdmi/ep932/DDC_If.o b/drivers/video/hdmi/ep932/DDC_If.o
new file mode 100644
index 0000000..c171289
Binary files /dev/null and b/drivers/video/hdmi/ep932/DDC_If.o differ
diff --git a/drivers/video/hdmi/ep932/EP932Controller.c b/drivers/video/hdmi/ep932/EP932Controller.c
new file mode 100644
index 0000000..7e95375
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932Controller.c
@@ -0,0 +1,1152 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005 
+                           ALL RIGHTS RESERVED 
+ 
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932Controller.c 
+
+  Description :  EP932Controller program 
+                 Control SFR directory and use HCI functions 
+
+  Codeing     :  Shihken
+
+  2008.09.04  :  1) Set the Version Number to 0.27 Beta 27
+                 2) Fix the problem that EP932E send YUV format in DVI mode.
+
+  2008.09.27  :  1) Set the Version Number to 0.28 Beta 28
+                 2) Fix the problem that some Registers are not initialized.
+                 3) Set Link_Status to No-ACK when there is no connection.
+
+  2008.11.10  :  1) Set the Version Number to 0.31 Beta 31
+                 2) Fix the interlace polarity problem in Embedded Sync Mode.
+
+  2008.12.08  :  1) Set the Version Number to 0.32 Beta 32
+                 2) Fix the Flat bits assignment in Layout 0.
+                 3) Improve the IIC Slave speed and support EPF021.
+
+  2008.12.19  :  1) Set the Version Number to 0.33 Beta 33
+                 2) Fix the Front Porch timing in Embedded Sync Mode with Mux Mode.
+
+  2009.02.05  :  1) Set the Version Number to 0.34 Beta 34
+                 2) Improve the EDID gathering algorithm.
+
+  2009.03.19  :  1) Set the Version Number to 0.35 Beta 35
+                 2) Set CS Audio Length to default.
+
+  2009.05.18  :  1) Set the Version Number to 0.36 Beta 36
+                 2) Use A_MUTE and CTS_M instead of disabling all audio relatived packet.
+
+\******************************************************************************/
+
+
+#include "EP932api.h"
+#include "Edid.h"
+#include "DDC_If.h"
+#include "EP932Controller.h"
+#include "EP932SettingsData.h"
+
+
+//
+// Defines
+//
+
+//#define Enable_HDCP
+
+#define AV_STABLE_TIME            1000
+
+#define CmpInTolarence(Value, Compared, Tolarence) ((Value >= (Compared - Tolarence)) && (Value <= (Compared + Tolarence)))
+
+#ifndef min
+#define min(a,b) (a<b)? a:b
+#endif
+
+typedef enum {
+	TXS_Search_EDID,
+	TXS_Wait_Upstream,
+	TXS_Stream,
+	TXS_HDCP
+} TX_STATE;
+
+// HDCP Key  
+unsigned char HDCP_Key[64][8];
+
+//
+// Global State and Flags
+//
+EP932C_REGISTER_MAP EP932C_Registers;
+
+/*
+// System flags
+bdata unsigned char EP932C_Flags[2];
+
+//sbit Event_HDMI_Int = EP932C_Flags[0]^0;
+// ...
+
+sbit is_Cap_HDMI = EP932C_Flags[0]^3;
+sbit is_Cap_YCC444 = EP932C_Flags[0]^4;
+sbit is_Cap_YCC422 = EP932C_Flags[0]^5;
+sbit is_Connected = EP932C_Flags[0]^6;
+sbit is_ReceiverSense = EP932C_Flags[0]^7;
+
+sbit is_TimingChanging = EP932C_Flags[1]^0;
+sbit is_VideoChanging = EP932C_Flags[1]^1;
+sbit is_AudioChanging = EP932C_Flags[1]^2;
+sbit is_HDCP_Info_BKSV_Rdy = EP932C_Flags[1]^3;
+sbit is_Hot_Plug = EP932C_Flags[1]^4;
+*/
+
+unsigned char is_Cap_HDMI;
+unsigned char is_Cap_YCC444;
+unsigned char is_Cap_YCC422;
+unsigned char is_Connected;
+unsigned char is_ReceiverSense;
+
+unsigned char is_TimingChanging;
+unsigned char is_VideoChanging;
+unsigned char is_AudioChanging;
+unsigned char is_HDCP_Info_BKSV_Rdy;
+unsigned char is_Hot_Plug;
+
+//
+// Global Data
+//
+
+// Temp Data
+unsigned char ChkSum, VC_Temp, ConnectionState;
+//int i;
+
+unsigned char HTPLG_NOW = 0, HTPLG_LAST = 0;
+
+
+// System Data
+TX_STATE TX_State;
+unsigned int HTP_TimeCount, VideoChg_TimeCount, AudioChg_TimeCount, ReadEDID_TimeCount;
+unsigned char Process_Dispatch_ID;
+
+unsigned char HP_ChangeCount, RSEN_ChangeCount, Backup_Analog_Test_Control;
+
+VDO_PARAMS Video_Params;
+ADO_PARAMS Audio_Params;
+unsigned char Gamut_Packet_Header_Backup[3];
+
+// Register
+PEP932C_REGISTER_MAP pEP932C_Registers;
+
+//
+// Private Functions
+//
+
+void EP932Controller_Reset(void);
+
+void TXS_RollBack_Wait_Upstream(void);
+void TXS_RollBack_Stream(void);
+void TXS_RollBack_HDCP(void);
+
+// Hardware
+void ReadInterruptFlags(void);
+//void On_HDMI_Int();
+
+EP932C_CALLBACK EP932C_GenerateInt;
+
+//--------------------------------------------------------------------------------------------------------------------
+
+void EP932Controller_Initial(PEP932C_REGISTER_MAP pEP932C_RegMap, EP932C_CALLBACK IntCall)
+{
+	// Save the Logical Hardware Assignment
+	pEP932C_Registers = pEP932C_RegMap;
+	EP932C_GenerateInt = IntCall;
+
+	// EP932 Reset Control
+	EP_EP932M_Reset();
+	EP932_EnableHPInit();
+	
+	// Initial IIC	   
+	EP932_If_Initial();
+
+	// Reset Variables
+	// bit
+	is_Cap_HDMI = 0;
+	is_Cap_YCC444 = is_Cap_YCC422 = 0;
+	is_Connected = 0;
+	is_VideoChanging = 0;
+	is_AudioChanging = 0;
+	// data
+	TX_State = TXS_Search_EDID;
+	HTP_TimeCount = 0;
+	Process_Dispatch_ID = 0;
+	VideoChg_TimeCount = 0;
+	AudioChg_TimeCount = 0;
+	ReadEDID_TimeCount = 0;
+	HP_ChangeCount = 0;
+	RSEN_ChangeCount = 0; 
+	memset(Gamut_Packet_Header_Backup, 0, 3);
+
+	// Reset all EP932C registers
+	memset(pEP932C_Registers, 0, sizeof(EP932C_REGISTER_MAP));
+	pEP932C_Registers->Video_Interface[0] = 0x80;
+	pEP932C_Registers->Power_Control = EP932E_Power_Control__PD_HDMI;
+	pEP932C_Registers->Audio_Interface = 0x10; // 2 Channel audio
+
+	// Update Version Registers
+	pEP932C_Registers->VendorID = 0x177A;
+	pEP932C_Registers->DeviceID = 0x0932;
+	pEP932C_Registers->Version_Major = VERSION_MAJOR;
+	pEP932C_Registers->Version_Minor = VERSION_MINOR;
+	DBG_printf(("Version %d.%d\r\n", (int)VERSION_MAJOR, (int)VERSION_MINOR ));
+	// Initial HDCP Info
+	memset(pEP932C_Registers->HDCP_AKSV, 0x00, sizeof(pEP932C_Registers->HDCP_AKSV));
+	memset(pEP932C_Registers->HDCP_BKSV, 0x00, sizeof(pEP932C_Registers->HDCP_BKSV));
+	
+	// Update Configuration Registers
+	EP932_Reg_Read(EP932_Configuration, DDC_Data, 1);
+	pEP932C_Registers->Configuration = DDC_Data[0];
+
+	// Set Revocation List address
+	HDCP_Extract_BKSV_BCAPS3(pEP932C_Registers->HDCP_BKSV);
+	HDCP_Extract_FIFO((unsigned char*)pEP932C_Registers->HDCP_KSV_FIFO, sizeof(pEP932C_Registers->HDCP_KSV_FIFO));
+	HDCP_Stop();
+
+	// Reset EP932 Control Program
+	EP932Controller_Reset();
+}
+
+void EP932Controller_Reset(void)
+{
+	int i;
+	SMBUS_STATUS status = SMBUS_STATUS_Success;
+
+	// Reset Hardware
+	DBG_printf(("Reset EP932\r\n"));
+
+	EP_EP932M_Reset();
+	EP932_EnableHPInit();
+	
+	// Initial Variables
+	EP932_Reg_Set_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__OSCSEL);
+
+#if Enable_HDCP
+
+	// Read HDCP Key for EEPROM
+	status = HDMI_Tx_Get_Key((unsigned char *)HDCP_Key);
+	//DBG_printf(("Read HDCP Key = 0x%02X\r\n",(int)status));
+	HDCP_Fake(0);
+	pEP932C_Registers->System_Status &= ~EP932E_System_Status__KEY_FAIL;
+
+	// Check HDCP key and up load the key
+	if(status) {
+		// Do not upload the default Key!
+		pEP932C_Registers->System_Configuration |= EP932E_System_Configuration__HDCP_DIS;
+		pEP932C_Registers->System_Status |= EP932E_System_Status__KEY_FAIL;
+		DBG_printf(("No HDCP Key\r\n"));
+	}
+	else {
+		// Check HDCP key and up load the key
+		ChkSum = 0;
+		for(i=0; i<328; ++i) {
+			ChkSum += *((unsigned char *)HDCP_Key+i);
+		}	
+		DBG_printf(("HDCP Key Check Sum 0x%02X\r\n", (int)ChkSum ));
+		if(HDCP_Key[3][7] != 0x50 || HDCP_Key[12][7] != 0x01 || ChkSum != 0x00) {// || HDCP_Key[40][0] != 0xA5) {
+			HDCP_Fake(1);
+			pEP932C_Registers->System_Status |= EP932E_System_Status__KEY_FAIL;
+			DBG_printf(("Check Key failed!\r\n"));
+			pEP932C_Registers->System_Configuration |= EP932E_System_Configuration__HDCP_DIS;
+			//DBG_printf(("Disable HDCP \r\n"));
+		}
+		else {
+			// Upload the key 0-39
+			for(i=0; i<40; ++i) {
+				DDC_Data[0] = (unsigned char)i;
+				status |= EP932_Reg_Write(EP932_Key_Add, DDC_Data, 1);
+				memcpy(DDC_Data,&HDCP_Key[i][0],7);
+				status |= EP932_Reg_Write(EP932_Key_Data, DDC_Data, 7);
+			}
+			// Read and check	
+			for(i=0; i<40; ++i) {
+				DDC_Data[0] = (unsigned char)i;
+				status |= EP932_Reg_Write(EP932_Key_Add, DDC_Data, 1);
+				status |= EP932_Reg_Read(EP932_Key_Data, DDC_Data, 7);
+				if((memcmp(DDC_Data,&HDCP_Key[i][0],7) != 0) || status) {
+					// Test failed
+					HDCP_Fake(1);
+					pEP932C_Registers->System_Status |= EP932E_System_Status__KEY_FAIL;
+					DBG_printf(("Check Key failed!\r\n"));
+					pEP932C_Registers->System_Configuration |= EP932E_System_Configuration__HDCP_DIS;
+					//DBG_printf(("Disable HDCP \r\n"));
+					break;
+				}
+			}
+			// Upload final KSV 40
+			DDC_Data[0] = 40;
+			status |= EP932_Reg_Write(EP932_Key_Add, DDC_Data, 1);
+			memcpy(DDC_Data,&HDCP_Key[40][0],7);
+			status |= EP932_Reg_Write(EP932_Key_Data, DDC_Data, 7);
+			// Read back and check
+	    	if(!HDMI_Tx_read_AKSV(pEP932C_Registers->HDCP_AKSV)) {
+				// Test failed
+				HDCP_Fake(1);
+				pEP932C_Registers->System_Status |= EP932E_System_Status__KEY_FAIL;
+				DBG_printf(("Check KSV failed!\r\n"));
+				pEP932C_Registers->System_Configuration |= EP932E_System_Configuration__HDCP_DIS;
+				//DBG_printf(("Disable HDCP \r\n"));
+			}
+		}	
+	}
+
+#else
+
+	pEP932C_Registers->System_Status |= EP932E_System_Status__KEY_FAIL;
+	pEP932C_Registers->System_Configuration |= EP932E_System_Configuration__HDCP_DIS;
+
+#endif 
+
+	// EP932 Interface Reset
+	EP932_If_Reset();
+
+	// Internal Variable Reset
+	// bit
+	//Event_HDMI_Int = 0;
+	is_ReceiverSense = 0;
+
+	// data
+	Backup_Analog_Test_Control = 0;
+	if(TX_State > TXS_Search_EDID) {
+		DBG_printf(("\r\nState Transist: Reset -> [TXS_Wait_Upstream]\r\n"));
+		TX_State = TXS_Wait_Upstream;
+	}
+
+	DBG_printf(("EP932Controller_Reset finish\r\n"));
+}
+
+void EP932Controller_Timer(void)
+{
+	++HTP_TimeCount;
+	if(is_VideoChanging) ++VideoChg_TimeCount;
+	if(is_AudioChanging) ++AudioChg_TimeCount;
+	if(TX_State == TXS_HDCP) HDCP_Timer();
+	++ReadEDID_TimeCount;
+}
+
+unsigned int EP932_HotPlugMonitorInt(void)
+{
+	unsigned char temp;
+	is_Hot_Plug = HDMI_Tx_HTPLG();
+
+//	EP932_Reg_Read(EP932_General_Control_2, &temp, 1);
+
+//	if(temp & 0x1)
+		return is_Hot_Plug;	
+//	else 
+//		return -1;
+}
+
+unsigned int EP932_HotPlugMonitor(void)
+{
+	unsigned char temp;
+	is_Hot_Plug = HDMI_Tx_HTPLG();
+	return is_Hot_Plug;
+
+}
+
+unsigned char EP932Controller_Task(void)
+{
+
+	// Read Interrupt Flag and updat the internal information
+	ReadInterruptFlags();
+
+	// Polling Hot-Plug every 80ms
+	if(HTP_TimeCount > 80/EP932C_TIMER_PERIOD) {
+		HTP_TimeCount = 0;
+		
+		ConnectionState = HDMI_Tx_HTPLG();
+
+		HTPLG_NOW = ConnectionState;
+		if(HTPLG_LAST != HTPLG_NOW)
+		{
+			HTPLG_LAST = HTPLG_NOW;
+			if(HTPLG_NOW == 0)
+			{
+				DBG_printf(("Without HotPlug\r\n"));	
+				EP_HDMI_DumpMessage();				
+			}
+			else
+			{
+				DBG_printf(("Detect HotPlug \r\n"));	
+			}
+		}
+		
+		is_Hot_Plug = (ConnectionState == 1)? 1:0;
+		if(is_Connected != ((ConnectionState)?1:0) ) {
+			if(HP_ChangeCount++ >= 1) { // Accept continuous 1 error = 1*80 ms = 80 ms (Skip when low period < 80 ms)
+				HP_ChangeCount = 0;
+
+				is_Connected = ((ConnectionState)?1:0);
+			}
+		}
+		else {
+			HP_ChangeCount = 0;
+		}
+		if(is_Hot_Plug) {
+			pEP932C_Registers->System_Status |= EP932E_System_Status__HTPLG;
+		}
+		else {
+			pEP932C_Registers->System_Status &= ~EP932E_System_Status__HTPLG;
+		}
+
+		is_ReceiverSense = HDMI_Tx_RSEN(); // Only valid when TX is powered on
+
+		if(TX_State > TXS_Wait_Upstream) { // Powered Up and have Input
+			
+			// Update RSEN
+			if(is_ReceiverSense) {
+				pEP932C_Registers->System_Status |= EP932E_System_Status__RSEN;
+			}
+			else {
+				pEP932C_Registers->System_Status &= ~EP932E_System_Status__RSEN;
+			}
+			RSEN_ChangeCount = 0;
+
+			// Read HSO VSO POL information
+			EP932_Reg_Read(EP932_General_Control_4, DDC_Data, 1);
+			Video_Params.HVPol = 0;//DDC_Data[0] & (EP932_DE_Control__VSO_POL | EP932_DE_Control__HSO_POL);	
+		}
+		else {
+			if(RSEN_ChangeCount++ >= 8) { // Accept continuous 8 error = 8*80 ms = 640 ms (Skip when low period < 640 ms)
+				RSEN_ChangeCount = 0;
+
+				pEP932C_Registers->System_Status &= ~EP932E_System_Status__RSEN;
+			}
+		}
+	}
+
+	//
+	// Update EP932 Registers according to the System Process
+	//
+	switch(TX_State) {
+		case TXS_Search_EDID:
+			if(is_Connected) {
+				if(ReadEDID_TimeCount > 200/EP932C_TIMER_PERIOD) {
+					unsigned char EDID_DDC_Status;
+
+					// Confirm Hot-Plug (time-out after 1s)
+					if(!is_Hot_Plug) {
+						if(ReadEDID_TimeCount <= 1000/EP932C_TIMER_PERIOD) break;
+						DBG_printf(("WARNING: EDID detected without Hot-Plug for 1s\r\n"));
+					}
+
+					// Read EDID
+					DBG_printf(("\r\nState Transist: Read EDID -> [TXS_Wait_Upstream]\r\n"));				
+					memset(pEP932C_Registers->Readed_EDID, 0xFF, 256);
+					EDID_DDC_Status = Downstream_Rx_read_EDID(pEP932C_Registers->Readed_EDID);
+					
+					if(EDID_DDC_Status) {
+						//if(EDID_DDC_Status == EDID_STATUS_NoAct) {
+						if(EDID_DDC_Status != EDID_STATUS_ChecksumError) {
+							DBG_printf(("WARNING: EDID read failed 0x%02X\r\n", (int)EDID_DDC_Status));
+							if(ReadEDID_TimeCount <= 500/EP932C_TIMER_PERIOD) break;
+						}
+					}
+					ReadEDID_TimeCount = 0;
+ 
+					// Set Output
+					if(pEP932C_Registers->System_Configuration & EP932E_System_Configuration__FORCE_HDMI_CAP) {
+						is_Cap_HDMI = 1;
+					}
+					else {
+						is_Cap_HDMI = EDID_GetHDMICap(pEP932C_Registers->Readed_EDID);
+					}
+					if(is_Cap_HDMI) {			
+						DBG_printf(("Support HDMI"));
+
+						// Default Capability
+						is_Cap_YCC444 =	is_Cap_YCC422 = 0;
+						pEP932C_Registers->EDID_ASFreq = 0x07;
+						pEP932C_Registers->EDID_AChannel = 1;
+
+						pEP932C_Registers->EDID_VideoDataAddr = 0x00;
+						pEP932C_Registers->EDID_AudioDataAddr = 0x00;
+						pEP932C_Registers->EDID_SpeakerDataAddr = 0x00;
+						pEP932C_Registers->EDID_VendorDataAddr = 0x00;
+
+						if(!EDID_DDC_Status) {
+
+							if(pEP932C_Registers->Readed_EDID[131] & 0x20) {	// Support YCC444
+								is_Cap_YCC444 = 1;
+								DBG_printf((" YCC444"));
+							}
+							if(pEP932C_Registers->Readed_EDID[131] & 0x10) {	// Support YCC422
+								is_Cap_YCC422 = 1;
+								DBG_printf((" YCC422"));
+							}
+							DBG_printf(("\r\n"));
+							pEP932C_Registers->EDID_ASFreq = EDID_GetPCMFreqCap(pEP932C_Registers->Readed_EDID);
+							DBG_printf(("EDID ASFreq = 0x%02X\r\n",(int)pEP932C_Registers->EDID_ASFreq));
+
+							pEP932C_Registers->EDID_AChannel = EDID_GetPCMChannelCap(pEP932C_Registers->Readed_EDID);
+							DBG_printf(("EDID AChannel = 0x%02X\r\n",(int)pEP932C_Registers->EDID_AChannel));
+
+							pEP932C_Registers->EDID_VideoDataAddr = EDID_GetDataBlockAddr(pEP932C_Registers->Readed_EDID, 0x40);
+							pEP932C_Registers->EDID_AudioDataAddr = EDID_GetDataBlockAddr(pEP932C_Registers->Readed_EDID, 0x20);
+							pEP932C_Registers->EDID_SpeakerDataAddr = EDID_GetDataBlockAddr(pEP932C_Registers->Readed_EDID, 0x80);
+							pEP932C_Registers->EDID_VendorDataAddr = EDID_GetDataBlockAddr(pEP932C_Registers->Readed_EDID, 0x60);
+						}
+					}
+					else {
+						DBG_printf(("Support DVI RGB only\r\n"));
+						is_Cap_YCC444 =	is_Cap_YCC422 = 0;
+						pEP932C_Registers->EDID_ASFreq = pEP932C_Registers->EDID_AChannel = 0;
+					}
+
+					if(is_Cap_HDMI)
+						pEP932C_Registers->EDID_Status = EDID_DDC_Status | EP932E_EDID_Status__HDMI;
+					else
+						pEP932C_Registers->EDID_Status = EDID_DDC_Status;
+					DBG_printf(("Support Max Audio Channel %d\r\n", (int)pEP932C_Registers->EDID_AChannel+1));
+					DBG_printf(("Support Audio Freq 0x%02X\r\n", (int)pEP932C_Registers->EDID_ASFreq));
+
+					// Report EDID Change
+					pEP932C_Registers->Interrupt_Flags |= EP932E_Interrupt_Flags__EDID_CHG;
+					if(EP932C_GenerateInt && (pEP932C_Registers->Interrupt_Enable & EP932E_Interrupt_Enable__EDID_CHG) ) EP932C_GenerateInt();
+	
+					TX_State = TXS_Wait_Upstream;
+				}
+			}
+			else {	
+				pEP932C_Registers->EDID_Status = EDID_STATUS_NoAct;
+				ReadEDID_TimeCount = 0;
+			}
+			break;
+			
+		case TXS_Wait_Upstream:
+
+			if(!is_Connected) {
+
+				TXS_RollBack_Wait_Upstream();
+				TX_State = TXS_Search_EDID;
+			}
+			else if(!(pEP932C_Registers->Power_Control & (EP932E_Power_Control__PD_HDMI | EP932E_Power_Control__PD_TOT)) ) {
+				DBG_printf(("\r\nState Transist: Power Up -> [TXS_Stream]\r\n"));							
+
+				// Power Up
+				HDMI_Tx_Power_Up();
+
+				TX_State = TXS_Stream;
+			}
+			else {
+				// Check Force HDMI bit
+				if(!is_Cap_HDMI) {
+					if(pEP932C_Registers->System_Configuration & EP932E_System_Configuration__FORCE_HDMI_CAP) {
+						TXS_RollBack_Wait_Upstream();
+						TX_State = TXS_Search_EDID;
+					}
+				}
+			}
+			break;
+
+		case TXS_Stream:
+
+#if Enable_HDCP
+			if(!is_HDCP_Info_BKSV_Rdy && is_ReceiverSense && is_Hot_Plug) {
+				// Get HDCP Info
+		    	if(!Downstream_Rx_read_BKSV(pEP932C_Registers->HDCP_BKSV)) {
+					pEP932C_Registers->HDCP_Status = EP932E_HDCP_Status__BKSV;
+				}
+				pEP932C_Registers->HDCP_BCAPS3[0] = Downstream_Rx_BCAPS();
+				is_HDCP_Info_BKSV_Rdy = 1;
+			}
+#endif			
+
+			if(!is_Connected) {
+
+				TXS_RollBack_Stream();
+				TXS_RollBack_Wait_Upstream();
+				TX_State = TXS_Search_EDID;
+			}
+			else if(pEP932C_Registers->Power_Control & (EP932E_Power_Control__PD_HDMI | EP932E_Power_Control__PD_TOT) ) {
+				pEP932C_Registers->Power_Control |= EP932E_Power_Control__PD_HDMI;
+
+				TXS_RollBack_Stream();
+				TX_State = TXS_Wait_Upstream;
+			}
+			
+#if Enable_HDCP
+			else if(!((pEP932C_Registers->System_Configuration & EP932E_System_Configuration__HDCP_DIS) || is_VideoChanging) && is_ReceiverSense) {
+				// Enable mute for transmiter video and audio
+				HDMI_Tx_Mute_Enable();
+
+				DBG_printf(("\r\nState Transist: Start HDCP -> [TXS_HDCP]\r\n"));
+				TX_State = TXS_HDCP;
+			}
+#endif			
+
+			break;
+			
+#if Enable_HDCP
+		case TXS_HDCP:
+		
+			if(!is_Connected || !is_Hot_Plug) {
+
+				TXS_RollBack_HDCP();
+				TXS_RollBack_Stream();
+				TXS_RollBack_Wait_Upstream();
+				TX_State = TXS_Search_EDID;
+			}
+			else if(pEP932C_Registers->Power_Control & (EP932E_Power_Control__PD_HDMI | EP932E_Power_Control__PD_TOT) ) {
+				pEP932C_Registers->Power_Control |= EP932E_Power_Control__PD_HDMI;
+
+				TXS_RollBack_HDCP();
+				TXS_RollBack_Stream();
+				TX_State = TXS_Wait_Upstream;
+			}
+			else if((pEP932C_Registers->System_Configuration & EP932E_System_Configuration__HDCP_DIS) || is_VideoChanging) {
+	
+				TXS_RollBack_HDCP();
+				TX_State = TXS_Stream;
+			}
+			else {
+				pEP932C_Registers->HDCP_State = HDCP_Authentication_Task(is_ReceiverSense && is_Hot_Plug);
+				pEP932C_Registers->HDCP_Status = HDCP_Get_Status();
+			}
+			break;
+#endif
+
+	}
+
+	//
+	// Update EP932 Registers for any time
+	//
+
+	// Mute Control
+	if( (pEP932C_Registers->System_Configuration & EP932E_System_Configuration__AUDIO_DIS) || (TX_State < TXS_Stream) || is_VideoChanging  || is_AudioChanging ) {
+		HDMI_Tx_AMute_Enable();	
+	}
+	else {
+		HDMI_Tx_AMute_Disable();
+	}
+	
+	if( (pEP932C_Registers->System_Configuration & EP932E_System_Configuration__VIDEO_DIS) || (TX_State < TXS_Stream) || is_VideoChanging ) {
+		HDMI_Tx_VMute_Enable();		
+	}
+	else {
+		HDMI_Tx_VMute_Disable();
+	}
+
+	// HDMI Mode
+	if(!is_Cap_HDMI || (pEP932C_Registers->System_Configuration & EP932E_System_Configuration__HDMI_DIS) ) {
+		HDMI_Tx_DVI();		// Set to DVI mode (The Info Frame and Audio Packets would not be send)
+	}
+	else {
+		HDMI_Tx_HDMI();	// Set to HDMI mode
+	}
+
+	++Process_Dispatch_ID;
+	if(Process_Dispatch_ID > 2) Process_Dispatch_ID = 0;
+
+	switch(Process_Dispatch_ID) {
+
+		case 0:
+			//
+			// Update Video Params
+			//
+		
+			// Video Interface
+			Video_Params.Interface = pEP932C_Registers->Video_Interface[0];
+		
+			// Video Timing
+			if(pEP932C_Registers->Video_Input_Format[0]) { 
+				// Manul set the Video Timing
+				if(pEP932C_Registers->Video_Input_Format[0] < 128) {
+					Video_Params.VideoSettingIndex = pEP932C_Registers->Video_Input_Format[0];
+				}
+				else {
+					Video_Params.VideoSettingIndex = pEP932C_Registers->Video_Input_Format[0] - (128 - EP932_VDO_Settings_IT_Start);
+				}
+			} 
+		
+			// Select Sync Mode
+			Video_Params.SyncMode = (pEP932C_Registers->Video_Interface[1] & EP932E_Video_Interface_Setting_1__SYNC) >> 2;
+		
+			// Select Color Space
+			switch(pEP932C_Registers->Video_Interface[1] & EP932E_Video_Interface_Setting_1__COLOR) {
+				default:
+				case EP932E_Video_Interface_Setting_1__COLOR__Auto:
+					switch(Video_Params.VideoSettingIndex) {
+						case  4: case  5: case 16: case 19: case 20: case 31: case 32: 
+						case 33: case 34: case 39: case 40: case 41: case 46: case 47:		// HD Timing
+							Video_Params.ColorSpace = COLORSPACE_709;
+							break;
+		
+						default:
+							if(Video_Params.VideoSettingIndex && Video_Params.VideoSettingIndex < EP932_VDO_Settings_IT_Start) { // SD Timing
+								Video_Params.ColorSpace = COLORSPACE_601;
+							}
+							else {															// IT Timing
+								Video_Params.ColorSpace = COLORSPACE_709;
+							}
+					}
+					break;
+				case EP932E_Video_Interface_Setting_1__COLOR__601:
+					Video_Params.ColorSpace = COLORSPACE_601;
+					break;
+				case EP932E_Video_Interface_Setting_1__COLOR__709:
+					Video_Params.ColorSpace = COLORSPACE_709;
+					break;
+			}
+		
+			// Set Input Format
+			switch(pEP932C_Registers->Video_Interface[1] & EP932E_Video_Interface_Setting_1__VIN_FMT) {
+				default:
+				case EP932E_Video_Interface_Setting_1__VIN_FMT__RGB:
+					Video_Params.FormatIn = COLORFORMAT_RGB;
+					Video_Params.FormatOut = COLORFORMAT_RGB;
+					break;
+				case EP932E_Video_Interface_Setting_1__VIN_FMT__YCC444:
+					Video_Params.FormatIn = COLORFORMAT_YCC444;
+					if(is_Cap_YCC444) {
+						Video_Params.FormatOut = COLORFORMAT_YCC444;
+					}
+					else if(is_Cap_YCC422) {
+						Video_Params.FormatOut = COLORFORMAT_YCC422;
+					}
+					else {
+						Video_Params.FormatOut = COLORFORMAT_RGB;
+					}
+					break;
+				case EP932E_Video_Interface_Setting_1__VIN_FMT__YCC422:
+					Video_Params.FormatIn = COLORFORMAT_YCC422;
+					if(is_Cap_YCC444) {
+						Video_Params.FormatOut = COLORFORMAT_YCC444;
+					}
+					else if(is_Cap_YCC422) {
+						Video_Params.FormatOut = COLORFORMAT_YCC422;
+					}
+					else {
+						Video_Params.FormatOut = COLORFORMAT_RGB;
+					}
+					break;
+			}
+
+	//add by eric.lu
+	
+			// Set Output Format
+			switch(pEP932C_Registers->Video_Output_Format) {
+				default:
+				case 0:		// Auto, don't need change setting.
+					break;
+					
+				case 1:		// Force to YUV444 output format
+					Video_Params.FormatOut = COLORFORMAT_YCC444;
+					break;
+					
+				case 2:		// Force to YUV422 output format
+					Video_Params.FormatOut = COLORFORMAT_YCC422;
+					break;
+					
+				case 3:		// Force to RGB444 output format
+					Video_Params.FormatOut = COLORFORMAT_RGB;
+					break;
+			}
+			
+	// end of add
+
+			// DVI mode settings overwrite
+			if(!is_Cap_HDMI || (pEP932C_Registers->System_Configuration & EP932E_System_Configuration__HDMI_DIS) ) {
+				Video_Params.FormatOut = COLORFORMAT_RGB;
+			}
+		
+			// AFAR
+			Video_Params.AFARate = ((pEP932C_Registers->Video_Input_Format[1] & EP932E_Video_Input_Format_1__AFAR) >> 4) | 0x08;
+
+		// add by eric.lu
+			// SCAN			
+			Video_Params.SCAN = (pEP932C_Registers->Video_Input_Format[1] & EP932E_Video_Input_Format_1__SCAN);
+		// end of add
+		
+			// Video Change
+			if(memcmp(&Video_Params, &pEP932C_Registers->Video_Params_Backup, sizeof(VDO_PARAMS)) != 0) {
+				if(memcmp(&Video_Params, &pEP932C_Registers->Video_Params_Backup, 6) != 0) {
+					is_TimingChanging = 1;
+				}
+//				DBG_printf(("Video_Params new: interface 0x%02X, Vindex 0x%02X, HV 0x%02X, mode 0x%02X, Fin 0x%02X, Fout 0x%02X, color 0x%02X, AFAR 0x%02X\r\n",(int)Video_Params.Interface, (int)Video_Params.VideoSettingIndex, (int)Video_Params.HVPol ,(int)Video_Params.SyncMode, (int)Video_Params.FormatIn, (int)Video_Params.FormatOut, (int)Video_Params.ColorSpace, (int)Video_Params.AFARate));
+//				DBG_printf(("Video_Params old: interface 0x%02X, Vindex 0x%02X, HV 0x%02X, mode 0x%02X, Fin 0x%02X, Fout 0x%02X, color 0x%02X, AFAR 0x%02X\r\n",(int)pEP932C_Registers->Video_Params_Backup.Interface, (int)pEP932C_Registers->Video_Params_Backup.VideoSettingIndex, (int)pEP932C_Registers->Video_Params_Backup.HVPol ,(int)pEP932C_Registers->Video_Params_Backup.SyncMode, (int)pEP932C_Registers->Video_Params_Backup.FormatIn, (int)pEP932C_Registers->Video_Params_Backup.FormatOut, (int)pEP932C_Registers->Video_Params_Backup.ColorSpace, (int)pEP932C_Registers->Video_Params_Backup.AFARate));
+				
+				pEP932C_Registers->Video_Params_Backup = Video_Params;
+				
+				VideoChg_TimeCount = 0;
+				is_VideoChanging = 1;
+			}
+		
+			// Video Change Debouncing
+			if(is_VideoChanging) {				
+				if(VideoChg_TimeCount > AV_STABLE_TIME/EP932C_TIMER_PERIOD) {
+
+					DBG_printf(("### VideoChanging \r\n"));
+
+					if(is_TimingChanging) 
+						EP932Controller_Reset();
+
+					HDMI_Tx_Video_Config(&Video_Params);
+
+					if(is_TimingChanging) {
+						if(!is_AudioChanging) 
+							HDMI_Tx_Audio_Config(&Audio_Params);
+					}
+
+					is_TimingChanging = 0;
+					is_VideoChanging = 0;
+					VideoChg_TimeCount = 0;
+					
+					// Report Video Change
+					pEP932C_Registers->Interrupt_Flags |= EP932E_Interrupt_Flags__VIDEO_CHG;
+					if(EP932C_GenerateInt && (pEP932C_Registers->Interrupt_Enable & EP932E_Interrupt_Enable__VIDEO_CHG) ) EP932C_GenerateInt();
+				}
+			}
+			break;
+
+		case 1:
+			//
+			// Update Audio Params
+			//
+			Audio_Params.Interface = pEP932C_Registers->Audio_Interface & 0x0F; // IIS, WS_M, WS_POL, SCK_POL
+			Audio_Params.VideoSettingIndex = Video_Params.VideoSettingIndex;
+
+			// Update Audio Channel Number
+			if(EP932_VDO_Settings[Video_Params.VideoSettingIndex].Pix_Freq_Type <= PIX_FREQ_27027KHz) {
+				Audio_Params.ChannelNumber = 1;
+			}
+			else {
+				Audio_Params.ChannelNumber = min(((pEP932C_Registers->Audio_Interface & 0x70) >> 4), pEP932C_Registers->EDID_AChannel);
+			}
+
+			// Update VFS
+			if(Audio_Params.VideoSettingIndex < EP932_VDO_Settings_IT_Start) {
+				// Pixel Clock Type shift (59.94/60)
+				Audio_Params.VFS = (pEP932C_Registers->Video_Input_Format[1] & EP932E_Video_Input_Format_1__VIF)? 1:0;
+			}
+			else {
+				Audio_Params.VFS = 0;
+			}
+			Audio_Params.NoCopyRight = (pEP932C_Registers->Audio_Input_Format & EP932E_Audio_Input_Format__NoCopyRight)?1:0;
+		
+			// Write Frequency info (Use ADO_FREQ or Auto)
+			switch( pEP932C_Registers->Audio_Input_Format & EP932E_Audio_Input_Format__ADO_FREQ ) {
+		
+				case EP932E_Audio_Input_Format__ADO_FREQ__32000Hz:
+					Audio_Params.InputFrequency = ADSFREQ_32000Hz;
+					// Disable Down Sample
+					Audio_Params.ADSRate = 0;
+					break;
+		
+				default:
+				case EP932E_Audio_Input_Format__ADO_FREQ__44100Hz:
+					Audio_Params.InputFrequency = ADSFREQ_44100Hz;
+					// Disable Down Sample
+					Audio_Params.ADSRate = 0;
+					break;
+		
+				case EP932E_Audio_Input_Format__ADO_FREQ__48000Hz:
+					Audio_Params.InputFrequency = ADSFREQ_48000Hz;
+					// Disable Down Sample
+					Audio_Params.ADSRate = 0;
+					break;
+		
+				case EP932E_Audio_Input_Format__ADO_FREQ__88200Hz:
+					Audio_Params.InputFrequency = ADSFREQ_88200Hz;
+					if(pEP932C_Registers->EDID_ASFreq & 0x08) { // 88.2kHz
+						// Disable Down Sample
+						Audio_Params.ADSRate = 0;
+					}
+					else {
+						// Enable Down Sample 1/2
+						Audio_Params.ADSRate = 1;
+					}
+					break;
+		
+				case EP932E_Audio_Input_Format__ADO_FREQ__96000Hz:
+					Audio_Params.InputFrequency = ADSFREQ_96000Hz;
+					if(pEP932C_Registers->EDID_ASFreq & 0x10) { // 96kHz
+						// Disable Down Sample
+						Audio_Params.ADSRate = 0;
+					}
+					else {
+						if(pEP932C_Registers->EDID_ASFreq & 0x04) { // 48kHz
+							// Enable Down Sample 1/2
+							Audio_Params.ADSRate = 1;
+						}
+						else {
+							// Enable Down Sample 1/3
+							Audio_Params.ADSRate = 2;
+						}
+					}
+					break;
+		
+				case EP932E_Audio_Input_Format__ADO_FREQ__176400Hz:
+					Audio_Params.InputFrequency = ADSFREQ_176400Hz;
+					if(pEP932C_Registers->EDID_ASFreq & 0x20) { // 176kHz
+						// Disable Down Sample
+						Audio_Params.ADSRate = 0;
+					}
+					else {
+						if(pEP932C_Registers->EDID_ASFreq & 0x08) { // 88.2kHz
+							// Enable Down Sample 1/2
+							Audio_Params.ADSRate = 1;
+						}
+						else {
+							// Enable Down Sample 1/4
+							Audio_Params.ADSRate = 3;
+						}
+					}
+					break;
+		
+				case EP932E_Audio_Input_Format__ADO_FREQ__192000Hz:
+					Audio_Params.InputFrequency = ADSFREQ_192000Hz;
+					if(pEP932C_Registers->EDID_ASFreq & 0x40) { // 192kHz
+						// Disable Down Sample
+						Audio_Params.ADSRate = 0;
+					}
+					else {
+						if(pEP932C_Registers->EDID_ASFreq & 0x10) { // 96kHz
+							// Enable Down Sample 1/2
+							Audio_Params.ADSRate = 1;
+						}
+						else {
+							// Enable Down Sample 1/4
+							Audio_Params.ADSRate = 3;
+						}
+					}
+					break;
+			}
+		
+			// Audio Change
+			if(memcmp(&Audio_Params, &pEP932C_Registers->Audio_Params_Backup, sizeof(ADO_PARAMS)) != 0) {
+				pEP932C_Registers->Audio_Params_Backup = Audio_Params;
+		
+				AudioChg_TimeCount = 0;
+				is_AudioChanging = 1;
+			}
+
+			// Audio Change Debouncing
+			if(is_AudioChanging) {
+				if(AudioChg_TimeCount > AV_STABLE_TIME/EP932C_TIMER_PERIOD) {
+					HDMI_Tx_Audio_Config(&Audio_Params);
+					is_AudioChanging = 0;
+					AudioChg_TimeCount = 0;
+					
+					// Report Audio Change
+					pEP932C_Registers->Interrupt_Flags |= EP932E_Interrupt_Flags__AUDIO_CHG;
+					if(EP932C_GenerateInt && (pEP932C_Registers->Interrupt_Enable & EP932E_Interrupt_Enable__AUDIO_CHG) ) EP932C_GenerateInt();
+				}
+			}
+			break;
+
+		case 2:
+
+			// Update TREG
+			if(pEP932C_Registers->Analog_Test_Control != Backup_Analog_Test_Control) {
+				Backup_Analog_Test_Control = pEP932C_Registers->Analog_Test_Control;
+		
+				if(pEP932C_Registers->Analog_Test_Control & 0x01) {
+					EP932_Reg_Set_Bit(EP932_Color_Space_Control, 0x01);
+				}
+				else {
+					EP932_Reg_Clear_Bit(EP932_Color_Space_Control, 0x01);
+				}
+				if(pEP932C_Registers->Analog_Test_Control & 0x02) {
+					EP932_Reg_Set_Bit(EP932_Color_Space_Control, 0x02);
+				}
+				else {
+					EP932_Reg_Clear_Bit(EP932_Color_Space_Control, 0x02);
+				}
+			}
+			break;
+	}
+
+	// Return the status
+	if(pEP932C_Registers->Power_Control & (EP932E_Power_Control__PD_HDMI | EP932E_Power_Control__PD_TOT)) {
+		return EP932C_TASK_Idle;
+	}
+	else {
+		return EP932C_TASK_Pending;
+	}
+}
+
+void TXS_RollBack_Wait_Upstream(void)
+{
+	DBG_printf(("\r\nState Rollback: Reset EDID -> [TXS_Search_EDID]\r\n"));
+
+	// Reset EDID
+	memset(pEP932C_Registers->Readed_EDID, 0xFF, 256);
+
+	// Report EDID Change
+	pEP932C_Registers->Interrupt_Flags |= EP932E_Interrupt_Flags__EDID_CHG;
+	if(EP932C_GenerateInt && (pEP932C_Registers->Interrupt_Enable & EP932E_Interrupt_Enable__EDID_CHG) ) EP932C_GenerateInt();
+	ReadEDID_TimeCount = 0;
+}
+
+void TXS_RollBack_Stream(void)
+{
+	DBG_printf(("\r\nState Rollback: Power Down -> [TXS_Wait_Upstream]\r\n"));
+
+	// Power Down
+	HDMI_Tx_Power_Down();
+
+	// Reset HDCP Info
+	memset(pEP932C_Registers->HDCP_BKSV, 0x00, sizeof(pEP932C_Registers->HDCP_BKSV));
+	is_HDCP_Info_BKSV_Rdy = 0;
+}
+
+void TXS_RollBack_HDCP(void)
+{
+	DBG_printf(("\r\nState Rollback: Stop HDCP -> [TXS_Stream]\r\n"));
+
+	HDCP_Stop();
+	pEP932C_Registers->HDCP_Status = 0;
+	pEP932C_Registers->HDCP_State = 0;
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+
+void ReadInterruptFlags(void) 
+{
+	//DBG_printf(("EP932 ReadInterruptFlags \r\n"));
+	EP932_Reg_Read(EP932_General_Control_2, DDC_Data, 1);
+
+	if(DDC_Data[0] & EP932_General_Control_2__RIF) {
+		HDCP_Ext_Ri_Trigger();
+		// Clear the interrupt flag
+		DDC_Data[0] = EP932_General_Control_2__RIF;
+		EP932_Reg_Write(EP932_General_Control_2, DDC_Data, 1);
+	}
+	/*
+	// Clear the interrupt flag
+	DDC_Data[0] = EP932_General_Control_2__RIF;
+	EP932_Reg_Write(EP932_General_Control_2, DDC_Data, 1);
+	*/
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+
+void  EP_HDMI_DumpMessage(void)
+{
+	unsigned short Temp_USHORT;
+	unsigned char temp_R[2];
+	unsigned char reg_addr;
+
+	// System Status
+	DBG_printf(("\r\n\r\n======= Dump EP932E information =======\r\n"));
+
+	DBG_printf(("\r\n[EDID Data]"));
+	for(Temp_USHORT = 0; Temp_USHORT < 256; ++Temp_USHORT) {
+		if(Temp_USHORT%16 == 0) DBG_printf(("\r\n"));
+		if(Temp_USHORT%8 == 0) DBG_printf((" "));
+		DBG_printf(("0x%02X,", (int)EP932C_Registers.Readed_EDID[Temp_USHORT] ));
+	}
+	DBG_printf(("\r\n"));
+
+	DBG_printf(("\r\n[Revision & Configuration]\r\n"));
+	DBG_printf(("VendorID=0x%04X, ", EP932C_Registers.VendorID ));
+	DBG_printf(("DeviceID=0x%04X, ", EP932C_Registers.DeviceID ));
+	DBG_printf(("Version=%d.%d, CFG=0x%02X\r\n", (int)EP932C_Registers.Version_Major, (int)EP932C_Registers.Version_Minor, (int)EP932C_Registers.Configuration ));
+
+	DBG_printf(("\r\n[Interrupt Flags]\r\n"));
+	DBG_printf(("EDID_CHG=%d, ", (int)((EP932C_Registers.Interrupt_Flags & EP932E_Interrupt_Flags__EDID_CHG)?1:0) ));
+	DBG_printf(("VIDEO_CHG=%d, ", (int)((EP932C_Registers.Interrupt_Flags & EP932E_Interrupt_Flags__VIDEO_CHG)?1:0) ));
+	DBG_printf(("AUDIO_CHG=%d\r\n", (int)((EP932C_Registers.Interrupt_Flags & EP932E_Interrupt_Flags__AUDIO_CHG)?1:0) ));
+
+	DBG_printf(("\r\n[System Status]\r\n"));
+	DBG_printf(("RSEN=%d, ", (int)((EP932C_Registers.System_Status & EP932E_System_Status__RSEN)?1:0) ));
+	DBG_printf(("HTPLG=%d, ", (int)((EP932C_Registers.System_Status & EP932E_System_Status__HTPLG)?1:0) ));
+	DBG_printf(("KEY_FAIL=%d, ", (int)((EP932C_Registers.System_Status & EP932E_System_Status__KEY_FAIL)?1:0) ));
+	DBG_printf(("DEF_KEY=%d\r\n", (int)((EP932C_Registers.System_Status & EP932E_System_Status__DEF_KEY)?1:0) ));
+
+	DBG_printf(("\r\n[EDID Status]\r\n"));
+	DBG_printf(("EDID_HDMI=%d, ", (int)((EP932C_Registers.EDID_Status & EP932E_EDID_Status__HDMI)?1:0) ));
+	DBG_printf(("DDC_STATUS=%d\r\n", (int)(EP932C_Registers.EDID_Status & 0x0F) ));
+	DBG_printf(("VIDEO_DATA_ADDR=0x%02X, ", (int)EP932C_Registers.EDID_VideoDataAddr ));
+	DBG_printf(("AUDIO_DATA_ADDR=0x%02X, ", (int)EP932C_Registers.EDID_AudioDataAddr ));
+	DBG_printf(("SPEAKER_DATA_ADDR=0x%02X, ", (int)EP932C_Registers.EDID_SpeakerDataAddr ));
+	DBG_printf(("VENDOR_DATA_ADDR=0x%02X\r\n", (int)EP932C_Registers.EDID_VendorDataAddr ));
+	DBG_printf(("ASFREQ=0x%02X, ", (int)EP932C_Registers.EDID_ASFreq ));
+	DBG_printf(("ACHANNEL=%d\r\n", (int)EP932C_Registers.EDID_AChannel ));
+
+	DBG_printf(("\r\n[Video Status]\r\n"));
+	DBG_printf(("Interface=0x%02X, ", (int)EP932C_Registers.Video_Params_Backup.Interface ));
+	DBG_printf(("VideoSettingIndex=%d, ", (int)EP932C_Registers.Video_Params_Backup.VideoSettingIndex ));
+	DBG_printf(("HVPol=%d, ", (int)EP932C_Registers.Video_Params_Backup.HVPol ));
+	DBG_printf(("SyncMode=%d, ", (int)EP932C_Registers.Video_Params_Backup.SyncMode ));
+	DBG_printf(("FormatIn=%d, ", (int)EP932C_Registers.Video_Params_Backup.FormatIn ));
+	DBG_printf(("FormatOut=%d, ", (int)EP932C_Registers.Video_Params_Backup.FormatOut ));
+	DBG_printf(("ColorSpace=%d, ", (int)EP932C_Registers.Video_Params_Backup.ColorSpace ));
+	DBG_printf(("AFARate=%d\r\n", (int)EP932C_Registers.Video_Params_Backup.AFARate ));
+
+	DBG_printf(("\r\n[Audio Status]\r\n"));
+	DBG_printf(("Interface=0x%02X, ", (int)EP932C_Registers.Audio_Params_Backup.Interface ));
+	DBG_printf(("VideoSettingIndex=%d, ", (int)EP932C_Registers.Audio_Params_Backup.VideoSettingIndex ));
+	DBG_printf(("ChannelNumber=%d, ", (int)EP932C_Registers.Audio_Params_Backup.ChannelNumber ));
+	DBG_printf(("ADSRate=%d, ", (int)EP932C_Registers.Audio_Params_Backup.ADSRate ));
+	DBG_printf(("InputFrequency=%d, ", (int)EP932C_Registers.Audio_Params_Backup.InputFrequency ));
+	DBG_printf(("VFS=%d, ", (int)EP932C_Registers.Audio_Params_Backup.VFS ));
+	DBG_printf(("NoCopyRight=%d\r\n", (int)EP932C_Registers.Audio_Params_Backup.NoCopyRight ));
+
+	DBG_printf(("\r\n[Power Control]\r\n"));
+	DBG_printf(("PD_HDMI=%d, ", (int)((EP932C_Registers.Power_Control & EP932E_Power_Control__PD_HDMI)?1:0) ));
+	DBG_printf(("PD_TOT=%d\r\n", (int)((EP932C_Registers.Power_Control & EP932E_Power_Control__PD_TOT)?1:0) ));
+
+	DBG_printf(("\r\n[System Configuration]\r\n"));
+	DBG_printf(("HDCP_DIS=%d, ", (int)((EP932C_Registers.System_Configuration & EP932E_System_Configuration__HDCP_DIS)?1:0) ));
+	DBG_printf(("HDMI_DIS=%d, ", (int)((EP932C_Registers.System_Configuration & EP932E_System_Configuration__HDMI_DIS)?1:0) ));
+	DBG_printf(("AUDIO_DIS=%d, ", (int)((EP932C_Registers.System_Configuration & EP932E_System_Configuration__AUDIO_DIS)?1:0) ));
+	DBG_printf(("VIDEO_DIS=%d\r\n", (int)((EP932C_Registers.System_Configuration & EP932E_System_Configuration__VIDEO_DIS)?1:0) ));
+
+	DBG_printf(("\r\n[Interrupt Enable]\r\n"));
+	DBG_printf(("EDID_CHG=%d, ", (int)((EP932C_Registers.Interrupt_Enable & EP932E_Interrupt_Enable__EDID_CHG)?1:0) ));
+	DBG_printf(("VS_PERIOD_CHG=%d, ", (int)((EP932C_Registers.Interrupt_Enable & EP932E_Interrupt_Enable__VIDEO_CHG)?1:0) ));
+	DBG_printf(("AS_FREQ_CHG=%d\r\n", (int)((EP932C_Registers.Interrupt_Enable & EP932E_Interrupt_Enable__AUDIO_CHG)?1:0) ));
+
+	DBG_printf(("\r\n[Video Interface 0]\r\n"));
+	DBG_printf(("DK=%d, ", (int)((EP932C_Registers.Video_Interface[0] & EP932E_Video_Interface_Setting_0__DK)?1:0) ));
+	DBG_printf(("DKEN=%d, ", (int)((EP932C_Registers.Video_Interface[0] & EP932E_Video_Interface_Setting_0__DKEN)?1:0) ));
+	DBG_printf(("DSEL=%d, ", (int)((EP932C_Registers.Video_Interface[0] & EP932E_Video_Interface_Setting_0__DSEL)?1:0) ));
+	DBG_printf(("BSEL=%d, ", (int)((EP932C_Registers.Video_Interface[0] & EP932E_Video_Interface_Setting_0__BSEL)?1:0) ));
+	DBG_printf(("EDGE=%d, ", (int)((EP932C_Registers.Video_Interface[0] & EP932E_Video_Interface_Setting_0__EDGE)?1:0) ));
+	DBG_printf(("FMT12=%d\r\n", (int)((EP932C_Registers.Video_Interface[0] & EP932E_Video_Interface_Setting_0__FMT12)?1:0) ));
+
+	DBG_printf(("\r\n[Video Interface 1]\r\n"));
+	DBG_printf(("COLOR=%d, ", (int)((EP932C_Registers.Video_Interface[1] & EP932E_Video_Interface_Setting_1__COLOR)>>4) ));
+	DBG_printf(("SYNC=%d, ", (int)((EP932C_Registers.Video_Interface[1] & EP932E_Video_Interface_Setting_1__SYNC)>>2) ));
+	DBG_printf(("VIN_FMT=%d\r\n", (int)((EP932C_Registers.Video_Interface[1] & EP932E_Video_Interface_Setting_1__VIN_FMT)>>0) ));
+
+	DBG_printf(("\r\n[Audio Interface]\r\n"));
+	DBG_printf(("CHANNEL=%d, ", (int) (EP932C_Registers.Audio_Interface & EP932E_Audio_Interface_Setting__CHANNEL)>>4 ));
+	DBG_printf(("IIS=%d, ", (int)((EP932C_Registers.Audio_Interface & EP932E_Audio_Interface_Setting__IIS)?1:0) ));
+	DBG_printf(("WS_M=%d, ", (int)((EP932C_Registers.Audio_Interface & EP932E_Audio_Interface_Setting__WS_M)?1:0) ));
+	DBG_printf(("WS_POL=%d, ", (int)((EP932C_Registers.Audio_Interface & EP932E_Audio_Interface_Setting__WS_POL)?1:0) ));
+	DBG_printf(("SCK_POL=%d\r\n", (int)((EP932C_Registers.Audio_Interface & EP932E_Audio_Interface_Setting__SCK_POL)?1:0) ));	
+
+	DBG_printf(("\r\n[Video Input Format 0]\r\n"));
+	DBG_printf(("VIC=%d\r\n", (int)EP932C_Registers.Video_Input_Format[0] ));	
+
+	DBG_printf(("\r\n[Video Input Format 1]\r\n"));
+	DBG_printf(("AFAR_VIF=0x%02X\r\n", (int)EP932C_Registers.Video_Input_Format[1] ));	
+
+
+	DBG_printf(("\r\n[EP932 Register value]"));
+	for(reg_addr = 0; reg_addr<=0x88; reg_addr++)
+	{
+		EP932_Reg_Read(reg_addr, temp_R, 1);
+		if(reg_addr%8 == 0)DBG_printf(("\r\n"));
+		DBG_printf(("[%02X]%02X, ",(int)reg_addr,(int)temp_R[0]));
+	}
+	DBG_printf(("\r\n"));
+}
+
+
diff --git a/drivers/video/hdmi/ep932/EP932Controller.h b/drivers/video/hdmi/ep932/EP932Controller.h
new file mode 100644
index 0000000..42f9253
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932Controller.h
@@ -0,0 +1,120 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932Controller.h
+
+  Description :  Head file of EP932Controller.
+
+\******************************************************************************/
+
+#ifndef EP932CONTROLLER_H
+#define EP932CONTROLLER_H
+
+// Our includes
+#include "EP932ERegDef.h"
+#include "EP932_If.h"
+#include "HDCP.h"
+
+#define VERSION_MAJOR             0  // Beta
+#define VERSION_MINOR             38 //      36
+
+#define EP932C_TIMER_PERIOD       10		//     The EP932Controller.c must be re-compiled if user want to change this value.
+
+typedef enum {
+	EP932C_TASK_Idle = 0,
+	EP932C_TASK_Error,
+	EP932C_TASK_Pending
+} EP932C_TASK_STATUS;
+
+typedef struct _EP932C_REGISTER_MAP {
+
+	// Read
+	unsigned short		VendorID;			// 0x00
+	unsigned short		DeviceID;
+	unsigned char		Version_Major;
+	unsigned char		Version_Minor;
+	unsigned char		Configuration;
+
+	unsigned char		Interrupt_Flags;		// 0x01
+
+	unsigned char		System_Status;			// 0x02
+
+	unsigned char		HDCP_Status;			// 0x03
+	unsigned char		HDCP_State;
+	unsigned char		HDCP_AKSV[5];
+	unsigned char		HDCP_BKSV[5];
+	unsigned char		HDCP_BCAPS3[3];
+	unsigned char		HDCP_KSV_FIFO[5*16];
+	unsigned char		HDCP_SHA[20];
+	unsigned char		HDCP_M0[8];
+
+	unsigned char		EDID_Status;			// 0x04
+	unsigned char		EDID_VideoDataAddr;
+	unsigned char		EDID_AudioDataAddr;
+	unsigned char		EDID_SpeakerDataAddr;
+	unsigned char		EDID_VendorDataAddr;
+	unsigned char		EDID_ASFreq;
+	unsigned char		EDID_AChannel;
+						
+	//unsigned short		VS_Period;				// 0x05 (Video Status)
+	//unsigned short		H_Res;
+	//unsigned short		V_Res;
+	//unsigned short		Ratio_24;
+	VDO_PARAMS 			Video_Params_Backup;
+
+	//unsigned short		AS_Freq;				// 0x06 (Audio Status)
+	//unsigned short		AS_Period;				// 
+	ADO_PARAMS 			Audio_Params_Backup;
+
+	unsigned char		Readed_EDID[256];		// 0x07
+
+	// Read / Write
+	unsigned char		Analog_Test_Control;	// 0X1C
+
+	unsigned char		Power_Control;			// 0x20
+	unsigned char		System_Configuration;
+
+	unsigned char		Interrupt_Enable;		// 0x21
+
+	unsigned char		Video_Interface[2];		// 0x22
+
+	unsigned char		Audio_Interface;		// 0x23
+
+	unsigned char		Video_Input_Format[2];	// 0x24
+
+	unsigned char 		Video_Output_Format;
+
+	unsigned char		Audio_Input_Format;		// 0x25
+
+	unsigned char		End;
+
+} EP932C_REGISTER_MAP, *PEP932C_REGISTER_MAP;
+
+// -----------------------------------------------------------------------------
+// -----------------------------------------------------------------------------
+
+typedef void (*EP932C_CALLBACK)(void);
+
+void EP932Controller_Initial(PEP932C_REGISTER_MAP pEP932C_RegMap, EP932C_CALLBACK IntCall);
+
+unsigned char EP932Controller_Task(void);
+
+void EP932Controller_Timer(void);
+void  EP_HDMI_DumpMessage(void);
+unsigned int EP932_HotPlugMonitor(void);
+unsigned int EP932_HotPlugMonitorInt(void);
+
+// -----------------------------------------------------------------------------
+#endif
+
diff --git a/drivers/video/hdmi/ep932/EP932Controller.o b/drivers/video/hdmi/ep932/EP932Controller.o
new file mode 100644
index 0000000..527d9e2
Binary files /dev/null and b/drivers/video/hdmi/ep932/EP932Controller.o differ
diff --git a/drivers/video/hdmi/ep932/EP932ERegDef.h b/drivers/video/hdmi/ep932/EP932ERegDef.h
new file mode 100644
index 0000000..5fda1f0
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932ERegDef.h
@@ -0,0 +1,178 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932ERegDef.h
+
+  Description :  Register Address definitions of EP932E.
+
+\******************************************************************************/
+
+#ifndef EP932EREGDEF_H
+#define EP932EREGDEF_H
+
+// Registers									Address		BitMask		Value
+#define EP932E_Vendor_ID						0x0000
+#define EP932E_Device_ID						0x0002
+#define EP932E_Firmware_Revision__Major			0x0004
+#define EP932E_Firmware_Revision__Minor			0x0005
+
+#define EP932E_Interrupt_Flags					0x0100
+#define EP932E_Interrupt_Flags__EDID_CHG					0x80
+#define EP932E_Interrupt_Flags__VIDEO_CHG					0x40
+#define EP932E_Interrupt_Flags__AUDIO_CHG					0x20
+#define EP932E_Interrupt_Flags__VS_ALIGN_FAILED				0x10
+#define EP932E_Interrupt_Flags__VS_ALIGN_DONE				0x08
+
+#define EP932E_System_Status					0x0200
+#define EP932E_System_Status__RSEN							0x80
+#define EP932E_System_Status__HTPLG							0x40
+#define EP932E_System_Status__KEY_FAIL						0x02
+#define EP932E_System_Status__DEF_KEY						0x01
+
+#define EP932E_HDCP_Status						0x0300
+#define EP932E_HDCP_Status__BKSV							0x80
+#define EP932E_HDCP_Status__AKSV							0x40
+#define EP932E_HDCP_Status__R0								0x20
+#define EP932E_HDCP_Status__Ri								0x10
+#define EP932E_HDCP_Status__RepeaterRdy						0x08
+#define EP932E_HDCP_Status__RepeaterSHA						0x04
+#define EP932E_HDCP_Status__RSEN							0x02
+#define EP932E_HDCP_Status__REVOKE							0x01
+
+#define EP932E_HDCP_State						0x0301
+
+#define EP932E_HDCP_AKSV						0x0302
+ 
+#define EP932E_HDCP_BKSV						0x0307 
+
+#define EP932E_HDCP_BCAPS						0x030C
+
+#define EP932E_HDCP_BSTATUS						0x030D
+
+#define EP932E_HDCP_KSV_FIFO					0x030F
+
+#define EP932E_EDID_Status						0x0400
+#define EP932E_EDID_Status__HDMI							0x10
+#define EP932E_EDID_Status__DDC_Status						0x0F
+typedef enum {
+	EDID_DDC_Success = 0x00,
+	EDID_DDC_Pending,
+	EDID_DDC_NoAct = 0x02,
+	EDID_DDC_TimeOut,
+	EDID_DDC_ArbitrationLoss = 0x04,
+	EDID_DDC_BlockNumber
+} EDID_DDC_STATUS;
+#define EP932E_EDID_Status_ASFreq				0x0401
+#define EP932E_EDID_Status_AChannel				0x0402
+
+#define EP932E_Video_Status_VS_Period			0x0500					// 2 Byte
+#define EP932E_Video_Status_H_RES				0x0502					// 2 Byte
+#define EP932E_Video_Status_V_RES				0x0504					// 2 Byte
+#define EP932E_Video_Status_RATIO_24			0x0506					// 2 Byte
+#define EP932E_Video_Status_Params				0x0508					// 8 Byte
+
+#define EP932E_Audio_Status_AS_Freq				0x0600					// 2 Byte
+#define EP932E_Audio_Status_AS_Period			0x0602					// 2 Byte
+#define EP932E_Audio_Status_Params				0x0604					// 7 Byte
+
+#define EP932E_EDID_Data						0x0700					// 256 Byte
+
+#define EP932E_Analog_Test_Control				0x1C00
+#define EP932E_Analog_Test_Control__PREEMPHASIS				0x03
+
+#define EP932E_SIP_Test_Control					0x1D00
+#define EP932E_SIP_Test_Control__VS_ALIGN					0x08
+#define EP932E_SIP_Test_Control__BIST						0x04
+#define EP932E_SIP_Test_Control__ANA_TEST					0x02
+#define EP932E_SIP_Test_Control__IIC_STOP 					0x01
+
+#define EP932E_Power_Control					0x2000
+#define EP932E_Power_Control__PD_HDMI						0x02
+#define EP932E_Power_Control__PD_TOT						0x01
+
+#define EP932E_System_Configuration				0x2001
+#define EP932E_System_Configuration__PACKET_RDY				0x80
+#define EP932E_System_Configuration__HDCP_DIS				0x20
+#define EP932E_System_Configuration__HDMI_DIS				0x10
+#define EP932E_System_Configuration__FORCE_HDMI_CAP			0x08
+#define EP932E_System_Configuration__AUDIO_DIS				0x02
+#define EP932E_System_Configuration__VIDEO_DIS				0x01
+
+#define EP932E_Interrupt_Enable					0x2100
+#define EP932E_Interrupt_Enable__EDID_CHG					0x80
+#define EP932E_Interrupt_Enable__VIDEO_CHG					0x40
+#define EP932E_Interrupt_Enable__AUDIO_CHG					0x20
+#define EP932E_Interrupt_Enable__VS_ALIGN_DONE				0x08
+
+#define EP932E_Video_Interface_Setting_0		0x2200
+#define EP932E_Video_Interface_Setting_0__DK				0xE0
+#define EP932E_Video_Interface_Setting_0__DKEN				0x10
+#define EP932E_Video_Interface_Setting_0__DSEL				0x08
+#define EP932E_Video_Interface_Setting_0__BSEL				0x04
+#define EP932E_Video_Interface_Setting_0__EDGE				0x02
+#define EP932E_Video_Interface_Setting_0__FMT12				0x01
+
+#define EP932E_Video_Interface_Setting_1		0x2201
+#define EP932E_Video_Interface_Setting_1__COLOR				0x30
+#define EP932E_Video_Interface_Setting_1__COLOR__Auto					0x00
+#define EP932E_Video_Interface_Setting_1__COLOR__601					0x10
+#define EP932E_Video_Interface_Setting_1__COLOR__709					0x20
+#define EP932E_Video_Interface_Setting_1__xvYCC_EN			0x80
+#define EP932E_Video_Interface_Setting_1__SYNC				0x0C
+#define EP932E_Video_Interface_Setting_1__SYNC__HVDE					0x00
+#define EP932E_Video_Interface_Setting_1__SYNC__HV						0x04
+#define EP932E_Video_Interface_Setting_1__SYNC__Embeded					0x08
+#define EP932E_Video_Interface_Setting_1__VIN_FMT			0x03
+#define EP932E_Video_Interface_Setting_1__VIN_FMT__RGB					0x00
+#define EP932E_Video_Interface_Setting_1__VIN_FMT__YCC444				0x01
+#define EP932E_Video_Interface_Setting_1__VIN_FMT__YCC422				0x02
+
+#define EP932E_Audio_Interface_Setting			0x2300
+#define EP932E_Audio_Interface_Setting__CHANNEL				0xF0
+#define EP932E_Audio_Interface_Setting__IIS					0x08
+#define EP932E_Audio_Interface_Setting__WS_M				0x04
+#define EP932E_Audio_Interface_Setting__WS_POL				0x02
+#define EP932E_Audio_Interface_Setting__SCK_POL				0x01
+
+#define EP932E_Video_Input_Format_VIC			0x2400
+#define EP932E_Video_Input_Format_1				0x2401
+#define EP932E_Video_Input_Format_1__AFAR					0x30
+#define EP932E_Video_Input_Format_1__AFAR__Auto							0x00
+#define EP932E_Video_Input_Format_1__AFAR__4_3							0x10
+#define EP932E_Video_Input_Format_1__AFAR__16_9							0x20
+#define EP932E_Video_Input_Format_1__AFAR__14_9							0x30
+#define EP932E_Video_Input_Format_1__VIF								0x08	 //0x01  //modify by eric.lu 
+#define EP932E_Video_Input_Format_1__SCAN								0x03	 		//add by eric.lu 
+
+#define EP932E_Audio_Input_Format				0x2500
+#define EP932E_Audio_Input_Format__NoCopyRight				0x10
+#define EP932E_Audio_Input_Format__ADO_FREQ					0x07
+#define EP932E_Audio_Input_Format__ADO_FREQ__Auto						0x00
+#define EP932E_Audio_Input_Format__ADO_FREQ__32000Hz					0x01
+#define EP932E_Audio_Input_Format__ADO_FREQ__44100Hz					0x02
+#define EP932E_Audio_Input_Format__ADO_FREQ__48000Hz					0x03
+#define EP932E_Audio_Input_Format__ADO_FREQ__88200Hz					0x04
+#define EP932E_Audio_Input_Format__ADO_FREQ__96000Hz					0x05
+#define EP932E_Audio_Input_Format__ADO_FREQ__176400Hz					0x06
+#define EP932E_Audio_Input_Format__ADO_FREQ__192000Hz					0x07
+
+#define EP932E_KSV_Revocation_List				0x2600
+
+#define EP932E_Gamut_Packet_Header				0x2700
+#define EP932E_Gamut_Packet_Data				0x2703
+
+#define EP932E_Select_Packet_Header				0x2800
+#define EP932E_Select_Packet_Data				0x2803
+
+#endif
diff --git a/drivers/video/hdmi/ep932/EP932RegDef.h b/drivers/video/hdmi/ep932/EP932RegDef.h
new file mode 100644
index 0000000..b9a6186
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932RegDef.h
@@ -0,0 +1,163 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932RegDef.h
+
+  Description :  Register Address definitions of EP932.
+
+\******************************************************************************/
+
+#ifndef EP932REGDEF_H
+#define EP932REGDEF_H
+
+// Registers								Word	BitMask
+#define EP932_SMPRD							0x06			// 2 Byte
+
+#define EP932_General_Control_1				0x08
+#define EP932_General_Control_1__TSEL_HTP			0x80
+#define EP932_General_Control_1__INT_OD				0x40
+#define EP932_General_Control_1__INT_POL			0x20
+#define EP932_General_Control_1__VTX				0x10
+#define EP932_General_Control_1__DSEL				0x08
+#define EP932_General_Control_1__BSEL				0x04
+#define EP932_General_Control_1__EDGE				0x02
+#define EP932_General_Control_1__PU					0x01
+
+#define EP932_General_Control_2				0x09
+#define EP932_General_Control_2__RSEN				0x80
+#define EP932_General_Control_2__HTPLG				0x40
+#define EP932_General_Control_2__RIE				0x20
+#define EP932_General_Control_2__VIE				0x10
+#define EP932_General_Control_2__MIE				0x08
+#define EP932_General_Control_2__RIF				0x04
+#define EP932_General_Control_2__VIF				0x02
+#define EP932_General_Control_2__MIF				0x01
+
+#define EP932_General_Control_3				0x0A	
+
+#define EP932_Configuration					0x0B
+
+#define EP932_Color_Space_Control			0x0C
+#define EP932_Color_Space_Control__422_OUT			0x80
+#define EP932_Color_Space_Control__YCC_OUT			0x40
+#define EP932_Color_Space_Control__COLOR			0x20
+#define EP932_Color_Space_Control__YCC_Range		0x10
+#define EP932_Color_Space_Control__VMUTE			0x08
+#define EP932_Color_Space_Control__AMUTE			0x04
+#define EP932_Color_Space_Control__TREG				0x03
+		
+#define EP932_Pixel_Repetition_Control		0x0D	
+#define EP932_Pixel_Repetition_Control__CS_M		0x80
+#define EP932_Pixel_Repetition_Control__CTS_M		0x40
+#define EP932_Pixel_Repetition_Control__ADSR		0x30
+#define EP932_Pixel_Repetition_Control__OSCSEL		0x08
+#define EP932_Pixel_Repetition_Control__VSYNC		0x04	
+#define EP932_Pixel_Repetition_Control__PR			0x03
+
+#define EP932_General_Control_4				0x0E
+#define EP932_General_Control_4__FMT12				0x80
+#define EP932_General_Control_4__422_IN				0x40
+#define EP932_General_Control_4__YCC_IN				0x20
+#define EP932_General_Control_4__E_SYNC				0x10
+#define EP932_General_Control_4__VPOL_DET			0x08
+#define EP932_General_Control_4__HPOL_DET			0x04
+#define EP932_General_Control_4__EESS				0x02
+#define EP932_General_Control_4__HDMI				0x01
+
+#define EP932_General_Control_5				0x0F
+#define EP932_General_Control_5__AKSV_RDY			0x80
+#define EP932_General_Control_5__RPTR				0x10
+#define EP932_General_Control_5__RI_RDY				0x02
+#define EP932_General_Control_5__ENC_EN				0x01
+
+#define EP932_BKSV							0x10			// BKSV1-BKSV5 0x10-0x14
+
+#define EP932_AN							0x15			// AN1-AN8 0x15-0x1C
+
+#define EP932_AKSV							0x1D			// AKSV1-AKSV5 0x1D-0x21
+
+#define EP932_RI							0x22			// RI1-RI2 0x22-0x23
+
+#define EP932_M0							0x25			// 0x25-0x32
+
+#define EP932_DE_DLY						0x32			// 10 bit
+
+#define EP932_DE_Control					0x33			// 10 bit
+#define EP932_DE_Control__DE_GEN					0x40
+#define EP932_DE_Control__VSO_POL					0x08
+#define EP932_DE_Control__HSO_POL					0x04
+
+#define EP932_DE_TOP						0x34			// 6 bit
+
+#define EP932_DE_CNT						0x36			// 10 bit
+
+#define EP932_DE_LIN						0x38			// 10 bit
+
+#define EP932_H_RES							0x3A			// 11 bit
+
+#define EP932_V_RES							0x3C			// 11 bit
+
+#define EP932_Audio_Subpacket_Allocation	0x3E			// Default 0xE4
+
+#define EP932_IIS_Control					0x3F			// Default 0x00
+#define EP932_IIS_Control__ACR_EN					0x80
+#define EP932_IIS_Control__AVI_EN					0x40
+#define EP932_IIS_Control__ADO_EN					0x20
+#define EP932_IIS_Control__AUDIO_EN					0x10
+#define EP932_IIS_Control__WS_M						0x04
+#define EP932_IIS_Control__WS_POL					0x02
+#define EP932_IIS_Control__SCK_POL					0x01
+
+#define EP932_Packet_Control				0x40			// Default 0x00
+#define EP932_Packet_Control__FLAT3					0x80
+#define EP932_Packet_Control__FLAT2					0x40
+#define EP932_Packet_Control__FLAT1					0x20
+#define EP932_Packet_Control__FLAT0					0x10
+#define EP932_Packet_Control__LAYOUT				0x08
+#define EP932_Packet_Control__IIS					0x04
+#define EP932_Packet_Control__PKT_RDY				0x01
+
+#define EP932_Data_Packet_Header 			0x41			// HB0-HB2 0x41-0x43
+
+#define EP932_Data_Packet 					0x44			// PB0-PB27 0x44-0x5F
+
+#define EP932_CTS		 					0x60			// 20bit (3 Byte)
+
+#define EP932_N			 					0x63			// 20bit (3 Byte)
+
+#define EP932_AVI_Packet 					0x66			// 14 Byte 0x66-0x73
+
+#define EP932_ADO_Packet 					0x74			// 6 Byte 0x74-0x79
+
+#define EP932_SPDIF_Sampling_Frequency 		0x7A			// 1 Byte
+
+#define EP932_Channel_Status		 		0x7B			// 5 Byte 0x7B-0x7F
+
+#define EP932_Embedded_Sync			 		0x80			// Default 0x00
+
+#define EP932_H_Delay			 			0x81			// 10 bit (2 Byte)
+
+#define EP932_H_Width			 			0x83			// 10 bit (2 Byte)
+
+#define EP932_V_Delay			 			0x85			// 6 bit
+
+#define EP932_V_Width			 			0x86			// 6 bit
+
+#define EP932_V_Off_Set			 			0x87			// 12 bit (2 Byte)
+
+#define EP932_Key_Add			 			0xF0			// 1 Byte
+
+#define EP932_Key_Data			 			0xF1			// 7 Byte
+
+#endif
diff --git a/drivers/video/hdmi/ep932/EP932SettingsData.c b/drivers/video/hdmi/ep932/EP932SettingsData.c
new file mode 100644
index 0000000..58b16b2
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932SettingsData.c
@@ -0,0 +1,310 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932SettingsData.c
+
+  Description :  EP932 Settings Table
+
+\******************************************************************************/
+
+#include "EP932SettingsData.h"
+
+VDO_SETTINGS EP932_VDO_Settings[] = {
+	//                   HVRes_Type,             		DE_Gen(DLY,CNT,TOP,LIN),                E_Sync, 				AR_PR,       Pix_Freq_Type,
+	{  0,{       0,   0,   0,    0},{  0,   0,  0,   0},{0x00,  0,  0,  0,  0,   0},  0x00,                  1}, // 0:
+	// HDMI Mode
+	{  1,{VNegHNeg, 800, 525,16666},{ 48, 640, 34, 480},{0x00, 12, 96, 10,  2,   0},  0x10,  PIX_FREQ_25175KHz}, // 1:    640 x  480p
+	{  2,{VNegHNeg, 858, 525,16666},{ 60, 720, 31, 480},{0x00, 12, 62,  9,  6,   0},  0x10,  PIX_FREQ_27000KHz}, // 2:    720 x  480p  4:3
+	{  3,{VNegHNeg, 858, 525,16666},{ 60, 720, 31, 480},{0x00, 12, 62,  9,  6,   0},  0x20,  PIX_FREQ_27000KHz}, // 3:    720 x  480p 16:9
+	{  4,{VPosHPos,1650, 750,16666},{220,1280, 21, 720},{0x00,106, 40,  5,  5,   0},  0x20,  PIX_FREQ_74176KHz}, // 4:   1280 x  720p
+	{  5,{VPosHPos,2200, 563,16666},{148,1920, 16, 540},{0x09, 84, 44,  2,  5,1100},  0x20,  PIX_FREQ_74176KHz}, // 5:   1920 x 1080i
+	{  6,{VNegHNeg, 858, 262,16666},{ 57, 720, 16, 240},{0x09, 15, 62,  4,  3, 429},  0x15,  PIX_FREQ_27000KHz}, // 6:    720 x  480i, pix repl
+	{  7,{VNegHNeg, 858, 262,16666},{ 57, 720, 16, 240},{0x09, 15, 62,  4,  3, 429},  0x25,  PIX_FREQ_27000KHz}, // 7:    720 x  480i, pix repl
+	{  8,{VNegHNeg, 858, 262,16666},{ 57, 720, 16, 240},{0x00, 15, 62,  4,  3,   0},  0x15,  PIX_FREQ_27000KHz}, // 8:    720 x  240p, pix repl
+	{  9,{VNegHNeg, 858, 262,16666},{ 57, 720, 16, 240},{0x00, 15, 62,  4,  3,   0},  0x25,  PIX_FREQ_27000KHz}, // 9:    720 x  240p, pix repl
+	{ 10,{VNegHNeg,3432, 262,16666},{228,2880, 16, 240},{0x09, 72,248,  4,  3,1716},  0x10,  PIX_FREQ_54000KHz}, // 10:  2880 x  480i 4:3
+	{ 11,{VNegHNeg,3432, 262,16666},{228,2880, 16, 240},{0x09, 72,248,  4,  3,1716},  0x20,  PIX_FREQ_54000KHz}, // 11:  2880 x  480i 16:9
+	{ 12,{VNegHNeg,3432, 262,16666},{228,2880, 16, 240},{0x00, 72,248,  4,  3,   0},  0x10,  PIX_FREQ_54000KHz}, // 12:  2880 x  240p 4:3
+	{ 13,{VNegHNeg,3432, 262,16666},{228,2880, 16, 240},{0x00, 72,248,  4,  3,   0},  0x20,  PIX_FREQ_54000KHz}, // 13:  2880 x  240p 16:9
+	{ 14,{VNegHNeg,1716, 525,16666},{120,1440, 31, 480},{0x00, 28,124,  9,  6,   0},  0x10,  PIX_FREQ_54000KHz}, // 14:  1440 x  480p 4:3
+	{ 15,{VNegHNeg,1716, 525,16666},{120,1440, 31, 480},{0x00, 28,124,  9,  6,   0},  0x20,  PIX_FREQ_54000KHz}, // 15:  1440 x  480p 16:9
+	{ 16,{VPosHPos,2200,1125,16666},{148,1920, 37,1080},{0x00, 84, 44,  4,  5,   0},  0x20, PIX_FREQ_148352KHz}, // 16:  1920 x 1080p
+	{ 17,{VNegHNeg, 864, 625,20000},{ 68, 720, 40, 576},{0x00,  8, 64,  5,  5,   0},  0x10,  PIX_FREQ_27000KHz}, // 17:   720 x  576p 4:3
+	{ 18,{VNegHNeg, 864, 625,20000},{ 68, 720, 40, 576},{0x00,  8, 64,  5,  5,   0},  0x20,  PIX_FREQ_27000KHz}, // 18:   720 x  576p 16:9
+	{ 19,{VPosHPos,1980, 750,20000},{220,1280, 21, 720},{0x00,436, 40,  5,  5,   0},  0x20,  PIX_FREQ_74250KHz}, // 19:  1280 x  720p, 50 Hz
+	{ 20,{VPosHPos,2640, 563,20000},{148,1920, 16, 540},{0x09,524, 44,  2,  5,1320},  0x20,  PIX_FREQ_74250KHz}, // 20:  1920 x 1080i, 50 Hz
+	{ 21,{VNegHNeg, 864, 313,20000},{ 69, 720, 20, 288},{0x09,  8, 63,  2,  3, 432},  0x15,  PIX_FREQ_27000KHz}, // 21:   720 x  576i, pix repl
+	{ 22,{VNegHNeg, 864, 313,20000},{ 69, 720, 20, 288},{0x09,  8, 63,  2,  3, 432},  0x25,  PIX_FREQ_27000KHz}, // 22:   720 x  576i, pix repl
+	{ 23,{VNegHNeg, 864, 313,20000},{ 69, 720, 20, 288},{0x00,  8, 63,  3,  3,   0},  0x15,  PIX_FREQ_27000KHz}, // 23:   720 x  288p, pix repl
+	{ 24,{VNegHNeg, 864, 313,20000},{ 69, 720, 20, 288},{0x00,  8, 63,  3,  3,   0},  0x25,  PIX_FREQ_27000KHz}, // 24:   720 x  288p, pix repl
+	{ 25,{VNegHNeg,3456, 313,20000},{276,2880, 20, 288},{0x09, 44,252,  2,  3,1728},  0x10,  PIX_FREQ_54000KHz}, // 25:  2880 x  576i
+	{ 26,{VNegHNeg,3456, 313,20000},{276,2880, 20, 288},{0x09, 44,252,  2,  3,1728},  0x20,  PIX_FREQ_54000KHz}, // 26:  2880 x  576i
+	{ 27,{VNegHNeg,3456, 313,20000},{276,2880, 20, 288},{0x00, 44,252,  3,  3,   0},  0x10,  PIX_FREQ_54000KHz}, // 27:  2880 x  288p
+	{ 28,{VNegHNeg,3456, 313,20000},{276,2880, 20, 288},{0x00, 44,252,  3,  3,   0},  0x20,  PIX_FREQ_54000KHz}, // 28:  2880 x  288p
+	{ 29,{VPosHNeg,1728, 625,20000},{136,1440, 40, 576},{0x00, 20,128,  5,  5,   0},  0x10,  PIX_FREQ_54000KHz}, // 29:  1440 x  576p
+	{ 30,{VPosHNeg,1728, 625,20000},{136,1440, 40, 576},{0x00, 20,128,  5,  5,   0},  0x20,  PIX_FREQ_54000KHz}, // 30:  1440 x  576p
+	{ 31,{VPosHPos,2640,1125,20000},{148,1920, 37,1080},{0x00,524, 44,  4,  5,   0},  0x20, PIX_FREQ_148500KHz}, // 31:  1920 x 1080p, 50 Hz
+	{ 32,{VPosHPos,2750,1125,41666},{148,1920, 37,1080},{0x00,634, 44,  4,  5,   0},  0x20,  PIX_FREQ_74176KHz}, // 32:  1920 x 1080p
+	{ 33,{VPosHPos,2640,1125,40000},{148,1920, 37,1080},{0x00,524, 44,  4,  5,   0},  0x20,  PIX_FREQ_74250KHz}, // 33:  1920 x 1080p, 25 Hz
+	{ 34,{VPosHPos,2200,1125,33333},{148,1920, 37,1080},{0x00, 84, 44,  4,  5,   0},  0x20,  PIX_FREQ_74176KHz}, // 34:  1920 x 1080p
+
+	{ 35,{VNegHNeg,3432, 525,16666},{240,2880, 31, 480},{0x00, 92,248,  9,  6,   0},  0x10, PIX_FREQ_108000KHz}, // 35:  2880 x  480p
+	{ 36,{VNegHNeg,3432, 525,16666},{240,2880, 31, 480},{0x00, 92,248,  9,  6,   0},  0x20, PIX_FREQ_108000KHz}, // 36:  2880 x  480p
+	{ 37,{VNegHNeg,3456, 625,20000},{272,2880, 40, 576},{0x00, 44,256,  5,  5,   0},  0x10, PIX_FREQ_108000KHz}, // 37:  2880 x  576p @ 50Hz
+	{ 38,{VNegHNeg,3456, 625,20000},{272,2880, 40, 576},{0x00, 44,256,  5,  5,   0},  0x20, PIX_FREQ_108000KHz}, // 38:  2880 x  576p @ 50Hz
+	{ 39,{VPosHNeg,2304, 625,20000},{184,1920, 58, 540},{0x09, 28,168,  2,  5,1152},  0x20,  PIX_FREQ_72000KHz}, // 39:  1920 x 1080i @ 50Hz
+	{ 40,{VPosHPos,2640, 563,10000},{148,1920, 16, 540},{0x09,524, 44,  2,  5,1320},  0x20, PIX_FREQ_148500KHz}, // 40:  1920 x 1080i @ 100Hz
+	{ 41,{VPosHPos,1980, 750,10000},{220,1280, 21, 720},{0x00,436, 40,  5,  5,   0},  0x20, PIX_FREQ_148500KHz}, // 41:  1280 x  720p @ 100Hz
+	{ 42,{VNegHNeg, 864, 625,10000},{ 68, 720, 40, 576},{0x00,  8, 64,  5,  5,   0},  0x10,  PIX_FREQ_54000KHz}, // 42:   720 x  576p @ 100Hz
+	{ 43,{VNegHNeg, 864, 625,10000},{ 68, 720, 40, 576},{0x00,  8, 64,  5,  5,   0},  0x20,  PIX_FREQ_54000KHz}, // 43:   720 x  576p @ 100Hz
+	{ 44,{VNegHNeg, 864, 313,10000},{ 69, 720, 20, 288},{0x09,  8, 63,  2,  3, 432},  0x15,  PIX_FREQ_54000KHz}, // 44:   720 x  576i @ 100Hz, pix repl
+	{ 45,{VNegHNeg, 864, 313,10000},{ 69, 720, 20, 288},{0x09,  8, 63,  2,  3, 432},  0x25,  PIX_FREQ_54000KHz}, // 45:   720 x  576i @ 100Hz, pix repl
+	{ 46,{VPosHPos,2200, 563, 8333},{148,1920, 16, 540},{0x09, 84, 44,  2,  5,2200},  0x20, PIX_FREQ_148352KHz}, // 46:  1920 x 1080i @ 119.88/120Hz
+	{ 47,{VPosHPos,1650, 750, 8333},{220,1280, 21, 720},{0x00,106, 40,  5,  5,   0},  0x20, PIX_FREQ_148352KHz}, // 47:  1280 x  720p @ 119.88/120Hz
+	{ 48,{VNegHNeg, 858, 525, 8333},{ 60, 720, 31, 480},{0x00, 12, 62,  9,  6,   0},  0x10,  PIX_FREQ_54000KHz}, // 48:   720 x  480p @ 119.88/120Hz
+	{ 49,{VNegHNeg, 858, 525, 8333},{ 60, 720, 31, 480},{0x00, 12, 62,  9,  6,   0},  0x20,  PIX_FREQ_54000KHz}, // 49:   720 x  480p @ 119.88/120Hz
+	{ 50,{VNegHNeg, 858, 262, 8333},{ 57, 720, 16, 240},{0x09, 15, 62,  4,  3, 429},  0x15,  PIX_FREQ_54000KHz}, // 50:   720 x  480i @ 119.88/120Hz, pix repl
+	{ 51,{VNegHNeg, 858, 262, 8333},{ 57, 720, 16, 240},{0x09, 15, 62,  4,  3, 429},  0x25,  PIX_FREQ_54000KHz}, // 51:   720 x  480i @ 119.88/120Hz, pix repl
+	{ 52,{VNegHNeg, 864, 625, 5000},{ 68, 720, 40, 576},{0x00,  8, 64,  5,  5,   0},  0x10, PIX_FREQ_108000KHz}, // 52:   720 x  576p @ 200Hz
+	{ 53,{VNegHNeg, 864, 625, 5000},{ 68, 720, 40, 576},{0x00,  8, 64,  5,  5,   0},  0x20, PIX_FREQ_108000KHz}, // 53:   720 x  576p @ 200Hz
+	{ 54,{VNegHNeg, 864, 313, 5000},{ 69, 720, 20, 288},{0x09,  8, 63,  2,  3, 432},  0x15, PIX_FREQ_108000KHz}, // 54:   720 x  576i @ 200Hz, pix repl
+	{ 55,{VNegHNeg, 864, 313, 5000},{ 69, 720, 20, 288},{0x09,  8, 63,  2,  3, 432},  0x25, PIX_FREQ_108000KHz}, // 55:   720 x  576i @ 200Hz, pix repl
+	{ 56,{VNegHNeg, 858, 525, 4166},{ 60, 720, 31, 480},{0x00, 12, 62,  9,  6,   0},  0x10, PIX_FREQ_108000KHz}, // 56:   720 x  480p @ 239.76/240Hz
+	{ 57,{VNegHNeg, 858, 525, 4166},{ 60, 720, 31, 480},{0x00, 12, 62,  9,  6,   0},  0x20, PIX_FREQ_108000KHz}, // 57:   720 x  480p @ 239.76/240Hz
+	{ 58,{VNegHNeg, 858, 263, 4166},{ 57, 720, 16, 240},{0x09, 15, 62,  4,  3, 429},  0x15, PIX_FREQ_108000KHz}, // 58:   720 x  480i @ 239.76/240Hz, pix repl
+	{ 59,{VNegHNeg, 858, 263, 4166},{ 57, 720, 16, 240},{0x09, 15, 62,  4,  3, 429},  0x25, PIX_FREQ_108000KHz}, // 59:   720 x  480i @ 239.76/240Hz, pix repl
+
+	// Special
+	{  6,{VNegHNeg,1716, 262,16666},{114,1440, 16, 240},{0x09, 30,124,  4,  3, 858},  0x14,  PIX_FREQ_27000KHz}, // 60:   720 x  480i, pix repl
+	{  7,{VNegHNeg,1716, 262,16666},{114,1440, 16, 240},{0x09, 30,124,  4,  3, 858},  0x24,  PIX_FREQ_27000KHz}, // 61:   720 x  480i, pix repl
+	{  8,{VNegHNeg,1716, 262,16666},{114,1440, 16, 240},{0x00, 30,124,  4,  3,   0},  0x14,  PIX_FREQ_27000KHz}, // 62:   720 x  240p, pix repl
+	{  9,{VNegHNeg,1716, 262,16666},{114,1440, 16, 240},{0x00, 30,124,  4,  3,   0},  0x24,  PIX_FREQ_27000KHz}, // 63:   720 x  240p, pix repl
+
+	{ 21,{VNegHNeg,1728, 313,20000},{192,1440, 20, 288},{0x09, 20,128,  2,  3, 864},  0x14,  PIX_FREQ_27000KHz}, // 64:   720 x  576i, pix repl
+	{ 22,{VNegHNeg,1728, 313,20000},{192,1440, 20, 288},{0x09, 20,128,  2,  3, 864},  0x24,  PIX_FREQ_27000KHz}, // 65:   720 x  576i, pix repl
+	{ 23,{VNegHNeg,1728, 313,20000},{192,1440, 20, 288},{0x00, 20,128,  3,  3,   0},  0x14,  PIX_FREQ_27000KHz}, // 66:   720 x  288p, pix repl
+	{ 24,{VNegHNeg,1728, 313,20000},{192,1440, 20, 288},{0x00, 20,128,  3,  3,   0},  0x24,  PIX_FREQ_27000KHz}, // 67:   720 x  288p, pix repl
+
+	{ 44,{VNegHNeg,1728, 313,10000},{192,1440, 20, 288},{0x09, 20,128,  2,  3, 864},  0x14,  PIX_FREQ_54000KHz}, // 68:   720 x  576i @ 100Hz, pix repl
+	{ 45,{VNegHNeg,1728, 313,10000},{192,1440, 20, 288},{0x09, 20,128,  2,  3, 864},  0x24,  PIX_FREQ_54000KHz}, // 69:   720 x  576i @ 100Hz, pix repl
+
+	{ 50,{VNegHNeg,1716, 262, 8333},{114,1440, 16, 240},{0x09, 30,124,  4,  3, 858},  0x14,  PIX_FREQ_54000KHz}, // 70:   720 x  480i @ 119.88/120Hz, pix repl
+	{ 51,{VNegHNeg,1716, 262, 8333},{114,1440, 16, 240},{0x09, 30,124,  4,  3, 858},  0x24,  PIX_FREQ_54000KHz}, // 71:   720 x  480i @ 119.88/120Hz, pix repl
+
+	{ 54,{VNegHNeg,1728, 313, 5000},{192,1440, 20, 288},{0x09, 20,128,  2,  3, 864},  0x14, PIX_FREQ_108000KHz}, // 72:   720 x  576i @ 200Hz, pix repl
+	{ 55,{VNegHNeg,1728, 313, 5000},{192,1440, 20, 288},{0x09, 20,128,  2,  3, 864},  0x24, PIX_FREQ_108000KHz}, // 73:   720 x  576i @ 200Hz, pix repl
+
+	{ 58,{VNegHNeg,1716, 262, 4166},{114,1440, 16, 240},{0x09, 30,124,  4,  3, 858},  0x14, PIX_FREQ_108000KHz}, // 74:   720 x  480i @ 239.76/240Hz, pix repl
+	{ 59,{VNegHNeg,1716, 262, 4166},{114,1440, 16, 240},{0x09, 30,124,  4,  3, 858},  0x24, PIX_FREQ_108000KHz}, // 75:   720 x  480i @ 239.76/240Hz, pix repl
+
+	// PC Mode (start form 76)
+	{128,{VNegHPos, 832, 445,16683},{ 96, 640, 61, 350},{0x00, 28, 64, 32,  3,   0},  0x00,        PIX_FREQ_PC}, // 128:  640 x  350p @ 60Hz d
+	{129,{VNegHPos, 832, 445,14285},{ 96, 640, 61, 350},{0x00, 28, 64, 32,  3,   0},  0x00,        PIX_FREQ_PC}, // 129:  640 x  350p @ 70Hz d
+	{130,{VNegHPos, 832, 445,13333},{ 96, 640, 61, 350},{0x00, 28, 64, 32,  3,   0},  0x00,        PIX_FREQ_PC}, // 130:  640 x  350p @ 75Hz d
+	{131,{VNegHPos, 832, 445,11753},{ 96, 640, 61, 350},{0x00, 28, 64, 32,  3,   0},  0x00,        PIX_FREQ_PC}, // 131:  640 x  350p @ 85Hz
+	
+	{132,{VPosHNeg, 832, 445,16683},{ 96, 640, 42, 400},{0x00, 28, 64,  1,  3,   0},  0x00,        PIX_FREQ_PC}, // 132:  640 x  400p @ 60Hz d
+	{133,{VPosHNeg, 832, 445,14285},{ 96, 640, 42, 400},{0x00, 28, 64,  1,  3,   0},  0x00,        PIX_FREQ_PC}, // 133:  640 x  400p @ 70Hz d
+	{134,{VPosHNeg, 832, 445,13333},{ 96, 640, 42, 400},{0x00, 28, 64,  1,  3,   0},  0x00,        PIX_FREQ_PC}, // 134:  640 x  400p @ 75Hz d
+	{135,{VPosHNeg, 832, 445,11753},{ 96, 640, 42, 400},{0x00, 28, 64,  1,  3,   0},  0x00,        PIX_FREQ_PC}, // 135:  640 x  400p @ 85Hz
+
+	{136,{VPosHNeg, 900, 449,16683},{108, 720, 43, 400},{0x00, 14,108, 13,  2,   0},  0x00,        PIX_FREQ_PC}, // 136:  720 x  400p @ 60Hz d
+	{137,{VPosHNeg, 900, 449,14285},{108, 720, 43, 400},{0x00, 14,108, 13,  2,   0},  0x00,        PIX_FREQ_PC}, // 137:  720 x  400p @ 70Hz d
+	{138,{VPosHNeg, 900, 449,13333},{108, 720, 43, 400},{0x00, 14,108, 13,  2,   0},  0x00,        PIX_FREQ_PC}, // 138:  720 x  400p @ 75Hz d
+	{139,{VPosHNeg, 936, 446,11759},{108, 720, 43, 400},{0x00, 32, 72,  1,  3,   0},  0x00,        PIX_FREQ_PC}, // 139:  720 x  400p @ 85Hz
+
+	// VGA
+	{140,{VNegHNeg, 800, 525,16683},{ 48, 640, 34, 480},{0x00,  8,100,  8,  4,   0},  0x10,  PIX_FREQ_25175KHz}, // 140:  640 x  480p @ 60Hz
+	{141,{VNegHNeg, 832, 520,13734},{128, 640, 29, 480},{0x00, 20, 40,  9,  3,   0},  0x10,        PIX_FREQ_PC}, // 141:  640 x  480p @ 72Hz
+	{142,{VNegHNeg, 840, 500,13333},{120, 640, 17, 480},{0x00, 12, 64,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 142:  640 x  480p @ 75Hz
+	{143,{VNegHNeg, 832, 509,11763},{ 80, 640, 26, 480},{0x00, 52, 56,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 143:  640 x  480p @ 85Hz
+	
+	// SVGA
+	{144,{VPosHPos,1056, 628,16579},{ 88, 800, 24, 600},{0x00, 36,128,  1,  4,   0},  0x10,        PIX_FREQ_PC}, // 144:  800 x  600p @ 60Hz
+	{145,{VPosHPos,1040, 666,13852},{ 64, 800, 24, 600},{0x00, 52,120, 37,  6,   0},  0x10,        PIX_FREQ_PC}, // 145:  800 x  600p @ 72Hz
+	{146,{VPosHPos,1056, 625,13333},{160, 800, 22, 600},{0x00, 12, 80,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 146:  800 x  600p @ 75Hz
+	{147,{VPosHPos,1048, 631,11756},{152, 800, 28, 600},{0x00, 28, 64,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 147:  800 x  600p @ 85Hz
+
+	{148,{VPosHPos,1088, 517,16666},{112, 848, 24, 480},{0x00, 12,112,  6,  8,   0},  0x20,        PIX_FREQ_PC}, // 148:  848 x  480p @ 60Hz
+	{149,{VPosHPos,1088, 517,14285},{112, 848, 24, 480},{0x00, 12,112,  6,  8,   0},  0x20,        PIX_FREQ_PC}, // 149:  848 x  480p @ 70Hz d
+	{150,{VPosHPos,1088, 517,13333},{112, 848, 24, 480},{0x00, 12,112,  6,  8,   0},  0x20,        PIX_FREQ_PC}, // 150:  848 x  480p @ 75Hz d
+	{151,{VPosHPos,1088, 517,11764},{112, 848, 24, 480},{0x00, 12,112,  6,  8,   0},  0x20,        PIX_FREQ_PC}, // 151:  848 x  480p @ 85Hz d
+
+	// XGA
+	{152,{VNegHNeg,1344, 806,16665},{160,1024, 30, 768},{0x00, 20,136,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 152: 1024 x  768p @ 60Hz
+	{153,{VNegHNeg,1328, 806,14271},{144,1024, 30, 768},{0x00, 20,136,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 153: 1024 x  768p @ 70Hz
+	{154,{VPosHPos,1312, 800,13328},{176,1024, 29, 768},{0x00, 12, 96,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 154: 1024 x  768p @ 75Hz
+	{155,{VPosHPos,1376, 808,11765},{208,1024, 37, 768},{0x00, 44, 96,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 155: 1024 x  768p @ 85Hz
+
+	{156,{VPosHPos,1600, 900,16666},{256,1152, 33, 864},{0x00, 60,128,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 156: 1152 x  864p @ 60Hz d
+	{157,{VPosHPos,1600, 900,14285},{256,1152, 33, 864},{0x00, 60,128,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 157: 1152 x  864p @ 70Hz d
+	{158,{VPosHPos,1600, 900,13333},{256,1152, 33, 864},{0x00, 60,128,  1,  3,   0},  0x10, PIX_FREQ_108000KHz}, // 158: 1152 x  864p @ 75Hz
+	{159,{VPosHPos,1600, 900,11764},{256,1152, 33, 864},{0x00, 60,128,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 159: 1152 x  864p @ 85Hz d
+
+	{160,{VPosHNeg,1664, 798,16702},{192,1280, 21, 768},{0x00, 60,128,  3,  7,   0},  0x20,        PIX_FREQ_PC}, // 160: 1280 x  768p @ 60Hz
+	{161,{VPosHNeg,1696, 805,14285},{208,1280, 28, 768},{0x00, 76,128,  3,  7,   0},  0x20,        PIX_FREQ_PC}, // 161: 1280 x  768p @ 70Hz d
+	{162,{VPosHNeg,1696, 805,13352},{208,1280, 28, 768},{0x00, 76,128,  3,  7,   0},  0x20,        PIX_FREQ_PC}, // 162: 1280 x  768p @ 75Hz
+	{163,{VPosHNeg,1712, 809,11787},{216,1280, 32, 768},{0x00, 76,136,  3,  7,   0},  0x20,        PIX_FREQ_PC}, // 163: 1280 x  768p @ 85Hz
+
+	{164,{VPosHPos,1800,1000,16666},{312,1280, 37, 960},{0x00, 92,112,  1,  3,   0},  0x10, PIX_FREQ_108000KHz}, // 164: 1280 x  960p @ 60Hz
+	{165,{VPosHPos,1728,1011,14285},{224,1280, 48, 960},{0x00, 60,160,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 165: 1280 x  960p @ 70Hz d
+	{166,{VPosHPos,1728,1011,13333},{224,1280, 48, 960},{0x00, 60,160,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 166: 1280 x  960p @ 75Hz d
+	{167,{VPosHPos,1728,1011,11764},{224,1280, 48, 960},{0x00, 60,160,  1,  3,   0},  0x10, PIX_FREQ_148500KHz}, // 167: 1280 x  960p @ 85Hz
+
+	// SXGA
+	{168,{VPosHPos,1688,1066,16661},{248,1280, 39,1024},{0x00, 44,112,  1,  3,   0},  0x10, PIX_FREQ_108000KHz}, // 168: 1280 x 1024p @ 60Hz
+	{169,{VPosHPos,1688,1066,14285},{248,1280, 39,1024},{0x00, 12,144,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 169: 1280 x 1024p @ 70Hz d
+	{170,{VPosHPos,1688,1066,13328},{248,1280, 39,1024},{0x00, 12,144,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 170: 1280 x 1024p @ 75Hz
+	{171,{VPosHPos,1728,1072,11761},{224,1280, 45,1024},{0x00, 60,160,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 171: 1280 x 1024p @ 85Hz
+
+	{172,{VPosHPos,1792, 795,16662},{256,1360, 19, 768},{0x00, 60,112,  3,  6,   0},  0x20,        PIX_FREQ_PC}, // 172: 1360 x  768p @ 60Hz
+	{173,{VPosHPos,1792, 795,14285},{256,1360, 19, 768},{0x00, 60,112,  3,  6,   0},  0x20,        PIX_FREQ_PC}, // 173: 1360 x  768p @ 70Hz d
+	{174,{VPosHPos,1792, 795,13333},{256,1360, 19, 768},{0x00, 60,112,  3,  6,   0},  0x20,        PIX_FREQ_PC}, // 174: 1360 x  768p @ 75Hz d
+	{175,{VPosHPos,1792, 795,11764},{256,1360, 19, 768},{0x00, 60,112,  3,  6,   0},  0x20,        PIX_FREQ_PC}, // 175: 1360 x  768p @ 85Hz d
+
+	{176,{VPosHNeg,1864,1089,16672},{232,1400, 33,1050},{0x00, 84,144,  3,  4,   0},  0x10,        PIX_FREQ_PC}, // 176: 1400 x 1050p @ 60Hz
+	{177,{VPosHNeg,1896,1099,14285},{248,1400, 43,1050},{0x00,100,144,  3,  4,   0},  0x10,        PIX_FREQ_PC}, // 177: 1400 x 1050p @ 70Hz d
+	{178,{VPosHNeg,1896,1099,13357},{248,1400, 43,1050},{0x00,100,144,  3,  4,   0},  0x10,        PIX_FREQ_PC}, // 178: 1400 x 1050p @ 75Hz
+	{179,{VPosHNeg,1912,1105,11770},{256,1400, 49,1050},{0x00,100,152,  3,  4,   0},  0x10,        PIX_FREQ_PC}, // 179: 1400 x 1050p @ 85Hz
+
+	{180,{VPosHNeg,1904, 934,16698},{232,1440, 26, 900},{0x00, 76,152,  3,  6,   0},  0x00,        PIX_FREQ_PC}, // 180: 1440 x  900p @ 60Hz
+	{181,{VPosHNeg,1936, 942,14285},{248,1440, 34, 900},{0x00, 92,152,  3,  6,   0},  0x00,        PIX_FREQ_PC}, // 181: 1440 x  900p @ 70Hz d
+	{182,{VPosHNeg,1936, 942,13336},{248,1440, 34, 900},{0x00, 92,152,  3,  6,   0},  0x00,        PIX_FREQ_PC}, // 182: 1440 x  900p @ 75Hz
+	{183,{VPosHNeg,1952, 948,11786},{256,1440, 40, 900},{0x00,100,152,  3,  6,   0},  0x00,        PIX_FREQ_PC}, // 183: 1440 x  900p @ 85Hz
+
+	// UXGA
+	{184,{VPosHPos,2160,1250,16666},{304,1600, 47,1200},{0x00, 60,192,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 184: 1600 x 1200p @ 60Hz
+	{185,{VPosHPos,2160,1250,14285},{304,1600, 47,1200},{0x00, 60,192,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 185: 1600 x 1200p @ 70Hz
+	{186,{VPosHPos,2160,1250,13333},{304,1600, 47,1200},{0x00, 60,192,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 186: 1600 x 1200p @ 75Hz
+	{187,{VPosHPos,2160,1250,11764},{304,1600, 47,1200},{0x00, 60,192,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 186: 1600 x 1200p @ 85Hz
+	
+	{188,{VPosHNeg,2240,1089,16679},{280,1680, 31,1050},{0x00,100,176,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 188: 1680 x 1050p @ 60Hz
+	{189,{VPosHNeg,2272,1099,14285},{296,1680, 41,1050},{0x00,116,176,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 189: 1680 x 1050p @ 70Hz d
+	{190,{VPosHNeg,2272,1099,13352},{296,1680, 41,1050},{0x00,116,176,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 190: 1680 x 1050p @ 75Hz
+	{191,{VPosHNeg,2288,1105,11772},{304,1680, 47,1050},{0x00,124,176,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 191: 1680 x 1050p @ 85Hz
+
+	{192,{VPosHNeg,2448,1394,16666},{328,1792, 47,1344},{0x00,124,200,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 192: 1792 x 1344p @ 60Hz
+	{193,{VPosHNeg,2456,1417,14285},{352,1792, 70,1344},{0x00, 92,216,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 193: 1792 x 1344p @ 70Hz d
+	{194,{VPosHNeg,2456,1417,13333},{352,1792, 70,1344},{0x00, 92,216,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 194: 1792 x 1344p @ 75Hz
+	{195,{VPosHNeg,2456,1417,11764},{352,1792, 70,1344},{0x00, 92,216,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 195: 1792 x 1344p @ 85Hz d
+
+	{196,{VPosHNeg,2528,1439,16668},{352,1856, 44,1392},{0x00, 92,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 196: 1856 x 1392p @ 60Hz
+	{197,{VPosHNeg,2560,1500,14285},{352,1856,105,1392},{0x00,124,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 197: 1856 x 1392p @ 70Hz d
+	{198,{VPosHNeg,2560,1500,13333},{352,1856,105,1392},{0x00,124,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 198: 1856 x 1392p @ 75Hz
+	{199,{VPosHNeg,2560,1500,11764},{352,1856,105,1392},{0x00,124,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 199: 1856 x 1392p @ 85Hz d
+
+	{200,{VPosHNeg,2592,1245,16698},{336,1920, 37,1200},{0x00,132,200,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 200: 1920 x 1200p @ 60Hz
+	{201,{VPosHNeg,2608,1255,14285},{344,1920, 47,1200},{0x00,132,208,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 201: 1920 x 1200p @ 70Hz d
+	{202,{VPosHNeg,2608,1255,13345},{344,1920, 47,1200},{0x00,132,208,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 202: 1920 x 1200p @ 75Hz
+	{203,{VPosHNeg,2624,1262,11774},{352,1920, 54,1200},{0x00,140,208,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 203: 1920 x 1200p @ 85Hz
+
+	{204,{VPosHNeg,2600,1500,16666},{344,1920, 57,1440},{0x00,124,208,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 204: 1920 x 1440p @ 60Hz
+	{205,{VPosHNeg,2640,1500,14285},{352,1920, 57,1440},{0x00,140,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 205: 1920 x 1440p @ 70Hz d
+	{206,{VPosHNeg,2640,1500,13333},{352,1920, 57,1440},{0x00,140,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 206: 1920 x 1440p @ 75Hz
+	{207,{VPosHNeg,2640,1500,11774},{352,1920, 57,1440},{0x00,140,224,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 207: 1920 x 1440p @ 85Hz d
+
+	// Special
+	{144,{VPosHPos,1024, 625,17777},{128, 800, 23, 600},{0x00, 20, 72,  1,  2,   0},  0x10,        PIX_FREQ_PC}, // 144:  800 x  600p @ 56Hz *
+	{160,{VNegHPos,1440, 790,16668},{ 80,1280, 13, 768},{0x00, 44, 32,  3,  7,   0},  0x10,        PIX_FREQ_PC}, // 160: 1280 x  768p @ 60Hz * (Reduced Blanking)
+	{176,{VNegHPos,1560,1080,16681},{ 80,1400, 24,1050},{0x00, 44, 32,  3,  4,   0},  0x10,        PIX_FREQ_PC}, // 176: 1400 x 1050p @ 60Hz * (Reduced Blanking)
+	{180,{VNegHPos,1600, 926,16694},{ 80,1440, 18, 900},{0x00, 44, 32,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 180: 1440 x  900p @ 60Hz * (Reduced Blanking)
+	{184,{VPosHPos,2160,1250,15484},{304,1600, 47,1200},{0x00, 60,192,  1,  3,   0},  0x10,        PIX_FREQ_PC}, // 184: 1600 x 1200p @ 65Hz *
+	{188,{VNegHPos,1840,1080,16699},{ 80,1680, 22,1050},{0x00, 44, 32,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 188: 1680 x 1050p @ 60Hz * (Reduced Blanking)
+	{200,{VNegHPos,2080,1235,16680},{ 80,1920, 27,1200},{0x00, 44, 32,  3,  6,   0},  0x10,        PIX_FREQ_PC}, // 200: 1920 x 1200p @ 60Hz * (Reduced Blanking)
+};
+
+unsigned char EP932_VDO_Settings_Max = (sizeof(EP932_VDO_Settings)/sizeof(EP932_VDO_Settings[0]));
+
+//
+// Index = [Channel Number]
+//
+ADO_SETTINGS EP932_ADO_Settings[] = {
+	// SpeakerMapping, Flat
+	{0x00, 0xF0}, // 0.0 - Flat All
+	{0x00, 0x00}, // 2.0 - SD0
+	{0x04, 0xA0}, // 3.0 - SD0 +SD2
+	{0x08, 0xA0}, // 4.0 - SD0 +SD1 +SD2 
+	{0x07, 0x80}, // 4.1 - SD0 +SD3
+	{0x0B, 0x80}, // 5.1 - SD0 +SD1 +SD3
+	{0x0F, 0x00}, // 6.1 - SD0 +SD2 +SD3
+	{0x13, 0x00}, // 7.1 - SD0 +SD1 +SD2 +SD3
+};
+
+//
+// Index = [Pixel Freq Type]
+//
+N_CTS_SETTINGS N_CTS_32K[] = {
+	{ 4576, 28125},        // ( 28125,  4576),  25.20 MHz / 1.001
+	{ 4096, 25200},        // ( 25200,  4096),  25.20 MHz
+
+	{ 4096, 27000},        // ( 27000,  4096),  27.00 MHz
+	{ 4096, 27027},        // ( 27027,  4096),  27.00 MHz * 1.001
+
+	{ 4096, 54000},        // ( 54000,  4096),  54.00 MHz
+	{ 4096, 54054},        // ( 54054,  4096),  54.00 MHz * 1.001
+
+	{ 4096, 72000},        // ( 72000,  4096),  72.00 MHz
+
+	{11648,210937},        // (210937, 11648),  74.25 MHz / 1.001
+	{ 4096, 74250},        // ( 74250,  4096),  74.25 MHz
+
+	{ 4096,108000},        // (108000,  4096), 108.00 MHz
+	{ 4096,108108},        // (108108,  4096), 108.00 MHz * 1.001
+
+	{11648,421875},        // (421875, 11648), 148.50 MHz / 1.001
+	{ 4096,148500},        // (148500,  4096), 148.50 MHz
+
+	{ 4096,148500},        // PC
+};
+        
+N_CTS_SETTINGS N_CTS_44K1[] = {
+	{ 7007, 31250},        // ( 31250,  7007),  25.20 MHz / 1.001
+	{ 6272, 28000},        // ( 28000,  6272),  25.20 MHz
+
+	{ 6272, 30000},        // ( 30000,  6272),  27.00 MHz
+	{ 6272, 30030},        // ( 30030,  6272),  27.00 MHz * 1.001
+
+	{ 6272, 60000},        // ( 60000,  6272),  54.00 MHz
+	{ 6272, 60060},        // ( 60060,  6272),  54.00 MHz * 1.001
+
+	{ 6272, 80000},        // ( 80000,  6272),  72.00 MHz
+
+	{17836,234375},        // (234375, 17836),  74.25 MHz / 1.001
+	{ 6272, 82500},        // ( 82500,  6272),  74.25 MHz
+
+	{ 6272,120000},        // (120000,  6272), 108.00 MHz
+	{ 6272,120120},        // (120120,  6272), 108.00 MHz * 1.001
+
+	{ 8918,234375},        // (234375,  8918), 148.50 MHz / 1.001
+	{ 6272,165000},        // (165000,  6272), 148.50 MHz
+
+	{ 6272,165000},        // PC
+};
+
+N_CTS_SETTINGS N_CTS_48K[] = {
+	{ 6864, 28125},        // ( 28125,  6864),  25.20 MHz / 1.001
+	{ 6144, 25200},        // ( 25200,  6144),  25.20 MHz
+
+	{ 6144, 27000},        // ( 27000,  6144),  27.00 MHz
+	{ 6144, 27027},        // ( 27027,  6144),  27.00 MHz * 1.001
+
+	{ 6144, 54000},        // ( 54000,  6144),  54.00 MHz
+	{ 6144, 54054},        // ( 54054,  6144),  54.00 MHz * 1.001
+
+	{ 6144, 72000},        // ( 72000,  6144),  72.00 MHz
+
+	{11648,140625},        // (140625, 11648),  74.25 MHz / 1.001
+	{ 6144, 74250},        // ( 74250,  6144),  74.25 MHz
+
+	{ 6144, 108000},        // (108000,  6144), 108.00 MHz
+	{ 6144, 108108},        // (108108,  6144), 108.00 MHz * 1.001
+
+	{ 5824, 140625},        // (140625,  5824), 148.50 MHz / 1.001
+	{ 6144, 148500},        // (148500,  6144), 148.50 MHz
+
+	{ 6144, 148500},        // PC
+};
diff --git a/drivers/video/hdmi/ep932/EP932SettingsData.h b/drivers/video/hdmi/ep932/EP932SettingsData.h
new file mode 100644
index 0000000..7ff040d
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932SettingsData.h
@@ -0,0 +1,130 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932SettingsData.h
+
+  Description :  Head file of EP932SettingsData.
+
+\******************************************************************************/
+
+#ifndef EP932SETTINGDATA_H
+#define EP932SETTINGDATA_H
+
+// -----------------------------------------------------------------------------
+
+#define EP932_VDO_Settings_IT_Start 76
+
+// Definition of H/V Polarity
+#define  VPosHPos               0x00
+#define  VPosHNeg               0x04
+#define  VNegHPos               0x08
+#define  VNegHNeg               0x0C
+
+// Pixel Freq Type
+typedef enum {
+	PIX_FREQ_25175KHz = 0,
+	PIX_FREQ_25200KHz,
+
+	PIX_FREQ_27000KHz,
+	PIX_FREQ_27027KHz,
+
+	PIX_FREQ_54000KHz,
+	PIX_FREQ_54054KHz,
+
+	PIX_FREQ_72000KHz,
+
+	PIX_FREQ_74176KHz,
+	PIX_FREQ_74250KHz,
+
+	PIX_FREQ_108000KHz,
+	PIX_FREQ_108108KHz,
+
+	PIX_FREQ_148352KHz,
+	PIX_FREQ_148500KHz,
+
+	PIX_FREQ_PC
+
+} PIX_FREQ_TYPE;
+
+//
+// Index = [Video Code]
+//
+typedef struct _HVRES_TYPE {
+   unsigned char  HVPol;
+   unsigned short Hres;
+   unsigned short Vres;
+   unsigned short Vprd;
+} HVRES_TYPE, *PHVRES_TYPE;
+
+// DE Generation
+typedef struct _DE_GEN_SETTINGS { // VideoCode to
+	unsigned short DE_DLY;
+	unsigned short DE_CNT;
+	unsigned char  DE_TOP;
+	unsigned short DE_LIN;
+} DE_GEN_SETTINGS, *PDE_GEN_SETTINGS;
+
+// Embeded Sybc
+typedef struct _E_SYNC_SETTINGS { // VideoCode to
+	unsigned char  CTL;
+	unsigned short H_DLY;
+	unsigned short H_WIDTH;
+	unsigned char  V_DLY;
+	unsigned char  V_WIDTH;
+	unsigned short V_OFST;
+} E_SYNC_SETTINGS, *PE_SYNC_SETTINGS;
+
+// AVI Settings
+typedef struct _VDO_SETTINGS { 
+	unsigned char	VideoCode;
+	HVRES_TYPE      HVRes_Type;
+	DE_GEN_SETTINGS DE_Gen;
+	E_SYNC_SETTINGS E_Sync; // (HV_Gen)
+	unsigned char   AR_PR;
+	PIX_FREQ_TYPE   Pix_Freq_Type;
+} VDO_SETTINGS, *PVDO_SETTINGS;
+
+extern VDO_SETTINGS EP932_VDO_Settings[];
+extern unsigned char EP932_VDO_Settings_Max; // = (sizeof(EP932_VDO_Settings)/sizeof(EP932_VDO_Settings[0]))
+
+// -----------------------------------------------------------------------------
+
+//
+// Index = [Channel Number]
+//
+// Audio Channel and Allocation
+typedef struct _ADO_SETTINGS { // IIS ChannelNumber to
+	unsigned char SpeakerMapping;
+	unsigned char Flat;
+} ADO_SETTINGS, *PADO_SETTINGS;
+
+extern ADO_SETTINGS EP932_ADO_Settings[];
+
+// -----------------------------------------------------------------------------
+
+//
+// Index = [Pixel Freq Type]
+//
+// N and CTS
+typedef struct _N_CTS_SETTINGS { // IIS ChannelNumber to
+	unsigned long N;
+	unsigned long CTS; // Use hardware to calculate the CTS
+} N_CTS_SETTINGS, *PN_CTS_SETTINGS;
+
+extern N_CTS_SETTINGS N_CTS_32K[];
+extern N_CTS_SETTINGS N_CTS_44K1[];
+extern N_CTS_SETTINGS N_CTS_48K[];
+
+
+#endif
diff --git a/drivers/video/hdmi/ep932/EP932SettingsData.o b/drivers/video/hdmi/ep932/EP932SettingsData.o
new file mode 100644
index 0000000..0c875fc
Binary files /dev/null and b/drivers/video/hdmi/ep932/EP932SettingsData.o differ
diff --git a/drivers/video/hdmi/ep932/EP932_If.c b/drivers/video/hdmi/ep932/EP932_If.c
new file mode 100644
index 0000000..7ea52ce
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932_If.c
@@ -0,0 +1,1272 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932_If.c
+
+  Description :  EP932 IIC Interface
+
+\******************************************************************************/
+
+#include "EP932_If.h"
+#include "DDC_If.h"
+
+#include "EP932SettingsData.h"
+
+
+//--------------------------------------------------------------------------------------------------
+
+//#define EDID_ADDR       		0xA0     // EDID Address
+//#define EDID_SEGMENT_PTR		0x60
+#define EP932_ADDR				0x70
+#define EP932_ADDR_2			0x72
+#define HEY_ADDR				0xA8
+
+
+//#define Little_Endian
+
+//--------------------------------------------------------------------------------------------------
+
+// Private Data
+unsigned char IIC_EP932_Addr,IIC_Key_Addr;
+
+//int i, j;
+//SMBUS_STATUS status;
+//USHORT TempUSHORT;
+unsigned short TempUSHORT;
+
+unsigned char Temp_Data[15];
+unsigned char W_Data[2];
+
+// Global date for HDMI Transmiter
+unsigned char is_HDCP_AVMute;
+unsigned char is_AMute;
+unsigned char is_VMute;
+unsigned char is_HDMI;
+unsigned char is_RSEN;
+unsigned char Cache_EP932_DE_Control;
+
+// Private Functions
+SMBUS_STATUS IIC_Write(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size);
+SMBUS_STATUS IIC_Read(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size);
+
+
+//==================================================================================================
+//
+// Public Function Implementation
+//
+
+//--------------------------------------------------------------------------------------------------
+// Hardware Interface
+
+void EP932_If_Initial()	//customer setting
+{
+//	IIC_EP932_Addr = 0x70;
+	IIC_EP932_Addr = 0x38;
+	IIC_Key_Addr = 0xA8;	
+}
+
+void EP932_If_Reset(void)
+{
+	int i;
+
+	// Global date for HDMI Transmiter
+	is_HDCP_AVMute = 0;
+	is_AMute = 1;
+	is_VMute = 1;
+	is_HDMI = 0;
+	is_RSEN = 0;
+	Cache_EP932_DE_Control = 0x03;
+
+	// Initial Settings
+	EP932_Reg_Set_Bit(EP932_General_Control_1, EP932_General_Control_1__VTX);
+	EP932_Reg_Set_Bit(EP932_General_Control_1, EP932_General_Control_1__INT_OD);
+
+	// Default Audio Mute
+	EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__AMUTE);
+	EP932_Reg_Set_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__CTS_M);
+	// Default Video Mute
+	EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__VMUTE);
+
+	//
+	// Set Default AVI Info Frame
+	//
+	memset(Temp_Data, 0x00, 14);
+
+	// Set AVI Info Frame to RGB
+	Temp_Data[1] &= 0x60;
+	Temp_Data[1] |= 0x00; // RGB
+
+	// Set AVI Info Frame to 601
+	Temp_Data[2] &= 0xC0;
+	Temp_Data[2] |= 0x40;
+
+	// Write AVI Info Frame
+	Temp_Data[0] = 0;
+	for(i=1; i<14; ++i) {
+		Temp_Data[0] += Temp_Data[i];
+	}
+	Temp_Data[0] = ~(Temp_Data[0] - 1);
+	EP932_Reg_Write(EP932_AVI_Packet, Temp_Data, 14);
+
+
+	//
+	// Set Default ADO Info Frame
+	//
+	memset(Temp_Data, 0x00, 6);
+
+	// Write ADO Info Frame
+	Temp_Data[0] = 0;
+	for(i=1; i<6; ++i) {
+		Temp_Data[0] += Temp_Data[i];
+	}
+	Temp_Data[0] = ~(Temp_Data[0] - 1);
+	EP932_Reg_Write(EP932_ADO_Packet, Temp_Data, 6);
+}
+
+//--------------------------------------------------------------------------------------------------
+//
+// HDMI Transmiter (EP932-Tx Implementation)
+//
+
+void HDMI_Tx_Power_Down(void)
+{
+	// Software power down
+	EP932_Reg_Clear_Bit(EP932_General_Control_1, EP932_General_Control_1__PU);
+}
+
+void HDMI_Tx_Power_Up(void)
+{
+	// Software power up
+	EP932_Reg_Set_Bit(EP932_General_Control_1, EP932_General_Control_1__PU);
+}
+
+unsigned char HDMI_Tx_HTPLG(void)
+{
+	// Software HotPlug Detect
+	EP932_Reg_Read(EP932_General_Control_2, Temp_Data, 1);
+	is_RSEN = (Temp_Data[0] & EP932_General_Control_2__RSEN)? 1:0;
+	if(Temp_Data[0] & EP932_General_Control_2__HTPLG)
+	{
+//		DBG_printf(("HDMI_Tx_HTPLG connect\r\n"));
+		return 1;
+	}
+	else
+	{
+//		DBG_printf(("HDMI_Tx_HTPLG disconnect\r\n"));
+		return 0;
+	}
+	// This is for old DVI monitor compatibility. For HDMI TV, there is no need to poll the EDID.
+	//return Downstream_Rx_poll_EDID();
+}
+
+unsigned char HDMI_Tx_RSEN(void)
+{
+	return is_RSEN;
+}
+
+void HDMI_Tx_HDMI(void)
+{
+	if(!is_HDMI) {
+		is_HDMI = 1;
+		EP932_Reg_Set_Bit(EP932_General_Control_4, EP932_General_Control_4__HDMI);
+		DBG_printf(("Set to HDMI mode\r\n"));
+	}
+}
+
+void HDMI_Tx_DVI(void)
+{
+	if(is_HDMI) {
+		is_HDMI = 0;
+		EP932_Reg_Clear_Bit(EP932_General_Control_4, EP932_General_Control_4__HDMI);
+		DBG_printf(("Set to DVI mode\r\n"));
+	}
+}
+
+//------------------------------------
+// HDCP
+
+void HDMI_Tx_Mute_Enable(void)
+{
+	is_HDCP_AVMute = 1;
+	EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__AMUTE | EP932_Color_Space_Control__VMUTE);
+	EP932_Reg_Set_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__CTS_M);
+}
+
+void HDMI_Tx_Mute_Disable(void)
+{
+	is_HDCP_AVMute = 0;
+
+	if(!is_AMute) {
+		EP932_Reg_Clear_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__CTS_M);
+		EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__AMUTE);
+	}
+	if(!is_VMute) {
+		EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__VMUTE);
+	}
+}
+
+void HDMI_Tx_HDCP_Enable(void)
+{
+	EP932_Reg_Set_Bit(EP932_General_Control_5, EP932_General_Control_5__ENC_EN);
+}
+
+void HDMI_Tx_HDCP_Disable(void)
+{
+	EP932_Reg_Clear_Bit(EP932_General_Control_5, EP932_General_Control_5__ENC_EN);
+}
+
+void HDMI_Tx_RPTR_Set(void)
+{
+	EP932_Reg_Set_Bit(EP932_General_Control_5, EP932_General_Control_5__RPTR);
+}
+
+void HDMI_Tx_RPTR_Clear(void)
+{
+	EP932_Reg_Clear_Bit(EP932_General_Control_5, EP932_General_Control_5__RPTR);
+}
+
+void HDMI_Tx_write_AN(unsigned char *pAN)
+{
+	EP932_Reg_Write(EP932_AN, pAN, 8);
+}
+
+unsigned char HDMI_Tx_AKSV_RDY(void)
+{
+	status = EP932_Reg_Read(EP932_General_Control_5, Temp_Data, 1);
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: AKSV RDY - MCU IIC %d\r\n", (int)status));
+		return 0;
+	}
+	return (Temp_Data[0] & EP932_General_Control_5__AKSV_RDY)? 1:0;
+}
+
+unsigned char HDMI_Tx_read_AKSV(unsigned char *pAKSV)
+{
+	int i, j;
+
+	status = EP932_Reg_Read(EP932_AKSV, pAKSV, 5);
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: AKSV read - MCU IIC %d\r\n", (int)status));
+		return 0;
+	}
+
+	i = 0;
+	j = 0;
+	while (i < 5) {
+		Temp_Data[0] = 1;
+		while (Temp_Data[0]) {
+			if (pAKSV[i] & Temp_Data[0]) j++;
+			Temp_Data[0] <<= 1;
+		}
+		i++;
+	}
+	if(j != 20) {
+		DBG_printf(("ERROR: AKSV read - Key Wrong\r\n"));
+		return 0;
+	}
+	return 1;
+}
+
+void HDMI_Tx_write_BKSV(unsigned char *pBKSV)
+{
+	EP932_Reg_Write(EP932_BKSV, pBKSV, 5);
+}
+
+unsigned char HDMI_Tx_RI_RDY(void)
+{
+	EP932_Reg_Read(EP932_General_Control_5, Temp_Data, 1);
+	return (Temp_Data[0] & EP932_General_Control_5__RI_RDY)? 1:0;
+}
+
+unsigned char HDMI_Tx_read_RI(unsigned char *pRI)
+{
+	status = EP932_Reg_Read(EP932_RI, pRI, 2);
+	if(status != SMBUS_STATUS_Success) {
+		DBG_printf(("ERROR: Tx Ri read - MCU IIC %d\r\n", (int)status));
+		return 0;
+	}
+	return 1;
+}
+
+void HDMI_Tx_read_M0(unsigned char *pM0)
+{
+	status = EP932_Reg_Read(EP932_M0, pM0, 8);
+}
+
+SMBUS_STATUS HDMI_Tx_Get_Key(unsigned char *Key)
+{
+	return IIC_Read(HEY_ADDR, 0, Key, 512);
+}
+
+//------------------------------------
+// Special for config
+
+void HDMI_Tx_AMute_Enable(void)
+{
+	unsigned char Temp_byte[2];
+	if(!is_AMute) {
+		is_AMute = 1;
+		EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__AMUTE);
+		EP932_Reg_Set_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__CTS_M);
+
+		EP932_Reg_Clear_Bit(EP932_IIS_Control, EP932_IIS_Control__ADO_EN);	// add by eric.lu
+		EP932_Reg_Clear_Bit(EP932_IIS_Control, EP932_IIS_Control__AUDIO_EN);	// add by eric.lu
+
+		DBG_printf(("<<< AMute_enable >>>\r\n"));
+
+		//read for verify
+		EP932_Reg_Read(EP932_Color_Space_Control, Temp_byte, 1);
+		DBG_printf(("EP932_Color_Space_Control = 0x%02X\r\n",(int)Temp_byte[0]));
+		EP932_Reg_Read(EP932_Pixel_Repetition_Control, Temp_byte, 1);
+		DBG_printf(("EP932_Pixel_Repetition_Control = 0x%02X\r\n",(int)Temp_byte[0]));
+		// add end
+	}
+}
+
+void HDMI_Tx_AMute_Disable(void)
+{
+	unsigned char Temp_byte[2];
+	if(is_AMute) {
+		is_AMute = 0;
+		if(!is_HDCP_AVMute) {
+			EP932_Reg_Clear_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__CTS_M);
+			EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__AMUTE);
+
+			EP932_Reg_Set_Bit(EP932_IIS_Control, EP932_IIS_Control__ADO_EN);		// add by eric.lu
+			EP932_Reg_Set_Bit(EP932_IIS_Control, EP932_IIS_Control__AUDIO_EN);	// add by eric.lu
+
+			DBG_printf(("<<< AMute_disable >>>\r\n"));
+
+			//read for verify
+			EP932_Reg_Read(EP932_Color_Space_Control, Temp_byte, 1);
+			DBG_printf(("EP932_Color_Space_Control = 0x%02X\r\n",(int)Temp_byte[0]));
+			EP932_Reg_Read(EP932_Pixel_Repetition_Control, Temp_byte, 1);
+			DBG_printf(("EP932_Pixel_Repetition_Control = 0x%02X\r\n",(int)Temp_byte[0]));
+			// add end
+		}
+	}
+}
+
+void HDMI_Tx_VMute_Enable(void)
+{
+	if(!is_VMute) {
+		is_VMute = 1;
+		EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__VMUTE);
+
+		DBG_printf(("<<< VMute_enable >>>\r\n"));
+	}
+}
+
+void HDMI_Tx_VMute_Disable(void)
+{
+	if(is_VMute) {
+		is_VMute = 0;
+		if(!is_HDCP_AVMute) {
+			EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__VMUTE);
+
+			DBG_printf(("<<< VMute_disable >>>\r\n"));
+		}
+	}
+}
+
+void HDMI_Tx_Video_Config(PVDO_PARAMS Params)
+{
+	int i;
+	DBG_printf(("\r\nStart Tx Video Config\r\n"));
+
+	//
+	// Disable Video
+	//
+	EP932_Reg_Clear_Bit(EP932_IIS_Control, EP932_IIS_Control__AVI_EN);
+
+	//
+	// Video Settings
+	//
+	// Interface
+	EP932_Reg_Read(EP932_General_Control_3, Temp_Data, 1);
+	Temp_Data[0] &= ~0xF0;
+	Temp_Data[0] |= Params->Interface & 0xF0;
+	EP932_Reg_Write(EP932_General_Control_3, Temp_Data, 1);
+
+	EP932_Reg_Read(EP932_General_Control_1, Temp_Data, 1);
+	Temp_Data[0] &= ~0x0E;
+	Temp_Data[0] |= Params->Interface & 0x0E;
+	EP932_Reg_Write(EP932_General_Control_1, Temp_Data, 1);
+
+	if(Params->Interface & 0x01) {
+		EP932_Reg_Set_Bit(EP932_General_Control_4, EP932_General_Control_4__FMT12);
+	}
+	else {
+		EP932_Reg_Clear_Bit(EP932_General_Control_4, EP932_General_Control_4__FMT12);
+	}
+
+	// Sync Mode
+	switch(Params->SyncMode) {
+		default:
+	 	case SYNCMODE_HVDE:
+			// Disable E_SYNC
+			EP932_Reg_Clear_Bit(EP932_General_Control_4, EP932_General_Control_4__E_SYNC);
+			// Disable DE_GEN
+			Cache_EP932_DE_Control &= ~EP932_DE_Control__DE_GEN;
+			//EP932_Reg_Write(EP932_DE_Control, &Cache_EP932_DE_Control, 1);
+
+			// Regular VSO_POL, HSO_POL
+			if((Params->HVPol & VNegHPos) != (EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.HVPol & VNegHPos)) { // V
+				Cache_EP932_DE_Control |= EP932_DE_Control__VSO_POL; // Invert
+			}
+			else {
+				Cache_EP932_DE_Control &= ~EP932_DE_Control__VSO_POL;
+			}
+			if((Params->HVPol & VPosHNeg) != (EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.HVPol & VPosHNeg)) { // H
+				Cache_EP932_DE_Control |= EP932_DE_Control__HSO_POL; // Invert
+			}
+			else {
+				Cache_EP932_DE_Control &= ~EP932_DE_Control__HSO_POL;
+			}
+			DBG_printf(("Set Sync mode to DE mode\r\n"));
+			break;
+
+		case SYNCMODE_HV:
+			// Disable E_SYNC
+			EP932_Reg_Clear_Bit(EP932_General_Control_4, EP932_General_Control_4__E_SYNC);
+			// Enable DE_GEN
+			Cache_EP932_DE_Control |= EP932_DE_Control__DE_GEN;
+			//EP932_Reg_Write(EP932_DE_Control, &Cache_EP932_DE_Control, 1);
+
+			// Regular VSO_POL, HSO_POL
+			if((Params->HVPol & VNegHPos) != (EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.HVPol & VNegHPos)) { // V
+				Cache_EP932_DE_Control |= EP932_DE_Control__VSO_POL; // Invert
+			}
+			else {
+				Cache_EP932_DE_Control &= ~EP932_DE_Control__VSO_POL;
+			}
+			if((Params->HVPol & VPosHNeg) != (EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.HVPol & VPosHNeg)) { // H
+				Cache_EP932_DE_Control |= EP932_DE_Control__HSO_POL; // Invert
+			}
+			else {
+				Cache_EP932_DE_Control &= ~EP932_DE_Control__HSO_POL;
+			}
+
+			// Set DE generation params
+			if(Params->VideoSettingIndex < EP932_VDO_Settings_Max) {
+				Cache_EP932_DE_Control &= ~0x03;
+
+			#ifdef Little_Endian
+				Cache_EP932_DE_Control |= ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_DLY)[1];
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_DLY)[0];
+				EP932_Reg_Write(EP932_DE_DLY, Temp_Data, 1);
+			#else	// Big Endian
+				Cache_EP932_DE_Control |= ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_DLY)[0];
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_DLY)[1];
+				EP932_Reg_Write(EP932_DE_DLY, Temp_Data, 1);
+			#endif
+
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_TOP)[0];
+				EP932_Reg_Write(EP932_DE_TOP, Temp_Data, 1);
+
+			#ifdef Little_Endian
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_CNT)[0];
+				Temp_Data[1] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_CNT)[1];
+				EP932_Reg_Write(EP932_DE_CNT, Temp_Data, 2);
+			#else	// Big Endian
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_CNT)[1];
+				Temp_Data[1] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_CNT)[0];
+				EP932_Reg_Write(EP932_DE_CNT, Temp_Data, 2);
+			#endif
+
+
+			#ifdef Little_Endian
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_LIN)[1];
+				Temp_Data[1] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_LIN)[0];
+				EP932_Reg_Write(EP932_DE_LIN, Temp_Data, 2);
+			#else	// Big Endian
+				Temp_Data[0] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_LIN)[1];
+				Temp_Data[1] = ((unsigned char *)&EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_LIN)[0];
+				EP932_Reg_Write(EP932_DE_LIN, Temp_Data, 2);
+			#endif
+
+				DBG_printf(("Update DE_GEN params %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_DLY));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_CNT));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_TOP));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].DE_Gen.DE_LIN));
+				DBG_printf(("\r\n"));
+			}
+			else {
+				DBG_printf(("ERROR: VideoCode overflow DE_GEN table\r\n"));
+			}
+			break;
+
+		case SYNCMODE_Embeded:
+			// Disable DE_GEN
+			Cache_EP932_DE_Control &= ~EP932_DE_Control__DE_GEN;
+			// Enable E_SYNC
+			EP932_Reg_Set_Bit(EP932_General_Control_4, EP932_General_Control_4__E_SYNC);
+
+			// Set E_SYNC params
+			if(Params->VideoSettingIndex < EP932_VDO_Settings_Max) {
+
+				Temp_Data[0] = EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.CTL;
+				EP932_Reg_Write(EP932_Embedded_Sync, Temp_Data, 1);
+
+				TempUSHORT = EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_DLY;
+				if(!(Params->Interface & 0x04)) { // Mux Mode
+					TempUSHORT += 2;
+				}
+
+			#ifdef Little_Endian
+				Temp_Data[0] = ((BYTE *)&TempUSHORT)[0];
+				Temp_Data[1] = ((BYTE *)&TempUSHORT)[1];
+				EP932_Reg_Write(EP932_H_Delay, Temp_Data, 2);
+			#else	// Big Endian
+				Temp_Data[0] = ((BYTE *)&TempUSHORT)[1];
+				Temp_Data[1] = ((BYTE *)&TempUSHORT)[0];
+				EP932_Reg_Write(EP932_H_Delay, Temp_Data, 2);
+			#endif
+
+				
+			#ifdef Little_Endian
+				Temp_Data[0] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_WIDTH)[0];
+				Temp_Data[1] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_WIDTH)[1];
+				EP932_Reg_Write(EP932_H_Width, Temp_Data, 2);
+			#else	// Big Endian
+				Temp_Data[0] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_WIDTH)[1];
+				Temp_Data[1] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_WIDTH)[0];
+				EP932_Reg_Write(EP932_H_Width, Temp_Data, 2);
+			#endif
+
+				Temp_Data[0] = EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_DLY;
+				EP932_Reg_Write(EP932_V_Delay, Temp_Data, 1);
+				//DBG_printf(("[0x85]= 0x%02X\r\n",(int)Temp_Data[0]));
+
+				Temp_Data[0] = EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_WIDTH;
+				EP932_Reg_Write(EP932_V_Width, Temp_Data, 1);
+				//DBG_printf(("[0x86]= 0x%02X\r\n",(int)Temp_Data[0]));
+
+			#ifdef Little_Endian
+				Temp_Data[0] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_OFST)[0];
+				Temp_Data[1] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_OFST)[1];
+				EP932_Reg_Write(EP932_V_Off_Set, Temp_Data, 2);
+			#else	// Big Endian
+				Temp_Data[0] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_OFST)[1];
+				Temp_Data[1] = ((BYTE *)&EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_OFST)[0];
+				EP932_Reg_Write(EP932_V_Off_Set, Temp_Data, 2);
+			#endif
+
+				DBG_printf(("Update E_SYNC params 0x%02X", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.CTL));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_DLY));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.H_WIDTH));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_DLY));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_WIDTH));
+				DBG_printf((", %u", (unsigned short)EP932_VDO_Settings[Params->VideoSettingIndex].E_Sync.V_OFST));
+				DBG_printf(("\r\n"));
+
+
+				for(i=0x80; i<=0x88; i++)
+				{
+					EP932_Reg_Read(i, Temp_Data, 1);
+					DBG_printf(("EP932_reg[0x%02X]=0x%02X\r\n",(int)i,(int)Temp_Data[0]));
+				}
+
+
+				// Regular VSO_POL, HSO_POL
+				if(EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.HVPol & VNegHPos) { // VNeg?
+					Cache_EP932_DE_Control |= EP932_DE_Control__VSO_POL;
+				}
+				else {
+					Cache_EP932_DE_Control &= ~EP932_DE_Control__VSO_POL;
+				}
+				if(EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.HVPol & VPosHNeg) { // HNeg?
+					Cache_EP932_DE_Control |= EP932_DE_Control__HSO_POL;
+				}
+				else {
+					Cache_EP932_DE_Control &= ~EP932_DE_Control__HSO_POL;
+				}
+			}
+			else {
+				DBG_printf(("ERROR: VideoCode overflow E_SYNC table\r\n"));
+			}
+			break;
+	}
+	EP932_Reg_Write(EP932_DE_Control, &Cache_EP932_DE_Control, 1);
+
+	// Pixel Repetition
+	EP932_Reg_Read(EP932_Pixel_Repetition_Control, Temp_Data, 1);
+	Temp_Data[0] &= ~EP932_Pixel_Repetition_Control__PR;
+	if(Params->VideoSettingIndex < EP932_VDO_Settings_Max) {
+		Temp_Data[0] |= EP932_VDO_Settings[Params->VideoSettingIndex].AR_PR & 0x03;
+	}
+	EP932_Reg_Write(EP932_Pixel_Repetition_Control, Temp_Data, 1);
+
+	// Color Space
+	switch(Params->FormatIn) {
+		default:
+	 	case COLORFORMAT_RGB:
+			EP932_Reg_Clear_Bit(EP932_General_Control_4, EP932_General_Control_4__YCC_IN | EP932_General_Control_4__422_IN);
+			DBG_printf(("Set to RGB In\r\n"));
+			break;
+	 	case COLORFORMAT_YCC444:
+			EP932_Reg_Set_Bit(EP932_General_Control_4, EP932_General_Control_4__YCC_IN);
+			EP932_Reg_Clear_Bit(EP932_General_Control_4, EP932_General_Control_4__422_IN);
+			DBG_printf(("Set to YCC444 In\r\n"));
+			break;
+	 	case COLORFORMAT_YCC422:
+			EP932_Reg_Set_Bit(EP932_General_Control_4, EP932_General_Control_4__YCC_IN | EP932_General_Control_4__422_IN);
+			DBG_printf(("Set to YCC422 In\r\n"));
+			break;
+	}
+	switch(Params->FormatOut) {
+		default:
+	 	case COLORFORMAT_RGB:
+			// Set to RGB
+			if(Params->VideoSettingIndex < EP932_VDO_Settings_IT_Start) { // CE Timing
+				EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__YCC_OUT | EP932_Color_Space_Control__422_OUT);
+				EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__YCC_Range); // Output limit range RGB
+			}
+			else { // IT Timing
+				EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__YCC_OUT | EP932_Color_Space_Control__422_OUT | EP932_Color_Space_Control__YCC_Range);
+			}
+			DBG_printf(("Set to RGB Out\r\n"));
+			break;
+
+	 	case COLORFORMAT_YCC444:
+			// Set to YCC444
+			EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__YCC_OUT);
+			EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__422_OUT);
+			DBG_printf(("Set to YCC444 Out\r\n"));
+			break;
+			
+	 	case COLORFORMAT_YCC422:
+			// Set to YCC422
+			EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__YCC_OUT | EP932_Color_Space_Control__422_OUT);
+			DBG_printf(("Set to YCC422 Out\r\n"));
+			break;
+	}
+
+	// Color Space
+	switch(Params->ColorSpace) {
+		default:
+	 	case COLORSPACE_601:
+			// Set to 601
+			EP932_Reg_Clear_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__COLOR);
+			DBG_printf(("Set to 601 color definition\r\n"));
+			break;
+
+	 	case COLORSPACE_709:
+			// Set to 709
+			EP932_Reg_Set_Bit(EP932_Color_Space_Control, EP932_Color_Space_Control__COLOR);
+			DBG_printf(("Set to 709 color definition\r\n"));
+			break;
+	}
+
+	//
+	// Update AVI Info Frame
+	//
+	// Read AVI Info Frame
+	memset(Temp_Data, 0x00, 14);
+	//Temp_Data[1] &= 0x60;
+	switch(Params->FormatOut) {
+		default:
+	 	case COLORFORMAT_RGB:
+			// Set AVI Info Frame to RGB
+			Temp_Data[1] |= 0x00; // RGB
+			break;
+
+	 	case COLORFORMAT_YCC444:
+			// Set AVI Info Frame to RGB
+			Temp_Data[1] |= 0x40; // YCC 444
+			break;
+			
+	 	case COLORFORMAT_YCC422:
+			// Set AVI Info Frame to RGB
+			Temp_Data[1] |= 0x20; // YCC 422
+			break;
+	}
+	Temp_Data[1] |= 0x10; // Active Format Information
+	//Temp_Data[2] &= 0xC0;
+
+// add by eric.lu
+	switch(Params->SCAN) {
+		default:
+		case 3:						// future 	
+		case 0:						// NoData
+			Temp_Data[1] &= ~0x03; 	
+			break;
+		case 1:						// overscan
+			Temp_Data[1] |= 0x01; 	
+			break;
+		case 2:						// underscan
+			Temp_Data[1] |= 0x02; 	
+			break;
+	}
+// add of end
+
+	switch(Params->ColorSpace) {
+		default:
+	 	case COLORSPACE_601:
+			// Set AVI Info Frame to 601
+			Temp_Data[2] |= 0x40;
+			break;
+
+	 	case COLORSPACE_709:
+			// Set AVI Info Frame to 709
+			Temp_Data[2] |= 0x80;
+			break;
+	}
+	if(Params->VideoSettingIndex < EP932_VDO_Settings_Max) {
+		Temp_Data[2] |= EP932_VDO_Settings[Params->VideoSettingIndex].AR_PR & 0x30;// AVI Info Frame : Picture Aspect Ratio
+	}
+	Temp_Data[2] |= Params->AFARate & 0x0F;// AVI Info Frame : Active format Aspect Ratio
+	if(Params->VideoSettingIndex < EP932_VDO_Settings_IT_Start) {
+		Temp_Data[4] |= EP932_VDO_Settings[Params->VideoSettingIndex].VideoCode;// AVI Info Frame : Vedio Identification code
+	}
+	if(Params->VideoSettingIndex < EP932_VDO_Settings_Max) {
+		Temp_Data[5] |= (EP932_VDO_Settings[Params->VideoSettingIndex].AR_PR & 0x0C) >> 2;// AVI Info Frame : Pixel Repetition
+	}
+
+	// Write AVI Info Frame
+	Temp_Data[0] = 0x91;
+	for(i=1; i<6; ++i) {
+		Temp_Data[0] += Temp_Data[i];
+	}
+	Temp_Data[0] = ~(Temp_Data[0] - 1);	// checksum
+	EP932_Reg_Write(EP932_AVI_Packet, Temp_Data, 14);
+
+	DBG_printf(("AVI Info: "));
+	for(i=0; i<6; ++i) {
+		DBG_printf(("0x%0.2X, ", (int)Temp_Data[i] ));
+	}
+	DBG_printf(("\r\n"));
+
+	//
+	// Enable Video
+	//
+	EP932_Reg_Set_Bit(EP932_IIS_Control, EP932_IIS_Control__AVI_EN);
+}
+
+void HDMI_Tx_Audio_Config(PADO_PARAMS Params)
+{
+	int i;
+	unsigned char N_CTS_Index;
+	unsigned long N_Value, CTS_Value;
+	ADSFREQ FinalFrequency;
+	unsigned char FinalADSRate;
+
+	DBG_printf(("\r\nStart Tx Audio Config\r\n"));
+
+	//
+	// Audio Settings
+	//
+	// Update WS_M, WS_POL, SCK_POL
+	EP932_Reg_Read(EP932_IIS_Control, Temp_Data, 1);
+	Temp_Data[0] &= ~0x07;
+	Temp_Data[0] |= Params->Interface & 0x07;
+	EP932_Reg_Write(EP932_IIS_Control, Temp_Data, 1);
+
+	// Update Channel Status
+	if(Params->Interface & 0x08) { // IIS
+
+		Temp_Data[0] = 0;
+		// Update Flat | IIS
+		Temp_Data[0] |= EP932_ADO_Settings[Params->ChannelNumber].Flat;
+		// Update Channel Number
+		if(Params->ChannelNumber > 1) {	// 3 - 8 channel
+			Temp_Data[0] |= EP932_Packet_Control__LAYOUT;
+		}
+		EP932_Reg_Write(EP932_Packet_Control, Temp_Data, 1); // Clear IIS
+		Temp_Data[0] |= EP932_Packet_Control__IIS;
+		EP932_Reg_Write(EP932_Packet_Control, Temp_Data, 1); // Set   IIS
+
+		// Downsample Convert
+		FinalADSRate = Params->ADSRate;
+		switch(Params->ADSRate) {
+			default:
+			case 0: // Bypass
+				//DBG_printf(("Audio ADS = 0\r\n"));
+				FinalADSRate = 0;
+				FinalFrequency = Params->InputFrequency;
+				break;
+			case 1: // 1/2
+				//DBG_printf(("Audio ADS = 1_2\r\n"));
+				switch(Params->InputFrequency) {
+					default: // Bypass
+						//DBG_printf(("Audio ADS = 0\r\n"));
+						FinalADSRate = 0;
+						FinalFrequency = Params->InputFrequency;
+						break;
+					case ADSFREQ_88200Hz:
+						FinalFrequency = ADSFREQ_44100Hz;
+						break;
+					case ADSFREQ_96000Hz:
+						FinalFrequency = ADSFREQ_48000Hz;
+						break;
+					case ADSFREQ_176400Hz:
+						FinalFrequency = ADSFREQ_88200Hz;
+						break;
+					case ADSFREQ_192000Hz:
+						FinalFrequency = ADSFREQ_96000Hz;
+						break;
+				}
+				break;
+			case 2: // 1/3
+				//DBG_printf(("Audio ADS = 1_3\r\n"));
+				switch(Params->InputFrequency) {
+					default: // Bypass
+						//DBG_printf(("Audio ADS = 0\r\n"));
+						FinalADSRate = 0;
+						FinalFrequency = Params->InputFrequency;
+						break;
+					case ADSFREQ_96000Hz:
+						FinalFrequency = ADSFREQ_32000Hz;
+						break;
+				}
+				break;
+			case 3: // 1/4
+				//DBG_printf(("Audio ADS = 1_4\r\n"));
+				switch(Params->InputFrequency) {
+					default: // Bypass
+						//DBG_printf(("Audio ADS = 0\r\n"));
+						FinalADSRate = 0;
+						FinalFrequency = Params->InputFrequency;
+						break;
+					case ADSFREQ_176400Hz:
+						FinalFrequency = ADSFREQ_44100Hz;
+						break;
+					case ADSFREQ_192000Hz:
+						FinalFrequency = ADSFREQ_48000Hz;
+						break;
+				}
+				break;
+		}
+
+		// Update Down Sample ADSRate
+		EP932_Reg_Read(EP932_Pixel_Repetition_Control, Temp_Data, 1);
+		Temp_Data[0] &= ~0x30;
+		Temp_Data[0] |= (FinalADSRate << 4) & 0x30;
+		EP932_Reg_Write(EP932_Pixel_Repetition_Control, Temp_Data, 1);
+
+
+		// Set Channel Status
+		memset(Temp_Data, 0x00, 5);
+		Temp_Data[0] = (Params->NoCopyRight)? 0x04:0x00;
+		Temp_Data[1] = 0x00; 			// Category code ??
+		Temp_Data[2] = 0x00; 			// Channel number ?? | Source number ??
+		Temp_Data[3] = FinalFrequency; 	// Clock accuracy ?? | Sampling frequency
+		Temp_Data[4] = 0x01; 			// Original sampling frequency ?? | Word length ??
+		EP932_Reg_Write(EP932_Channel_Status, Temp_Data, 5);
+
+		DBG_printf(("CS Info: "));
+		for(i=0; i<5; ++i) {
+			DBG_printf(("0x%02X, ", (int)Temp_Data[i] ));
+		}
+		DBG_printf(("\r\n"));
+
+		EP932_Reg_Set_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__CS_M);
+	}
+	else { // SPIDIF
+
+		EP932_Reg_Set_Bit(EP932_Packet_Control, EP932_Packet_Control__IIS);
+		EP932_Reg_Clear_Bit(EP932_Packet_Control, EP932_Packet_Control__FLAT3 | EP932_Packet_Control__FLAT2 | EP932_Packet_Control__FLAT1 | EP932_Packet_Control__FLAT0 |
+			EP932_Packet_Control__IIS | EP932_Packet_Control__LAYOUT);
+
+		// No Downsample
+		FinalADSRate = 0;
+		FinalFrequency = Params->InputFrequency;
+
+		// Disable Down Sample and Bypass Channel Status
+		EP932_Reg_Clear_Bit(EP932_Pixel_Repetition_Control, EP932_Pixel_Repetition_Control__ADSR | EP932_Pixel_Repetition_Control__CS_M);
+
+		Params->ChannelNumber = 0;
+	}
+
+	// Set CTS/N
+	if(Params->VideoSettingIndex < EP932_VDO_Settings_Max) {
+		N_CTS_Index = EP932_VDO_Settings[Params->VideoSettingIndex].Pix_Freq_Type;
+		if(EP932_VDO_Settings[Params->VideoSettingIndex].HVRes_Type.Vprd % 500) { // 59.94/60 Hz
+			N_CTS_Index += Params->VFS;
+			DBG_printf(("N_CTS_Index Shift %d\r\n", (int)Params->VFS));
+		}
+	}
+	else {
+		DBG_printf(("Use default N_CTS_Index\r\n"));
+		N_CTS_Index = PIX_FREQ_25200KHz;
+	}
+	switch(FinalFrequency) {
+
+		default:
+		case ADSFREQ_32000Hz:
+			DBG_printf(("Set to 32KHz"));
+			N_Value = N_CTS_32K[N_CTS_Index].N;
+			CTS_Value = N_CTS_32K[N_CTS_Index].CTS;
+			break;
+		case ADSFREQ_44100Hz:
+			DBG_printf(("Set to 44.1KHz"));
+			N_Value = N_CTS_44K1[N_CTS_Index].N;
+			CTS_Value = N_CTS_44K1[N_CTS_Index].CTS;
+			break;
+		case ADSFREQ_48000Hz:
+			DBG_printf(("Set to 48KHz"));
+			N_Value = N_CTS_48K[N_CTS_Index].N;
+			CTS_Value = N_CTS_48K[N_CTS_Index].CTS;
+			break;
+		case ADSFREQ_88200Hz:
+			DBG_printf(("Set to 88.2KHz"));
+			N_Value = N_CTS_44K1[N_CTS_Index].N * 2;
+			CTS_Value = N_CTS_44K1[N_CTS_Index].CTS * 2;
+			break;
+		case ADSFREQ_96000Hz:
+			DBG_printf(("Set to 96KHz"));
+			N_Value = N_CTS_48K[N_CTS_Index].N * 2;
+			CTS_Value = N_CTS_48K[N_CTS_Index].CTS * 2;
+			break;
+		case ADSFREQ_176400Hz:
+			DBG_printf(("Set to 176.4KHz"));
+			N_Value = N_CTS_44K1[N_CTS_Index].N * 4;
+			CTS_Value = N_CTS_44K1[N_CTS_Index].CTS * 4;
+			break;
+		case ADSFREQ_192000Hz:
+			DBG_printf(("Set to 192KHz"));
+			N_Value = N_CTS_48K[N_CTS_Index].N * 4;
+			CTS_Value = N_CTS_48K[N_CTS_Index].CTS * 4;
+			break;
+	}
+
+	DBG_printf((", N[%d]=%d(0x%X)", (int)N_CTS_Index, N_Value, N_Value));
+	DBG_printf((", CTS=%d(0x%X) \r\n", CTS_Value, CTS_Value));
+
+	Temp_Data[0] = CTS_Value>>16;
+	EP932_Reg_Write(EP932_CTS, Temp_Data, 1);
+	Temp_Data[0] = CTS_Value>>8;
+	EP932_Reg_Write(0x61, Temp_Data, 1);
+	Temp_Data[0] = CTS_Value;
+	EP932_Reg_Write(0x62, Temp_Data, 1);
+
+	Temp_Data[0] = N_Value>>16;
+	EP932_Reg_Write(EP932_N, Temp_Data, 1);
+	Temp_Data[0] = N_Value>>8;
+	EP932_Reg_Write(0x64, Temp_Data, 1);
+	Temp_Data[0] = N_Value;
+	EP932_Reg_Write(0x65, Temp_Data, 1);
+
+// read for verify
+
+	EP932_Reg_Read(EP932_CTS, Temp_Data, 1);
+	DBG_printf(("EP932_CTS_0(Reg addr 0x60) = 0x%02X\r\n",(int)Temp_Data[0]));
+	EP932_Reg_Read(0x61, Temp_Data, 1);
+	DBG_printf(("EP932_CTS_1(Reg addr 0x61) = 0x%02X\r\n",(int)Temp_Data[0]));
+	EP932_Reg_Read(0x62, Temp_Data, 1);
+	DBG_printf(("EP932_CTS_2(Reg addr 0x62) = 0x%02X\r\n",(int)Temp_Data[0]));
+
+	EP932_Reg_Read(EP932_N, Temp_Data, 1);
+	DBG_printf(("EP932_N_0(Reg addr 0x63) = 0x%02X\r\n",(int)Temp_Data[0]));
+	EP932_Reg_Read(0x64, Temp_Data, 1);
+	DBG_printf(("EP932_N_1(Reg addr 0x64) = 0x%02X\r\n",(int)Temp_Data[0]));
+	EP932_Reg_Read(0x65, Temp_Data, 1);
+	DBG_printf(("EP932_N_2(Reg addr 0x65) = 0x%02X\r\n",(int)Temp_Data[0]));
+
+	//
+	// Update ADO Info Frame
+	//
+	// Set Default ADO Info Frame
+	memset(Temp_Data, 0x00, 6);
+
+	// Overwrite ADO Info Frame
+	Temp_Data[1] = Params->ChannelNumber;
+	Temp_Data[4] = EP932_ADO_Settings[Params->ChannelNumber].SpeakerMapping;
+
+	// Write ADO Info Frame back
+	Temp_Data[0] = 0x8F;
+	for(i=1; i<6; ++i) {
+		Temp_Data[0] += Temp_Data[i];
+	}
+	Temp_Data[0] = ~(Temp_Data[0] - 1);
+	EP932_Reg_Write(EP932_ADO_Packet, Temp_Data, 6);
+
+	DBG_printf(("ADO Info: "));
+	for(i=0; i<6; ++i) {
+		DBG_printf(("0x%0.2X, ", (int)Temp_Data[i] ));
+	}
+	DBG_printf(("\r\n"));
+
+	EP932_Reg_Set_Bit(EP932_IIS_Control, EP932_IIS_Control__ACR_EN | EP932_IIS_Control__ADO_EN | EP932_IIS_Control__AUDIO_EN);
+}
+
+//--------------------------------------------------------------------------------------------------
+//
+// Hardware Interface
+//
+SMBUS_STATUS Key_Read(unsigned char ByteAddr, void *Data, unsigned int Size)
+{
+	return IIC_Read(IIC_Key_Addr, ByteAddr, Data, Size);
+}
+
+SMBUS_STATUS Key_Write(unsigned char ByteAddr, void *Data, unsigned int Size)
+{
+	return IIC_Write(IIC_Key_Addr, ByteAddr, Data, Size);
+}
+
+SMBUS_STATUS EP932_Reg_Read(unsigned char ByteAddr, unsigned char *Data, unsigned int Size)
+{
+	return IIC_Read(IIC_EP932_Addr, ByteAddr, Data, Size);
+}
+
+SMBUS_STATUS EP932_Reg_Write(unsigned char ByteAddr, unsigned char *Data, unsigned int Size)
+{
+#if 0
+	//DBG_printf(("EP932_Reg_Write 0x%02X, 0x%02X\r\n",(int)ByteAddr,(int)Data[0]));
+	unsigned char temp_data[255];
+	int i;
+	int ret;
+	IIC_Read(IIC_EP932_Addr,ByteAddr,temp_data,Size);	
+	for(i =0;i<Size;i++)
+		printk("[EP932_Reg_Write]before write [%x]%x\r\n",ByteAddr+i,temp_data[i]);
+
+	ret = IIC_Write(IIC_EP932_Addr, ByteAddr, Data, Size);
+
+	IIC_Read(IIC_EP932_Addr,ByteAddr,temp_data,Size);	
+	for(i =0;i<Size;i++)
+		printk("[EP932_Reg_Write]after write [%x]%x\r\n",ByteAddr+i,temp_data[i]);
+	 
+	return ret;
+#else
+	return  IIC_Write(IIC_EP932_Addr, ByteAddr, Data, Size);
+#endif
+}
+
+SMBUS_STATUS EP932_Reg_Set_Bit(unsigned char ByteAddr, unsigned char BitMask)
+{
+#if 0
+	unsigned char temp_data[255]; 
+	int ret;
+	IIC_Read(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+	printk("[EP932_Reg_Set_Bit]bfore set [%x]%x bitMask[%x]\r\n",ByteAddr,Temp_Data[0],BitMask);
+
+	// Write back to Reg Reg_Addr
+	Temp_Data[0] |= BitMask;
+
+	ret = IIC_Write(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+	IIC_Read(IIC_EP932_Addr, ByteAddr, temp_data, 1);
+	printk("[EP932_Reg_Set_Bit] after set [%x]%x\r\n",ByteAddr,temp_data[0]);
+
+	return ret;
+#else
+	IIC_Read(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+
+	// Write back to Reg Reg_Addr
+	Temp_Data[0] |= BitMask;
+
+	return IIC_Write(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+#endif
+}
+
+SMBUS_STATUS EP932_Reg_Clear_Bit(unsigned char ByteAddr, unsigned char BitMask)
+{
+#if 0
+	unsigned char temp_data[255]; 
+	int ret;
+	IIC_Read(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+	printk("[EP932_Reg_Clear_Bit]bfore clear [%x]%x bitMask[%x]\r\n",ByteAddr,Temp_Data[0],BitMask);
+
+	// Write back to Reg Reg_Addr
+	Temp_Data[0] &= ~BitMask;
+
+	ret = IIC_Write(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+
+	IIC_Read(IIC_EP932_Addr, ByteAddr, temp_data, 1);
+	printk("[EP932_Reg_Clear_Bit] after clear [%x]%x\r\n",ByteAddr,temp_data[0]);
+
+	return ret;
+#else
+	IIC_Read(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+
+	// Write back to Reg Reg_Addr
+	Temp_Data[0] &= ~BitMask;
+
+	return IIC_Write(IIC_EP932_Addr, ByteAddr, Temp_Data, 1);
+#endif
+}
+
+
+//==================================================================================================
+//
+// Private Functions
+//
+
+SMBUS_STATUS IIC_Write(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size)
+{
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with Customer's I2C ?????????????????????????????
+	// return 0; for success
+	// return 2; for No_ACK
+	// return 4; for Arbitration
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+
+	//DBG_printf(("IIC_Write 0x%02X, 0x%02X\r\n",(int)ByteAddr,(int)Data[0]));
+
+	// need to use customer's I2C  function
+	//result = TLGI2C_WriteReg_EP932M(IICAddr, ByteAddr, Data, Size);
+	
+#if 0
+	int result = 1;
+	int i;
+	unsigned long to, tn;
+	to = get_ticks();
+
+	//DBG_printf(("IIC_Write 0x%02X, 0x%02X\r\n",(int)ByteAddr,(int)Data[0]));
+
+	// need to use customer's I2C  function
+	//result = TLGI2C_WriteReg_EP932M(IICAddr, ByteAddr, Data, Size);
+	if(iic_init(1,1,IICAddr,0,1,0)== FALSE)
+		return 1;
+
+	for(i = 0;i < Size;i++)
+	{
+		while(iic_write(1,ByteAddr+i,Data[i]) == 0)
+		{
+			tn = get_ticks();
+			if(tn > to + 500000) break;
+		}
+	}
+	return 0;
+#endif
+
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(Size + 1, GFP_KERNEL);
+	unsigned int i;
+
+	buf[0] = ByteAddr;
+	for(i=0;i<Size;i++)
+		buf[i + 1] = Data[i];
+
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = Size + 1,
+			.buf            = buf,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[IIC_Write]: unable to allocate memory for EDID.\n");
+		return -1; 
+	}
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_EP932_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[IIC_Write]: can't get i2c adapter\n");
+
+		return -1; 
+	}
+
+	if (i2c_transfer(adapter, msgs, 1) != 1)
+		return -1; 
+
+	kfree(buf);
+
+	return 0;
+}
+
+SMBUS_STATUS IIC_Read(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, unsigned int Size)
+{
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+	// How to implement this with Customer's I2C ?????????????????????????????
+	// return 0; for success
+	// return 2; for No_ACK
+	// return 4; for Arbitration
+	/////////////////////////////////////////////////////////////////////////////////////////////////
+
+#if 0
+	int result = 1;
+	int i;
+	unsigned long to, tn;
+	to = get_ticks();
+	// need to use customer's I2C  function
+	//result = TLGI2C_ReadReg_EP932M(IICAddr, ByteAddr, Data, Size);
+
+/*
+	if(result != 0)
+	{
+		DBG_printf(("EP932M IIC_Read error : 0x%02X, 0x%02X, 0x%02X, %d\r\n",(int)IICAddr,(int)ByteAddr,(int)Data[0],Size));
+	}
+*/
+	if(iic_init(1,1,IICAddr,0,1,0)== FALSE)
+		return 1;
+
+	for(i=0;i<Size;i++)
+	{
+		while(iic_writeread(1,ByteAddr+i,&Data[i]) == 0)
+		{
+			tn = get_ticks();
+			if(tn > to + 500000) break;
+		}
+	}
+
+	return 0;
+#endif
+
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(Size, GFP_KERNEL);
+/*	
+	struct i2c_msg msgs1[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = 1,
+			.buf            = &ByteAddr,
+		}
+	};
+
+	struct i2c_msg msgs2[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = I2C_M_RD,
+			.len            = Size,
+			.buf            = Data,
+		}
+	};
+*/
+
+	struct i2c_msg msgs1[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = I2C_M_NOSTART,
+			.len            = 1,
+			.buf            = &ByteAddr,
+		},{
+			.addr   = IICAddr,
+			.flags  = I2C_M_RD,
+			.len            = Size,
+			.buf            = Data,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[IIC_Read]: unable to allocate memory for Read.\n");
+		return -1; 
+	}
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_EP932_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[IIC_Read]: can't get i2c adapter\n");
+
+		return -1; 
+	}
+
+	if (i2c_transfer(adapter, msgs1, 2) != 2)
+		return -1; 
+/*
+	if (i2c_transfer(adapter, msgs2, 1) != 1)
+*/		return -1; 
+
+	kfree(buf);
+
+	return 0;
+}
diff --git a/drivers/video/hdmi/ep932/EP932_If.h b/drivers/video/hdmi/ep932/EP932_If.h
new file mode 100644
index 0000000..a298afe
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932_If.h
@@ -0,0 +1,166 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+  File        :  EP932_If.h 
+
+  Description :  Head file of EP932 Interface  
+
+\******************************************************************************/
+
+#ifndef EP932_IF_H
+#define EP932_IF_H
+
+//#include "EPcsapi.h"
+#include "EP932api.h"
+#include "EP932RegDef.h"
+
+//==================================================================================================
+//
+// Protected Data Member
+//
+
+typedef enum {
+	COLORSPACE_601 = 1,
+	COLORSPACE_709
+} COLORSPACE;
+
+typedef enum {
+	SYNCMODE_HVDE = 0,
+	SYNCMODE_HV,
+	SYNCMODE_Embeded
+} SYNCMODE;
+
+typedef enum {
+	COLORFORMAT_RGB = 0,
+	COLORFORMAT_YCC444,
+	COLORFORMAT_YCC422
+} COLORFORMAT;
+
+typedef enum {
+	AFAR_VideoCode = 0,
+	AFAR_4_3,
+	AFAR_16_9,
+	AFAR_14_9
+} AFAR;
+
+typedef enum {
+	SCAN_NoData = 0,
+	SCAN_OverScan,
+	SCAN_UnderScan,
+	SCAN_Future
+} SCAN_MODE;
+
+
+// Video Output Congif Params
+typedef struct _VDO_PARAMS {
+// Which cause Timing Change Reset
+	unsigned char 	Interface;				// DK[3:1], DKEN, DSEL, BSEL, EDGE, FMT12
+	unsigned char 	VideoSettingIndex;	// VIC
+	unsigned char 	HVPol;					// x, x, x, x, VSO_POL, HSO_POL, x, x
+	SYNCMODE 		SyncMode;				// 0 = HVDE, 1 = HV(DE Gen), 2 = Embedded Sync
+	COLORFORMAT 	FormatIn;				// 0 = RGB, 1 = YCC444, 2 = YCC422
+	COLORFORMAT 	FormatOut;				// 0 = RGB, 1 = YCC444, 2 = YCC422
+// Which don't cause Timing Chage Reset
+	COLORSPACE 		ColorSpace;			// 0 = Auto, 1 = 601, 2 = 709
+	AFAR 			AFARate;				// 0 = Auto, 1 = 4:3, 2 = 16:9, 3 = 14:9
+	SCAN_MODE   	SCAN;					// 0 = no data, 1 = overscan, 2 = underscan, 3 = future
+} VDO_PARAMS, *PVDO_PARAMS;
+
+typedef enum {
+	ADSFREQ_32000Hz = 0x03,
+	ADSFREQ_44100Hz = 0x00,
+	ADSFREQ_48000Hz = 0x02,
+	ADSFREQ_88200Hz = 0x08,
+	ADSFREQ_96000Hz = 0x0A,
+	ADSFREQ_176400Hz = 0x0C,
+	ADSFREQ_192000Hz = 0x0E
+} ADSFREQ;
+
+// Audio Output Congif Params
+typedef struct _ADO_PARAMS {
+	unsigned char 		Interface;				// x, x, x, x, IIS, WS_M, WS_POL, SCK_POL
+	unsigned char 		VideoSettingIndex;		// VIC
+	unsigned char 		ChannelNumber;			// 1 = 2 ch, 2 = 3 ch, ... , 5 = 5.1 ch, 7 = 7.1 ch
+	unsigned char 		ADSRate;				// 1 = SF/2, 2 = SF/3, 3 = SF/4 (Down Sample)
+	ADSFREQ		InputFrequency;			// ADSFREQ
+	unsigned char       	VFS; 					// 0 = 59.94Hz, 1 = 60Hz (Vertical Frequency Shift of Video)
+	unsigned char 		NoCopyRight;
+} ADO_PARAMS, *PADO_PARAMS;
+
+//==================================================================================================
+//
+// Public Functions
+//
+
+//--------------------------------------------------------------------------------------------------
+//
+// General
+//
+
+// All Interface Inital
+//extern void EP932_If_Initial(CSI2C_HANDLE E_handle, CSI2C_HANDLE K_handle);
+extern void EP932_If_Initial();
+extern void EP932_If_Reset(void);
+
+
+//--------------------------------------------------------------------------------------------------
+//
+// HDMI Transmiter Interface
+//
+
+// Common
+extern void HDMI_Tx_Power_Down(void);
+extern void HDMI_Tx_Power_Up(void);
+extern void HDMI_Tx_HDMI(void);
+extern void HDMI_Tx_DVI(void);
+extern unsigned char HDMI_Tx_HTPLG(void);
+extern unsigned char HDMI_Tx_RSEN(void);
+
+// HDCP
+extern void HDMI_Tx_Mute_Enable(void);
+extern void HDMI_Tx_Mute_Disable(void);
+extern void HDMI_Tx_HDCP_Enable(void);
+extern void HDMI_Tx_HDCP_Disable(void);
+extern void HDMI_Tx_RPTR_Set(void);
+extern void HDMI_Tx_RPTR_Clear(void);
+extern unsigned char HDMI_Tx_RI_RDY(void);
+extern void HDMI_Tx_write_AN(unsigned char *pAN);
+extern unsigned char HDMI_Tx_AKSV_RDY(void);
+extern unsigned char HDMI_Tx_read_AKSV(unsigned char *pAKSV);
+extern void HDMI_Tx_write_BKSV(unsigned char *pBKSV);
+extern unsigned char HDMI_Tx_read_RI(unsigned char *pRI);
+extern void HDMI_Tx_read_M0(unsigned char *pM0);
+extern SMBUS_STATUS HDMI_Tx_Get_Key(unsigned char *Key);
+
+// Special for EP932E
+extern void HDMI_Tx_AMute_Enable(void);
+extern void HDMI_Tx_AMute_Disable(void);
+extern void HDMI_Tx_VMute_Enable(void);
+extern void HDMI_Tx_VMute_Disable(void);
+extern void HDMI_Tx_Video_Config(PVDO_PARAMS Params);
+extern void HDMI_Tx_Audio_Config(PADO_PARAMS Params);
+
+
+//--------------------------------------------------------------------------------------------------
+//
+// Hardware Interface
+//
+
+// EP932
+extern SMBUS_STATUS Key_Read(unsigned char ByteAddr, void *Data, unsigned int Size);
+
+extern SMBUS_STATUS Key_Write(unsigned char ByteAddr, void *Data, unsigned int Size);
+
+extern SMBUS_STATUS EP932_Reg_Read(unsigned char ByteAddr, unsigned char *Data, unsigned int Size);
+extern SMBUS_STATUS EP932_Reg_Write(unsigned char ByteAddr, unsigned char *Data, unsigned int Size);
+extern SMBUS_STATUS EP932_Reg_Set_Bit(unsigned char ByteAddr, unsigned char BitMask);
+extern SMBUS_STATUS EP932_Reg_Clear_Bit(unsigned char ByteAddr, unsigned char BitMask);
+
+
+#endif // EP932_IF_H
+
+
diff --git a/drivers/video/hdmi/ep932/EP932_If.o b/drivers/video/hdmi/ep932/EP932_If.o
new file mode 100644
index 0000000..fdbefad
Binary files /dev/null and b/drivers/video/hdmi/ep932/EP932_If.o differ
diff --git a/drivers/video/hdmi/ep932/EP932api.c b/drivers/video/hdmi/ep932/EP932api.c
new file mode 100644
index 0000000..4751a1c
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932api.c
@@ -0,0 +1,344 @@
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include "EP932Controller.h"  // HDMI Transmiter
+#include "EP932api.h"
+
+
+static EP932C_REGISTER_MAP EP932C_Registers;
+
+
+/*
+============================================================================
+	need use customer's function 
+		
+	1. EP932 reset - use customer's GPIO function 
+
+		EP_EP932M_Reset()
+		
+		### EP932 must reset after video format timing change ###
+			
+	2. EP932 IIC/DDC - use customer's IIC function
+
+		DDC_If.c  	=> 	DDC_Write(......) , DDC_Read(.......)
+		EP932_If.c	=> 	IIC_Write(......) , IIC_Read(.......)
+
+		### customer' IIC function must can check IIC error (no ack, write error, read error) ###
+	
+	3. Timer 
+
+		10ms timer to run EP932Controller_Task(); and EP932Controller_Timer();
+
+
+   ============================================================================
+	initial EP932 
+
+	1. initial EP932 variable and customer's GPIO + I2C (if need).
+
+		EP_HDMI_Init();
+
+	2. set video interface and timing, timing need modify to fit with customer's require
+
+		EP_HDMI_Set_Video_Timing( 3 );   // 480P
+
+		EP_HDMI_Set_Video_Output(Video_OUT_Auto);
+
+	3. set audio interface
+
+		EP_HDMI_SetAudFmt(AUD_I2S, AUD_SF_48000Hz);
+
+	4. need to run EP932Controller_Task and EP932Controller_Timer every 10ms
+
+		while(1)
+		{
+			EP932Controller_Task();
+			EP932Controller_Timer();
+		}
+
+============================================================================
+*/
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+
+void EP932_EnableHPInit(void)
+{
+	EP932_Reg_Set_Bit(EP932_General_Control_1,EP932_General_Control_1__TSEL_HTP);
+	EP932_Reg_Set_Bit(EP932_General_Control_1,EP932_General_Control_1__INT_OD);
+	EP932_Reg_Clear_Bit(EP932_General_Control_1,EP932_General_Control_1__INT_POL);
+	EP932_Reg_Clear_Bit(EP932_General_Control_2, EP932_General_Control_2__RIE);
+	EP932_Reg_Clear_Bit(EP932_General_Control_2, EP932_General_Control_2__VIE);
+	EP932_Reg_Set_Bit(EP932_General_Control_2, EP932_General_Control_2__MIE);
+}
+
+void EP_EP932M_Reset(void)
+{
+	////////////////////////////////////////////////////////////////
+	// need use customer's GPIO to reset EP932 after video timing change
+	//
+	// 1. GPIO set to low level
+	// 2. delay 200ms
+	// 3. GPIO set to high level
+	//
+	///////////////////////////////////////////////////////////////
+
+	unsigned long reg_temp;
+	unsigned int i;
+
+	reg_temp = __imapx_name_to_gpio(CONFIG_HDMI_EP932_RESET);
+
+	if(reg_temp == IMAPX_GPIO_ERROR)
+	{
+		printk(KERN_ERR "EP932 get reset pin failed.\n");
+		return -ENOTTY;
+	}
+
+	imapx_gpio_setcfg(reg_temp, IG_OUTPUT, IG_NORMAL);
+	imapx_gpio_setpin(reg_temp, 0, IG_NORMAL);
+
+	for(i = 0;i<200;i++)
+	  udelay(1000);
+
+	imapx_gpio_setpin(reg_temp, 1, IG_NORMAL);
+}
+
+void hdmi_main (LCD_TIMING timing)
+{
+	unsigned int i=0;
+	//////////////////////////////////////////////////////
+	//
+	// initial EP932 variable and customer's GPIO + I2C (if need).
+	//
+	/////////////////////////////////////////////////////
+	EP_HDMI_Init();
+
+	/////////////////////////////////////////////////////
+	//
+	// set video interface and timing, timing need modify to fit with customer's require
+	//
+	/////////////////////////////////////////////////////
+	EP_HDMI_Set_Video_Timing(timing);	
+
+	EP_HDMI_Set_Video_Output(Video_OUT_YUV_444);
+	////////////////////////////////////////////////////
+	//
+	// set audio interface
+	//
+	///////////////////////////////////////////////////
+	EP_HDMI_SetAudFmt(AUD_I2S, AUD_SF_44100Hz);
+
+	//////////////////////////////////////////////////////////////////
+	//
+	// need to run EP932Controller_Task and EP932Controller_Timer every 10ms
+	//
+	/////////////////////////////////////////////////////////////////
+	while(1)
+	{
+		i++;
+		if(i>200)
+			break;
+
+		EP932Controller_Task();
+		EP932Controller_Timer();
+	}
+}
+
+void  EP_HDMI_SetAudFmt(HDMI_AudFmt_t  Audfmt, HDMI_AudFreq  Audfreq)
+{
+	if(Audfmt == AUD_I2S)
+	{
+		EP932C_Registers.Audio_Interface = 0x18;		// 2 channel IIS
+		DBG_printf(("Audio interface is IIS - 2.0 CH, "));
+	}
+	else
+	{
+		EP932C_Registers.Audio_Interface = 0x10;		// SPDIF
+		DBG_printf(("Audio interface is SPDIF, "));
+	}
+
+	if(Audfreq == AUD_Mute)
+	{
+		EP932C_Registers.System_Configuration = 0x22;	// Audio mute enable	
+	}
+	else
+	{
+		EP932C_Registers.System_Configuration = 0x20;	// Audio mute disable	
+	}
+
+	EP932C_Registers.Audio_Input_Format = Audfreq;	// set Audio frequency
+	DBG_printf(("freq = "));
+	switch(Audfreq)
+	{
+		case AUD_Mute:
+			DBG_printf(("Audio Mute\r\n"));
+			break;
+
+		case AUD_SF_32000Hz:
+			DBG_printf(("32K Hz\r\n"));
+			break;
+			
+		case AUD_SF_44100Hz:
+			DBG_printf(("44.1K Hz\r\n"));
+			break;
+			
+		case AUD_SF_48000Hz:
+			DBG_printf(("48K Hz\r\n"));
+			break;
+			
+		case AUD_SF_88200Hz:
+			DBG_printf(("88.2K Hz\r\n"));
+			break;
+			
+		case AUD_SF_96000Hz:
+			DBG_printf(("96K Hz\r\n"));
+			break;
+			
+		case AUD_SF_176400Hz:
+			DBG_printf(("176.4K Hz\r\n"));
+			break;
+			
+		case AUD_SF_192000Hz:
+			DBG_printf(("192K Hz\r\n"));
+			break;
+
+		default:
+			DBG_printf(("Unknown %d\r\n",Audfreq));
+			break;
+			
+	}
+}
+
+
+
+void  EP_HDMI_Set_Video_Timing(LCD_TIMING Timing)
+{
+		DBG_printf(("\r\n\r\n"));
+		DBG_printf(("##############################################\r\n"));
+	
+		// no skew, Dual edge - falling edge first, 12 bit, FMT12 = 0, 
+		EP932C_Registers.Video_Interface[0] = 0x04 /*| BSEL_24bit*/ /*| EDGE_rising */ /*| FMT_12*/;
+		DBG_printf(("Video_Interface_0 = 0x%02X \r\n",(int)EP932C_Registers.Video_Interface[0] ));
+		
+		// mode: DE + Hsync + Vsync , input: YUV422
+		EP932C_Registers.Video_Interface[1] = 0x0; 	// DE,HS,VS, YUV422
+		DBG_printf(("Video_Interface_1 = 0x%02X \r\n",(int)EP932C_Registers.Video_Interface[1] ));
+	
+		switch (Timing)
+		{
+			case HDMI_1080P:/*1920x1080p 60Hz[16:9]*/	
+				DBG_printf(("TVOUT_MODE_1080P60\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x10;
+				break;
+				
+//			case HDMI_1080I: /*1920x1080I 60Hz[16:9]*/
+//				DBG_printf(("TVOUT_MODE_1080I60\r\n"));
+//				EP932C_Registers.Video_Input_Format[0] = 0x05;
+//				break;
+				
+			case HDMI_720P: /*1280x720p 60Hz[16:9]*/
+				DBG_printf(("TVOUT_MODE_720p\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x04;
+				break;
+				
+			case HDMI_480P_16_9: /*720x480p 60Hz[16:9]*/
+				DBG_printf(("TVOUT_MODE_480p[16:9]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x03;
+				break;
+				
+			case HDMI_480P_4_3: /*720x480p 60Hz[4:3]*/
+				DBG_printf(("TVOUT_MODE_480p[4:3]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x02;
+				break;
+				
+//			case HDMI_480I_16_9: /*720x480I 60Hz[16:9]*/
+//				DBG_printf(("TVOUT_MODE_480I[16:9]\r\n"));
+//				EP932C_Registers.Video_Input_Format[0] = 0x07;
+//				break;
+				
+//			case HDMI_480I_4_3: /*720x480I 60Hz[4:3]*/
+//				DBG_printf(("TVOUT_MODE_480I[4:3]\r\n"));
+//				EP932C_Registers.Video_Input_Format[0] = 0x06;
+//				break;
+				
+			case HDMI_576P_16_9: /*720x576p 50Hz[16:9]*/
+				DBG_printf(("TVOUT_MODE_576p[16:9]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x12;
+				break;
+				
+			case HDMI_576P_4_3: /*720x576p 50Hz[4:3]*/
+				DBG_printf(("TVOUT_MODE_576p[4:3]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x11;
+				break;
+				
+//			case HDMI_576I_16_9: /*720x576I 50Hz[16:9]*/
+//				DBG_printf(("TVOUT_MODE_576I[16:9]\r\n"));
+//				EP932C_Registers.Video_Input_Format[0] = 0x16;
+//				break;
+				
+//			case HDMI_576I_4_3: /*720x576I 50Hz[4:3]*/
+//				DBG_printf(("TVOUT_MODE_576I[4:3]\r\n"));
+//				EP932C_Registers.Video_Input_Format[0] = 0x15;
+//				break;
+
+			case HDMI_640_480: //640x480p 60Hz[4:3]:
+				DBG_printf(("TVOUT_MODE_640x480p[4:3]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 0x01;
+				break;
+
+			case HDMI_800_600: //800x600p 60Hz[4:3]:
+				DBG_printf(("TVOUT_MODE_800x600p[4:3]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 144;
+				break;
+
+			case HDMI_1024_768: //1024x768p 60Hz[4:3]:
+				DBG_printf(("TVOUT_MODE_1024x768p[4:3]\r\n"));
+				EP932C_Registers.Video_Input_Format[0] = 152;
+				break;
+			default:
+				DBG_printf(("TVOUT_MODE_Unknown : %d\r\n",Timing));
+				EP932C_Registers.Video_Input_Format[0] = 0x00;
+				break;
+		}
+	
+		// power on 
+		EP932C_Registers.Power_Control = 0x00;
+	
+	//===================================================================
+	
+		DBG_printf(("##############################################\r\n"));
+	
+}
+
+void EP_HDMI_Set_Video_Output(int HDMI_output)
+{	
+	switch(HDMI_output)	
+	{		
+		default:		
+		case Video_OUT_Auto:
+			EP932C_Registers.Video_Output_Format = 0x00;		// Auto select output			
+			break;	
+			
+		case Video_OUT_YUV_444:			
+			EP932C_Registers.Video_Output_Format = 0x01;		// YUV 444 output			
+			break;		
+			
+		case Video_OUT_YUV_422:			
+			EP932C_Registers.Video_Output_Format = 0x02;		// YUV 422 output			
+			break;		
+			
+		case Video_OUT_RGB_444:			
+			EP932C_Registers.Video_Output_Format = 0x03;		// RGB 444 output			
+			break;	
+	}
+}
+
+unsigned char EP_HDMI_Init(void)
+{
+
+	EP932Controller_Initial(&EP932C_Registers, NULL);
+
+	return 0; //HDMI_SUCCESS;
+}
+
+
diff --git a/drivers/video/hdmi/ep932/EP932api.h b/drivers/video/hdmi/ep932/EP932api.h
new file mode 100644
index 0000000..861efca
--- /dev/null
+++ b/drivers/video/hdmi/ep932/EP932api.h
@@ -0,0 +1,75 @@
+#ifndef EP932_API_H
+#define EP932_API_H
+
+#include <asm/io.h>
+#include <linux/i2c.h>
+#include <plat/imapx.h>
+#include "imap_HDMI.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// for EP Driver
+//
+#include "type.h"
+
+//#define DBG_printf(x) printk x
+#define DBG_printf(x)
+
+
+typedef enum {
+	// Master
+	SMBUS_STATUS_Success = 0x00,
+	SMBUS_STATUS_Pending,//	SMBUS_STATUS_Abort,
+	SMBUS_STATUS_NoAct = 0x02,
+	SMBUS_STATUS_TimeOut,
+	SMBUS_STATUS_ArbitrationLoss = 0x04
+} SMBUS_STATUS;
+
+
+typedef enum {
+	AUD_Mute = 0,
+	AUD_SF_32000Hz = 1,
+	AUD_SF_44100Hz,
+	AUD_SF_48000Hz,
+	AUD_SF_88200Hz,
+	AUD_SF_96000Hz,
+	AUD_SF_176400Hz,
+	AUD_SF_192000Hz
+}HDMI_AudFreq;
+
+typedef enum {
+	Video_OUT_Auto	= 0,
+	Video_OUT_YUV_444,
+	Video_OUT_YUV_422,
+	Video_OUT_RGB_444,
+}HDMI_Out_format;
+
+//
+////////////////////////////////////////////////////////////////////////////////
+/*
+typedef enum{
+	AudioMute_Disable = 0,
+	AudioMute_Enable = 1
+}CSTVOUT_Audio_MODE;
+*/	
+
+typedef enum {
+	AUD_I2S = 0,
+	AUD_SPDIF	
+}HDMI_AudFmt_t;
+
+#define DSEL_Dual_Edge		0x08
+#define BSEL_24bit			0x04
+#define EDGE_rising		0x02
+#define FMT_12				0x01
+
+void EP_EP932M_Reset(void);
+void  EP_HDMI_Set_Audio_Interface(HDMI_AudFmt_t  Audfmt, HDMI_AudFreq  Audfreq);
+//void  EP_HDMI_Set_Video_Timing(int Timing);
+void EP_HDMI_Set_Video_Output(int HDMI_output);
+unsigned char EP_HDMI_Init(void); 
+void hdmi_main (LCD_TIMING timing);
+void  EP_HDMI_SetAudFmt(HDMI_AudFmt_t  Audfmt, HDMI_AudFreq  Audfreq);
+void  EP_HDMI_Set_Video_Timing(LCD_TIMING Timing);
+void EP932_EnableHPInit(void);
+
+#endif
diff --git a/drivers/video/hdmi/ep932/EP932api.o b/drivers/video/hdmi/ep932/EP932api.o
new file mode 100644
index 0000000..f19d4ac
Binary files /dev/null and b/drivers/video/hdmi/ep932/EP932api.o differ
diff --git a/drivers/video/hdmi/ep932/Edid.c b/drivers/video/hdmi/ep932/Edid.c
new file mode 100644
index 0000000..94822b6
--- /dev/null
+++ b/drivers/video/hdmi/ep932/Edid.c
@@ -0,0 +1,105 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+  File        :  Edid.c 
+
+  Description :  Implement the interfaces fo Edid
+
+\******************************************************************************/
+
+#include "Edid.h"
+#include "EP932api.h"
+
+static int i, j;
+
+//--------------------------------------------------------------------------------------------------
+
+unsigned char EDID_GetHDMICap(unsigned char *pTarget)
+{
+	if(pTarget[126] == 0x01) {
+		for(i=4; i<pTarget[EDID_BLOCK_SIZE+2]; ++i) {
+			if((pTarget[EDID_BLOCK_SIZE+i] & 0xE0) == 0x60) { // find tag code - Vendor Specific Block
+				if( (pTarget[EDID_BLOCK_SIZE+1+i] == 0x03) && (pTarget[EDID_BLOCK_SIZE+2+i] == 0x0C) && (pTarget[EDID_BLOCK_SIZE+3+i] == 0x00) ) {
+					return 1;
+				}
+			}
+			else {
+				i += (pTarget[EDID_BLOCK_SIZE+i] & 0x1F);
+			}
+		}
+		if(i>=pTarget[EDID_BLOCK_SIZE+2]) { // Error, can not find the Vendor Specific Block
+			return 0;
+		}
+	}
+	return 0;
+}
+
+unsigned char EDID_GetPCMFreqCap(unsigned char *pTarget)
+{
+	if(pTarget[126] >= 0x01) {
+		for(i=4; i<pTarget[EDID_BLOCK_SIZE+2]; ++i) {
+			if((pTarget[EDID_BLOCK_SIZE+i] & 0xE0) == 0x20) { // find tag code - Audio Data Block
+				for(j=1; j<(pTarget[EDID_BLOCK_SIZE+i] & 0x1F); j+=3) {
+					if((pTarget[EDID_BLOCK_SIZE+i+j] >> 3) == 1) {
+						return pTarget[EDID_BLOCK_SIZE+i+j+1];
+					}
+				}
+			}
+			else {
+				i += (pTarget[EDID_BLOCK_SIZE+i] & 0x1F);
+			}
+		}
+		if(i>=pTarget[EDID_BLOCK_SIZE+2]) { // Error, can not find the Audio Data Block
+			return 0x07;
+		}
+	}
+	return 0x00;
+}
+
+unsigned char EDID_GetPCMChannelCap(unsigned char *pTarget)
+{
+	unsigned char MaxPCMChannel = 1;
+	if(pTarget[126] >= 0x01) {
+		for(i=4; i<pTarget[EDID_BLOCK_SIZE+2]; ++i) {
+			if((pTarget[EDID_BLOCK_SIZE+i] & 0xE0) == 0x20) { // find tag code - Audio Data Block
+				for(j=1; j<(pTarget[EDID_BLOCK_SIZE+i] & 0x1F); j+=3) {
+					if((pTarget[EDID_BLOCK_SIZE+i+j] >> 3) == 1) {
+						//return pTarget[EDID_BLOCK_SIZE+i+j] & 0x07;
+						MaxPCMChannel = max(MaxPCMChannel, pTarget[EDID_BLOCK_SIZE+i+j] & 0x07);
+					}
+				}
+			}
+			else {
+				i += (pTarget[EDID_BLOCK_SIZE+i] & 0x1F);
+			}
+		}
+		return MaxPCMChannel;
+		//if(i>=pTarget[EDID_BLOCK_SIZE+2]) { // Error, can not find the Audio Data Block
+		//	return 1;
+		//}
+	}
+	return 0;
+}
+
+unsigned char EDID_GetDataBlockAddr(unsigned char *pTarget, unsigned char Tag)
+{
+	if(pTarget[126] >= 0x01) {
+		for(i=4; i<pTarget[EDID_BLOCK_SIZE+2]; ++i) {
+			if((pTarget[EDID_BLOCK_SIZE+i] & 0xE0) == Tag) { // find tag code 
+				return i+128;
+			}
+			else {
+				i += (pTarget[EDID_BLOCK_SIZE+i] & 0x1F);
+			}
+		}
+		if(i>=pTarget[EDID_BLOCK_SIZE+2]) { // Error, can not find
+			return 0;
+		}
+	}
+	return 0;
+}
+
diff --git a/drivers/video/hdmi/ep932/Edid.h b/drivers/video/hdmi/ep932/Edid.h
new file mode 100644
index 0000000..968580f
--- /dev/null
+++ b/drivers/video/hdmi/ep932/Edid.h
@@ -0,0 +1,33 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+  File        :  Edid.h 
+
+  Description :  Head file of Edid IO Interface 
+
+\******************************************************************************/
+
+#ifndef EDID_H
+#define EDID_H
+
+#define EDID_BLOCK_SIZE  128
+
+//#define max(a,b) (((a)>(b))? (a):(b))
+
+
+//
+// Structure Definitions
+//
+
+extern unsigned char EDID_GetHDMICap(unsigned char *pTarget);
+extern unsigned char EDID_GetPCMFreqCap(unsigned char *pTarget);
+extern unsigned char EDID_GetPCMChannelCap(unsigned char *pTarget);
+extern unsigned char EDID_GetDataBlockAddr(unsigned char *pTarget, unsigned char Tag);
+
+#endif // EDID_H
+
+
diff --git a/drivers/video/hdmi/ep932/Edid.o b/drivers/video/hdmi/ep932/Edid.o
new file mode 100644
index 0000000..5c359b1
Binary files /dev/null and b/drivers/video/hdmi/ep932/Edid.o differ
diff --git a/drivers/video/hdmi/ep932/HDCP.c b/drivers/video/hdmi/ep932/HDCP.c
new file mode 100644
index 0000000..0fc0a3f
--- /dev/null
+++ b/drivers/video/hdmi/ep932/HDCP.c
@@ -0,0 +1,690 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005 
+                           ALL RIGHTS RESERVED 
+ 
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  HDCP.c 
+
+  Description :  HDCP program for HDMI Transmiter (EP932)
+
+  Codeing     :  Shihken
+
+\******************************************************************************/
+
+// Our includes
+#include "HDCP.h"
+#include "EP932_If.h"
+#include "DDC_If.h"
+#include "type.h"
+
+#ifndef min
+#define min(a,b) (a<b)? a:b
+#endif
+
+//
+// System State
+//
+
+unsigned int HDCP_TimeCount = 0;
+HDCP_STATE HDCP_State = 0;
+unsigned char HDCP_Status = 0;
+unsigned char RI_Check = 0, Fake_HDCP = 0;
+unsigned char *pKSVList = 0, *pBKSV_BCAPS3 = 0, *pSHA_M0 = 0;
+unsigned char KSVListNumber = 0;
+
+
+//
+// Global Data
+//
+unsigned long Temp_SHA_H[5];
+unsigned char Temp_HDCP[10];
+
+//int i, j;
+
+//
+// Private Functions
+//
+
+unsigned char HDCP_validate_RI(void);
+
+// Repeater
+unsigned char HDCP_compute_SHA_message_digest(unsigned char hdcp_dev_count, unsigned char hdcp_depth);
+
+// SHA
+void SHA_Initial(void);
+void SHA_Push_Data(unsigned char *pData, unsigned char Size);
+unsigned long *SHA_Get_SHA_Digest(void);
+void SHA_Calculation(unsigned long pSHA_H[5], unsigned long pSHA_W1[16]);
+
+//---------------------------------------------------------------------------------------------------------------------------
+
+void HDCP_Extract_BKSV_BCAPS3(unsigned char *pBKSV_BCaps3)
+{
+	pBKSV_BCAPS3 = pBKSV_BCaps3;
+}
+
+void HDCP_Extract_FIFO(unsigned char *pFIFOList, unsigned char ListNumber)
+{
+	pKSVList = pFIFOList;
+	KSVListNumber = ListNumber;
+}
+
+void HDCP_Extract_SHA_M0(unsigned char *pSha_M0)
+{
+	pSHA_M0 = pSha_M0;
+}
+
+void HDCP_Stop()
+{
+	HDCP_TimeCount = 1000/HDCP_TIMER_PERIOD; // No delay for next startup
+	HDCP_Status = 0;
+	HDCP_State = 0;
+	RI_Check = 0;
+
+	// Disable the HDCP Engine
+	HDMI_Tx_HDCP_Disable();
+
+	// Disable mute for transmiter video and audio
+	HDMI_Tx_Mute_Disable();
+}
+
+void HDCP_Fake(unsigned char Enable)
+{
+	Fake_HDCP = Enable;
+}
+
+unsigned char HDCP_Get_Status(void)
+{
+	return HDCP_Status;
+}
+
+void HDCP_Timer(void) 
+{
+	++HDCP_TimeCount;
+}
+
+void HDCP_Ext_Ri_Trigger(void) 
+{
+	RI_Check = 1;
+}
+
+HDCP_STATE HDCP_Authentication_Task(unsigned char ReceiverRdy)
+{
+	if( (HDCP_State > A0_Wait_for_Active_Rx) && !(ReceiverRdy) ) {
+		DBG_printf(("WARNING: No RSEN or Hot-Plug in Authentication\r\n"));	
+			
+		// Enable mute for transmiter video and audio
+		HDMI_Tx_Mute_Enable();
+
+		// Confirm, Disable the HDCP Engine (actived from Downstream)
+		HDMI_Tx_HDCP_Disable();
+
+		// Restart HDCP authentication
+		HDCP_TimeCount = 0;
+		HDCP_State = A0_Wait_for_Active_Rx;
+		HDCP_Status |= HDCP_ERROR_RSEN;
+		return HDCP_State;
+	}	   
+
+	switch(HDCP_State) {
+	// HDCP authentication
+
+		// A0 state -- Wait for Active RX
+		//          -- read and validate BKSV for every 1 second.
+		case A0_Wait_for_Active_Rx:
+ 		    
+ 	    	if(HDCP_TimeCount > 1000/HDCP_TIMER_PERIOD) {
+				HDCP_TimeCount = 0;
+   
+				if( Downstream_Rx_read_BKSV(Temp_HDCP) ) {		
+					DBG_printf(("Authentication start...\r\n"));
+		   			HDCP_State = A1_Exchange_KSVs;
+				}
+				else {	// HDCP not support
+					DBG_printf(("HDCP might not be supported\r\n"));
+					Downstream_Rx_write_AINFO(0x00); // Make TE sense the retry to pass ATC HDCP test
+					HDCP_Status |= HDCP_ERROR_BKSV;
+				}
+			}
+			break;
+
+		// A1 state -- Exchange KSVs
+		//          -- retrieve the random number
+		//          -- write AN to RX and TX
+		//          -- read and write AKSV, BKSV
+		case A1_Exchange_KSVs:
+
+			// Write AINFO
+			Downstream_Rx_write_AINFO(0x00);
+
+			// Check Repeater Bit
+			Temp_HDCP[0] = Downstream_Rx_BCAPS();
+			if(Temp_HDCP[0] & 0x40) {		// REPEATER
+				HDMI_Tx_RPTR_Set();
+			}
+			else {						// NON-REPEATER
+				HDMI_Tx_RPTR_Clear();
+			}
+
+			// Exange AN
+			for(Temp_HDCP[8]=0; Temp_HDCP[8]<8; ++Temp_HDCP[8]) {		 	   
+//				Temp_HDCP[Temp_HDCP[8]] = rand()%256;
+			}
+		    HDMI_Tx_write_AN(Temp_HDCP);
+		    Downstream_Rx_write_AN(Temp_HDCP);
+
+			// Exange AKSV
+		    if(!HDMI_Tx_read_AKSV(Temp_HDCP)) {
+			
+				if(!Fake_HDCP) {
+					HDCP_State = A0_Wait_for_Active_Rx;
+					HDCP_Status |= HDCP_ERROR_AKSV;
+					break;
+				}
+				else {
+					memset(Temp_HDCP, 0x5A, 5);
+				}
+			}
+		    Downstream_Rx_write_AKSV(Temp_HDCP);
+
+			// Exange BKSV
+		    if(!Downstream_Rx_read_BKSV(Temp_HDCP)) {
+				HDCP_State = A0_Wait_for_Active_Rx;
+				HDCP_Status |= HDCP_ERROR_BKSV;
+				break;
+			}
+		   	HDMI_Tx_write_BKSV(Temp_HDCP);
+			if(pBKSV_BCAPS3) memcpy(&pBKSV_BCAPS3[0], Temp_HDCP, 5);
+		
+		    HDCP_State = A2_Computations;
+			break;
+
+		// A2 state -- Computations
+		//          -- Wait 150ms for R0 update (min 100ms)
+		case A2_Computations:
+
+		 	if(HDCP_TimeCount > 150/HDCP_TIMER_PERIOD) {
+				if(HDMI_Tx_RI_RDY()) {
+					HDCP_TimeCount = 0;
+					HDCP_State = A3_Validate_Receiver;
+				}
+			}
+			break;
+
+		// A3 state -- Validate Receiver
+		//          -- read and compare R0 from TX and RX
+  		//          -- allow IIC traffic or R0 compare error in 200ms
+		case A3_Validate_Receiver:
+
+			if(!HDCP_validate_RI()) {
+	 	    	if(HDCP_TimeCount > 200/HDCP_TIMER_PERIOD) {
+					HDCP_TimeCount = 0;
+
+					DBG_printf(("ERROR: R0 check failed\r\n"));
+
+					HDCP_State = A0_Wait_for_Active_Rx;	
+					HDCP_Status |= HDCP_ERROR_R0;
+				}
+			}
+			else {
+				HDCP_TimeCount = 0;
+				HDCP_State = A6_Test_for_Repeater;
+			}
+			break;
+
+		// A4 state -- Authenticated
+		//          -- Disable mute
+		case A4_Authenticated:
+					
+			// Start the HDCP Engine
+			if(!Fake_HDCP) HDMI_Tx_HDCP_Enable(); 
+	
+			// Disable mute for transmiter video 
+			HDMI_Tx_Mute_Disable();
+
+			DBG_printf(("Authenticated\r\n"));			
+
+			HDCP_State = A5_Link_Integrity_Check;
+			break;
+
+		// A5 state -- Link Integrity Check every second
+		//          -- HDCP Engine must be started
+  		//          -- read and compare RI from RX and TX
+		case A5_Link_Integrity_Check:
+
+			if(RI_Check) {
+				RI_Check = 0;
+
+				if(!HDCP_validate_RI()) {
+					if(!HDCP_validate_RI()) {
+
+						// Enable mute for transmiter video and audio
+						HDMI_Tx_Mute_Enable();
+
+						// Disable the HDCP Engine
+						HDMI_Tx_HDCP_Disable(); 
+
+						DBG_printf(("ERROR: Ri check failed\r\n"));
+
+						HDCP_State = A0_Wait_for_Active_Rx;
+						HDCP_Status |= HDCP_ERROR_Ri;
+					}
+				}
+			}
+/*
+ 	    	if(HDCP_TimeCount > 2000/HDCP_TIMER_PERIOD) {	// Wait for 2 second
+				HDCP_TimeCount = 0;
+
+				if(!HDCP_validate_RI()) {
+
+					if(RI_Check) { // RI_Failed_Two
+
+						// Enable mute for transmiter video and audio
+						HDMI_Tx_Mute_Enable();
+
+						// Disable the HDCP Engine
+						HDMI_Tx_HDCP_Disable(); 
+
+						DBG_printf(("ERROR: Ri check failed\r\n"));
+
+						HDCP_State = A0_Wait_for_Active_Rx;
+						HDCP_Status |= HDCP_ERROR_Ri;
+					}
+					else {
+						DBG_printf(("WARNING: Ri check failed\r\n"));
+
+						RI_Check = 1;
+						HDCP_TimeCount = 1500/HDCP_TIMER_PERIOD;
+					}
+				}
+				else {
+					RI_Check = 0;
+				}
+			}
+*/
+			break;
+
+		// A6 state -- Test For Repeater
+		//          -- REPEATER     : Enter the WAIT_RX_RDY state;
+		//          -- NON-REPEATER : Enter the AUTHENTICATED state
+		case A6_Test_for_Repeater:   
+
+			Temp_HDCP[0] = Downstream_Rx_BCAPS();
+			if(pBKSV_BCAPS3) pBKSV_BCAPS3[5] = Temp_HDCP[0];
+
+			if (Temp_HDCP[0] & 0x40) {	// REPEATER	
+				HDCP_State = A8_Wait_for_READY;
+			}
+			else {						// NON-REPEATER
+				HDCP_State = A4_Authenticated;
+			}
+			break;
+
+		// A8 state -- Wait for READY
+		//          -- read BCAPS and check READY bit continuously
+		//          -- time out while 5-second period exceeds
+		case A8_Wait_for_READY:   
+
+			Temp_HDCP[0] = Downstream_Rx_BCAPS();
+			if(pBKSV_BCAPS3) pBKSV_BCAPS3[5] = Temp_HDCP[0];
+
+			if (Temp_HDCP[0] & 0x20) {
+				HDCP_TimeCount = 0;
+				HDCP_State = A9_Read_KSV_List;
+			}
+			else {
+				if(HDCP_TimeCount > 5000/HDCP_TIMER_PERIOD) {
+					HDCP_TimeCount = 0;
+
+					DBG_printf(("ERROR: Repeater check READY bit time-out\r\n"));
+
+					HDCP_State = A0_Wait_for_Active_Rx;	
+					HDCP_Status |= HDCP_ERROR_RepeaterRdy;
+				}
+			}
+			break;
+
+		// A9 state -- Read KSV List
+		//          -- compute and validate SHA-1 values
+		case A9_Read_KSV_List:
+			
+			Downstream_Rx_read_BSTATUS(Temp_HDCP);
+			if(pBKSV_BCAPS3) memcpy(&pBKSV_BCAPS3[6], Temp_HDCP, 2);
+
+			if(!(Temp_HDCP[0] & 0x80) && !(Temp_HDCP[1] & 0x08)) {
+				if(HDCP_compute_SHA_message_digest(Temp_HDCP[0], Temp_HDCP[1])) {
+					HDCP_State = A4_Authenticated;
+					break;
+				}
+				else {
+					HDCP_Status |= HDCP_ERROR_RepeaterSHA;
+				}
+			}
+			else {
+				HDCP_Status |= HDCP_ERROR_RepeaterMax;
+			}
+
+			DBG_printf(("ERROR: Repeater HDCP SHA check failed\r\n"));
+
+			HDCP_State = A0_Wait_for_Active_Rx;	
+			break;
+	}
+
+	return HDCP_State;
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+
+unsigned char HDCP_validate_RI(void)
+{
+	unsigned short Temp_RI_Tx, Temp_RI_Rx;
+	if(!HDMI_Tx_read_RI((unsigned char *)&Temp_RI_Tx)) return 0;		// Read form Tx is fast, do it first
+	if(!Downstream_Rx_read_RI((unsigned char *)&Temp_RI_Rx)) return 0;	// Read form Rx is slow, do it second
+//	if(Temp_RI_Tx != Temp_RI_Rx) DBG_printf(("RI_Tx=0x%0.4X, RI_Rx=0x%0.4X\r\n", (int)Temp_RI_Tx, (int)Temp_RI_Rx));
+	if(Fake_HDCP) return 1;
+	return (Temp_RI_Tx == Temp_RI_Rx);
+}
+
+//--------------------------------------------------------------------------------------------------
+
+//
+// NOTE : The following SHA calculation subroutine has not been verified in the
+//        real environment. It has been evaluated by some debugging procedure.
+//        The auther is not responsible to ensure the functionality.
+//
+unsigned char HDCP_compute_SHA_message_digest(unsigned char hdcp_dev_count, unsigned char hdcp_depth) 
+{
+	int i;
+	unsigned long *SHA_H;
+  
+	//////////////////////////////////////////////////////////////////////////////////////////////
+	// Calculate SHA Value
+	//
+
+	SHA_Initial();
+
+	//
+	// Step 1
+	// Push all KSV FIFO to SHA caculation
+	//
+
+	// Read KSV (5 byte) one by one and check the revocation list
+	for(i=0; i<hdcp_dev_count; ++i) {
+
+		// Get KSV from FIFO
+		if(!Downstream_Rx_read_KSV_FIFO(Temp_HDCP, i, hdcp_dev_count)) {
+			return 0;
+		}
+
+		// Save FIFO 
+		if(pKSVList && KSVListNumber) {
+			if(i < KSVListNumber) memcpy(pKSVList+(i*5), Temp_HDCP, 5);
+		}
+
+		// Push KSV to the SHA block buffer (Total 5 bytes)
+		SHA_Push_Data(Temp_HDCP, 5);
+	}
+	if(hdcp_dev_count == 0) {
+		Downstream_Rx_read_KSV_FIFO(Temp_HDCP, 0, 1);
+	}
+
+	//
+	// Step 2
+	// Push BSTATUS, M0, and EOF to SHA caculation
+	//
+
+	// Get the BSTATUS, M0, and EOF
+	Temp_HDCP[0] = hdcp_dev_count;	// Temp_HDCP[0]   = BStatus, LSB
+	Temp_HDCP[1] = hdcp_depth;		// Temp_HDCP[1]   = BStatus, MSB
+	HDMI_Tx_read_M0(Temp_HDCP+2);	// Temp_HDCP[2:9] = Read M0 from TX
+	if(pSHA_M0) memcpy(pSHA_M0+20, (unsigned char*)Temp_HDCP+2, 8);
+
+	// Push the BSTATUS, and M0 to the SHA block buffer (Total 10 bytes)
+	SHA_Push_Data(Temp_HDCP, 10);
+
+	//
+	// Step 3
+	// Push the final block with length to SHA caculation
+	//
+
+	SHA_H = SHA_Get_SHA_Digest();
+
+	//
+	// SHA complete
+	//////////////////////////////////////////////////////////////////////////////////////////////
+
+
+	//////////////////////////////////////////////////////////////////////////////////////////////
+	// Compare the SHA value
+	//
+
+	// read RX SHA value
+	Downstream_Rx_read_SHA1_HASH((unsigned char*)Temp_SHA_H); 
+	if(pSHA_M0) memcpy(pSHA_M0, (unsigned char*)Temp_SHA_H, 20);
+	DBG_printf(("Rx_SHA_H: "));  
+#ifdef DBG
+	for(i=0; i<20; i+=4) {		
+		DBG_printf(("0x%0.2X%0.2X%0.2X%0.2X ", (int)(((PBYTE)Temp_SHA_H)[i+3]), (int)(((PBYTE)Temp_SHA_H)[i+2]), (int)(((PBYTE)Temp_SHA_H)[i+1]), (int)(((PBYTE)Temp_SHA_H)[i+0])));
+	}
+	DBG_printf(("\r\n"));
+#endif
+	// compare the TX/RX SHA value
+	if( (hdcp_dev_count & 0x80) || (hdcp_depth & 0x08) ) {
+		DBG_printf(("Max Cascade or Max Devs exceeded\r\n"));
+		return 0;
+	}
+	else if( (SHA_H[0] != Temp_SHA_H[0]) || (SHA_H[1] != Temp_SHA_H[1]) || (SHA_H[2] != Temp_SHA_H[2]) || (SHA_H[3] != Temp_SHA_H[3]) || (SHA_H[4] != Temp_SHA_H[4]) ) {
+		DBG_printf(("SHA Digit Unmatch\r\n"));
+  		return 0;
+	}
+	else {
+		DBG_printf(("SHA Digit Match\r\n"));
+		return 1;
+	}
+
+	//
+	// Return the compared result
+	//////////////////////////////////////////////////////////////////////////////////////////////
+
+}
+
+//--------------------------------------------------------------------------------------------------
+// SHA Implementation
+//--------------------------------------------------------------------------------------------------
+
+unsigned long SHA_H[5];
+unsigned char SHA_Block[64];	 	// 16*4
+unsigned char SHA_Block_Index;
+unsigned char CopySize;
+unsigned int SHA_Length;
+
+void SHA_Initial(void)
+{
+	//////////////////////////////////////////////////////////////////////////////////////////////
+	// Calculate SHA Value
+	//
+
+	// initial the SHA variables
+	SHA_H[0] = 0x67452301;
+	SHA_H[1] = 0xEFCDAB89;
+	SHA_H[2] = 0x98BADCFE;
+	SHA_H[3] = 0x10325476;
+	SHA_H[4] = 0xC3D2E1F0;
+
+	// Clean the SHA Block buffer
+	memset(SHA_Block, 0, 64);
+	SHA_Block_Index = 0;
+
+	SHA_Length = 0;
+}
+
+void SHA_Push_Data(unsigned char *pData, unsigned char Size)
+{
+	int i;
+	SHA_Length += Size;
+
+	while(Size) {
+		// Push Data to the SHA block buffer
+		CopySize = min((64-SHA_Block_Index), Size);
+		memcpy(SHA_Block+SHA_Block_Index, pData, CopySize);
+		SHA_Block_Index += CopySize;
+		pData += CopySize;
+		Size -= CopySize;
+
+		if(SHA_Block_Index >= 64) { // The SHA block buffer Full
+
+        // add by Eric_Lu
+		/*
+		#ifdef Little_Endian
+			// Swap the sequence of SHA Block (The little-endian to big-endian)
+			unsigned char Swap_Temp;
+			for(i=0; i<64; i+=4) {
+			   
+				Swap_Temp = SHA_Block[i+0];
+				SHA_Block[i+0] = SHA_Block[i+3];
+				SHA_Block[i+3] = Swap_Temp;
+
+				Swap_Temp = SHA_Block[i+1];
+				SHA_Block[i+1] = SHA_Block[i+2];
+				SHA_Block[i+2] = Swap_Temp;
+			}
+		#endif
+		 */
+        // add end
+			// Do SHA caculation for this SHA block buffer
+			SHA_Calculation(SHA_H, (unsigned long*)SHA_Block);
+			memset(SHA_Block, 0, 64);				
+	
+			SHA_Block_Index = 0; // Reset the Index
+		}
+	}
+}
+
+unsigned long *SHA_Get_SHA_Digest(void)
+{
+	int i;
+	SHA_Block[SHA_Block_Index++] = 0x80;	// Set EOF
+
+	if((64 - SHA_Block_Index) < 2) {
+		memset(SHA_Block, 0, 64);
+	}
+	SHA_Length *= 8; 
+	SHA_Block[62] = (SHA_Length >> 8) & 0xFF; 			// Pad with Length MSB
+	SHA_Block[63] = SHA_Length & 0xFF;  				// Pad with Length LSB
+
+    // add by Eric_Lu
+    /*
+	#ifdef Little_Endian
+		// Swap the sequence of SHA Block (The little-endian to big-endian)
+		unsigned char Swap_Temp;
+		for(i=0; i<64; i+=4) {
+		   
+			Swap_Temp = SHA_Block[i+0];
+			SHA_Block[i+0] = SHA_Block[i+3];
+			SHA_Block[i+3] = Swap_Temp;
+
+			Swap_Temp = SHA_Block[i+1];
+			SHA_Block[i+1] = SHA_Block[i+2];
+			SHA_Block[i+2] = Swap_Temp;
+		}
+	#endif
+	*/
+        // add end
+
+	// Do SHA caculation for final SHA block
+	SHA_Calculation(SHA_H, (unsigned long*)SHA_Block);
+
+	// Swap the sequence of SHA_H (The big-endian to little-endian)
+	DBG_printf(("SHA_H:    ")); 
+	for(i=0; i<20; i+=4) {
+	   
+		Temp_HDCP[0] = ((unsigned char*)SHA_H)[i+0];
+		((unsigned char*)SHA_H)[i+0] = ((unsigned char*)SHA_H)[i+3];
+		((unsigned char*)SHA_H)[i+3] = Temp_HDCP[0];
+
+		Temp_HDCP[0] = ((unsigned char*)SHA_H)[i+1];
+		((unsigned char*)SHA_H)[i+1] = ((unsigned char*)SHA_H)[i+2];
+		((unsigned char*)SHA_H)[i+2] = Temp_HDCP[0];
+
+		DBG_printf(("0x%02X%02X%02X%02X ", (int)(((unsigned char*)SHA_H)[i+3]), (int)(((unsigned char*)SHA_H)[i+2]), (int)(((unsigned char*)SHA_H)[i+1]), (int)(((unsigned char*)SHA_H)[i+0])));
+	}
+	DBG_printf(("\r\n")); 
+	
+	return SHA_H;
+}
+
+void SHA_Calculation(unsigned long pSHA_H[5], unsigned long pSHA_W1[16])
+{
+	unsigned char i;
+	unsigned long TEMP;
+
+	// =========================================================
+	//
+	// STEP (c) : Let A = H0, B = H1, C = H2, D = H3, E = H4
+	//
+	Temp_SHA_H[0] = pSHA_H[0];
+	Temp_SHA_H[1] = pSHA_H[1];
+	Temp_SHA_H[2] = pSHA_H[2];
+	Temp_SHA_H[3] = pSHA_H[3];
+	Temp_SHA_H[4] = pSHA_H[4];
+	//
+	// =========================================================    
+													
+	// =========================================================
+	//
+	// STEP (d) : FOR t = 0 to 79 DO
+	//              1. TEMP = S5(A) + Ft(B,C,D) + E + Wt + Kt
+	//              2. E = D; D = C; C = S30(B); B = A; A = TEMP;
+	//
+	for (i = 0; i <= 79; i++) {
+		// Update the Message Word while loop time >= 16
+		if (i >= 16) {
+			// tword = pSHA_W1[tm03] ^ pSHA_W1[tm08] ^ pSHA_W1[tm14] ^ pSHA_W1[tm16];                   
+			TEMP = pSHA_W1[(i + 13) % 16] ^ pSHA_W1[(i + 8) % 16] ^ pSHA_W1[(i + 2) % 16] ^ pSHA_W1[i % 16];
+			pSHA_W1[i % 16] = (TEMP << 1) | (TEMP >> 31);
+		}
+
+		// Calculate first equation
+		TEMP = pSHA_W1[i % 16];
+
+	    TEMP += ((Temp_SHA_H[0] << 5) | (Temp_SHA_H[0] >> 27));
+	
+	    if (i <= 19)      TEMP += ((Temp_SHA_H[1] & Temp_SHA_H[2]) | (~Temp_SHA_H[1] & Temp_SHA_H[3])) + 0x5A827999;
+	    else if (i <= 39) TEMP += (Temp_SHA_H[1] ^ Temp_SHA_H[2] ^ Temp_SHA_H[3]) + 0x6ED9EBA1;
+	    else if (i <= 59) TEMP += ((Temp_SHA_H[1] & Temp_SHA_H[2]) | (Temp_SHA_H[1] & Temp_SHA_H[3]) | (Temp_SHA_H[2] & Temp_SHA_H[3])) + 0x8F1BBCDC;
+	    else              TEMP += (Temp_SHA_H[1] ^ Temp_SHA_H[2] ^ Temp_SHA_H[3]) + 0xCA62C1D6;
+
+	    TEMP += Temp_SHA_H[4];
+
+    	// Update the Value A/B/C/D/E
+    	Temp_SHA_H[4] = Temp_SHA_H[3];
+    	Temp_SHA_H[3] = Temp_SHA_H[2];
+    	Temp_SHA_H[2] = ((Temp_SHA_H[1] << 30) | (Temp_SHA_H[1] >> 2));
+    	Temp_SHA_H[1] = Temp_SHA_H[0];
+    	Temp_SHA_H[0] = TEMP;
+	}
+	//
+	// =========================================================
+
+	// =========================================================
+	//
+	// STEP (e) : H0 = H0 + A; H1 = H1 + B; H2 = H2 + C; H3 = H3 + D; H4 = H4 + E;
+	//
+	pSHA_H[0] += Temp_SHA_H[0];
+	pSHA_H[1] += Temp_SHA_H[1];
+	pSHA_H[2] += Temp_SHA_H[2];
+	pSHA_H[3] += Temp_SHA_H[3];
+	pSHA_H[4] += Temp_SHA_H[4];
+	//
+	// =========================================================
+}
+
diff --git a/drivers/video/hdmi/ep932/HDCP.h b/drivers/video/hdmi/ep932/HDCP.h
new file mode 100644
index 0000000..c7efbb0
--- /dev/null
+++ b/drivers/video/hdmi/ep932/HDCP.h
@@ -0,0 +1,64 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2005 
+                           ALL RIGHTS RESERVED 
+ 
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  HDCP.h
+
+  Description :  Header file of HDCP.c
+
+  Codeing     :  Shihken
+
+\******************************************************************************/
+
+#ifndef HDCP_H
+#define HDCP_H
+
+//#define EXT_RICMP_TRIGGER
+#define HDCP_TIMER_PERIOD 					10		//   
+
+// HDCP Transmiter Link State
+typedef enum {
+	A0_Wait_for_Active_Rx,
+	A1_Exchange_KSVs,
+	A2_Computations,
+	A3_Validate_Receiver,
+	A4_Authenticated,
+	A5_Link_Integrity_Check,
+	A6_Test_for_Repeater,
+	A8_Wait_for_READY,
+	A9_Read_KSV_List
+} HDCP_STATE;
+
+#define HDCP_ERROR_BKSV									0x80
+#define HDCP_ERROR_AKSV									0x40
+#define HDCP_ERROR_R0									0x20
+#define HDCP_ERROR_Ri									0x10
+#define HDCP_ERROR_RepeaterRdy							0x08
+#define HDCP_ERROR_RepeaterSHA							0x04
+#define HDCP_ERROR_RSEN									0x02
+#define HDCP_ERROR_RepeaterMax							0x01
+
+extern HDCP_STATE HDCP_Authentication_Task(unsigned char ReceiverRdy);
+extern void HDCP_Stop(void);
+extern unsigned char HDCP_Get_Status(void);
+extern void HDCP_Timer(void);
+extern void HDCP_Ext_Ri_Trigger(void);
+
+// Special Functions
+extern void HDCP_Assign_RKSV_List(unsigned char *pRevocationList, unsigned char ListNumber);
+extern void HDCP_Fake(unsigned char Enable);
+extern void HDCP_Extract_BKSV_BCAPS3(unsigned char *pBKSV_BCaps3);
+extern void HDCP_Extract_FIFO(unsigned char *pFIFO, unsigned char ListNumber);
+extern void HDCP_Extract_SHA_M0(unsigned char *pSha_M0);
+
+#endif // HDCP_H
diff --git a/drivers/video/hdmi/ep932/HDCP.o b/drivers/video/hdmi/ep932/HDCP.o
new file mode 100644
index 0000000..5089de7
Binary files /dev/null and b/drivers/video/hdmi/ep932/HDCP.o differ
diff --git a/drivers/video/hdmi/ep932/Makefile b/drivers/video/hdmi/ep932/Makefile
new file mode 100644
index 0000000..f7b23ed
--- /dev/null
+++ b/drivers/video/hdmi/ep932/Makefile
@@ -0,0 +1,7 @@
+#
+## Makefile for the HDMI output interface driver
+#
+
+obj-y += imap_HDMI.o EP932api.o DDC_If.o EP932Controller.o	 \
+				 Edid.o EP932_If.o EP932SettingsData.o HDCP.o
+
diff --git a/drivers/video/hdmi/ep932/built-in.o b/drivers/video/hdmi/ep932/built-in.o
new file mode 100644
index 0000000..b728214
Binary files /dev/null and b/drivers/video/hdmi/ep932/built-in.o differ
diff --git a/drivers/video/hdmi/ep932/hdmi_apilib.h b/drivers/video/hdmi/ep932/hdmi_apilib.h
new file mode 100644
index 0000000..5cb521e
--- /dev/null
+++ b/drivers/video/hdmi/ep932/hdmi_apilib.h
@@ -0,0 +1,86 @@
+/***************************************************************************** 
+** XXX hdmi_apilib.h XXX
+** 
+** Copyright (c) 2009~2014 ShangHai Infotm Ltd all rights reserved. 
+** 
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+** 
+** Description: PCB test, module hdmi.
+**
+** Author:
+**      
+**      XXX Alex XXX
+** Revision History: 
+** ----------------- 
+** 1.1  XXX 04/30/2010 XXX	
+*****************************************************************************/
+/*structure for hdmi solution*/
+#include <mt/common.h>
+typedef unsigned long UINT32;
+typedef BOOL unsigned long;
+
+typedef struct{
+/*LCDCON1*/
+	UINT32 VCLK;
+	UINT32 EACH_FRAME;
+	UINT32 LCD_PANNEL;
+	UINT32 BPP_MODE;
+	UINT32 LCD_OUTPUT;
+
+/*LCDCON2*/
+	UINT32 VBPD;
+	UINT32 VACTIVE;
+	UINT32 VFPD;
+	UINT32 VSPW;
+
+/*LCDCON3*/	
+	UINT32 VACTIVE_HIGHBIT;
+	UINT32 HBPD;
+	UINT32 HACTIVE;
+	UINT32 HFPD;
+
+/*LCDCON4*/	
+	UINT32 HSPW;
+
+/*LCDCON5*/
+	UINT32 COLOR_MODE;
+	UINT32 BPP24BL;
+	UINT32 FRM565;
+	UINT32 INVVCLK;
+	UINT32 INVVLINE;
+	UINT32 INVVFRAME;
+	UINT32 INVVD;
+	UINT32 INVVDEN;
+	UINT32 INVPWREN;
+	UINT32 INVENDLINE;
+	UINT32 PWREN;
+	UINT32 ENLEND;
+	UINT32 BSWP;
+	UINT32 HWSWP;
+} struct_lcd_timing_param;
+
+typedef struct{
+/*DPLLCFG*/
+	UINT32 DPLLCFG;
+
+/*DIVCFG4*/	
+	UINT32 DIVCFG4;
+} struct_lds_clk_param;
+
+typedef enum
+{
+	LCD = 0,
+	HDMI_1080P,
+	HDMI_720P,
+	HDMI_480P,
+}LCD_TIMING;
+
+BOOL lcd_change_timing(LCD_TIMING timing);
+void lcd_config_clk(LCD_TIMING timing);
+void lcd_config_controller(LCD_TIMING timing);
+int pt_hdmi_cable_check(void); 
+int pt_hdmi_init(void);
+int pt_hdmi_release(void); 
diff --git a/drivers/video/hdmi/ep932/imap_HDMI.c b/drivers/video/hdmi/ep932/imap_HDMI.c
new file mode 100644
index 0000000..d6798f2
--- /dev/null
+++ b/drivers/video/hdmi/ep932/imap_HDMI.c
@@ -0,0 +1,1324 @@
+/***************************************************************************** 
+ * ** drivers/video/infotm_HDMI/imap_HDMI.c
+ * ** 
+ * ** Copyright (c) 2009~2014 ShangHai Infotm Ltd all rights reserved. 
+ * ** 
+ * ** Use of Infotm's code is governed by terms and conditions 
+ * ** stated in the accompanying licensing statement. 
+ * ** 
+ * ** Description: Implementation file of Infotm HDMI.
+ * **
+ * ** Author:
+ * **     Alex Zhang <alex.zhang@infotmic.com.cn>
+ * **      
+ * ** Revision History: 
+ * ** ----------------- 
+ * ** 1.0  06/11/2010 Alex Zhang 
+ * ** 1.1  06/18/2010 Alex Zhang 
+ * ** 2.0  06/21/2010 Alex Zhang 
+ * ** 2.1  06/23/2010 Alex Zhang 
+ * ** 2.2  06/24/2010 Alex Zhang 
+ * *****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/mutex.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/ioctl.h>
+#include <linux/poll.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <plat/imapx.h>
+#include <asm/mach/irq.h>
+
+/* import imapfb configuration for compatibility */
+#include "../../infotm/imapfb.h"
+#include "imap_HDMI.h"
+#include "EP932api.h"
+#include "EP932Controller.h"
+
+#ifdef CONFIG_FAKE_PM
+#include <plat/fake_pm.h>
+#endif
+
+#define HDMI_MAJOR               84
+#define HDMI_POLL_MAJOR               85
+#define HDMI_MINOR               0
+#define i2c_device_address  0x70
+
+#define turn_on_backlight() imapx_gpio_setcfg(__imapx_name_to_gpio(CONFIG_IG_LCD_BACKLIGHT), IG_CTRL0, IG_NORMAL)
+
+#define turn_off_backlight()	\
+({				\
+	imapx_gpio_setcfg(__imapx_name_to_gpio(CONFIG_IG_LCD_BACKLIGHT), IG_OUTPUT, IG_NORMAL);	\
+	imapx_gpio_setpin(__imapx_name_to_gpio(CONFIG_IG_LCD_BACKLIGHT), 0, IG_NORMAL);	\
+})
+
+static unsigned short normal_i2c[] = {0, I2C_CLIENT_END};
+
+static struct class *HDMI_class;
+
+I2C_CLIENT_INSMOD;
+
+wait_queue_head_t       HDMI_wait;
+spinlock_t              lock;
+struct completion	Monitor_Wait;
+unsigned int	HDMI_MENU_SWITCH = -1; 
+unsigned int	HDMI_HOTPLUG_IN = -1;
+unsigned int    HDMI_HOTPLUG_RESULT = 0;
+unsigned int VIDEO_MODE = 0;
+EXTERL_SYMBOL(VIDEO_MODE);
+unsigned int DOUBLE_DISPLAY_MODE = 0;
+EXTERL_SYMBOL(DOUBLE_DISPLAY_MODE);
+unsigned int PANAUISION_MODE = 0;
+EXTERL_SYMBOL(PANAUISION_MODE);
+unsigned int HDMI_QUERY_MONITOR_FLAG = -1;
+static unsigned int previous_mode = 1;
+
+#define HDMI_HP_POLL_DELAY	1000
+extern void imapbl_lowlevel_blctrl(int);
+extern void imap_iokey_spken(int);
+
+static const struct i2c_device_id HDMI_i2c_id[] = {
+	{ "imap_HDMI", 0 },
+	{ }
+};
+
+static struct i2c_client gHDMIClient;
+static struct mutex HDMI_lock;
+
+struct imap_HDMI_info {
+	struct device *dev;
+	struct i2c_client *client;
+	struct delayed_work    delayed_work;
+};
+
+struct_lcd_timing_param ids_timing[10] = 
+{
+	{0}, /* this row is removed, lcd timing will be provied by lcd driver, apr.20.2011 */
+
+	{1,0,3,12,0,36,1080,4,5,1,127,1920,109,44,0x06,0,0,0,0,0,0,0,0,0,0,0,0,1},
+	{1,0,3,12,0,20,720,5,5,0,127,1280,203,40,0x06,0,0,0,0,0,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,30,480,9,6,0,60,720,16,62,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,30,480,9,6,0,60,720,16,62,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,39,576,5,5,0,68,720,12,64,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,39,576,5,5,0,68,720,12,64,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1}, 
+	{2,0,3,12,0,33,480,10,2,0,48,640,16,96,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},    
+	{1,0,3,12,0,23,600,1,4,0,88,800,40,128,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,29,768,3,6,0,160,1024,24,136,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+};
+
+struct_tvif_timing_param tvif_timing[10] = 
+{
+	{1,0,0,1,0,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/18,/**/600,/**/10,/**/18,/**/600,/**/10,/**/408,/**/1024,/**/0,134,32,/**/134,4667,/**/134,4667,/**/1023,/**/599},
+	{1,0,0,1,1,/**/0,1,0,1,0,0,1,1,0,0,0,/**/0,1,0,0,0,0,
+	 /**/41,/**/1080,/**/4,/**/41,/**/1080,/**/4,/**/272,/**/1920,/**/0,84,44,/**/84,8191,/**/84,8191,/**/1919,/**/1079},
+	{1,0,0,1,1,/**/0,1,0,1,0,0,1,1,0,0,0,/**/0,1,0,0,0,0,
+	 /**/25,/**/720,/**/5,/**/25,/**/720,/**/5,/**/362,/**/1280,/**/0,106,40,/**/106,8191,/**/106,8191,/**/1279,/**/719},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	/**/36,/**/480,/**/9,/**/36,/**/480,/**/9,/**/130,/**/720,/**/0,12,62,/**/12,5147,/**/12,5147,/**/719,/**/479},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/36,/**/480,/**/9,/**/36,/**/480,/**/9,/**/130,/**/720,/**/0,12,62,/**/12,5147,/**/12,5147,/**/719,/**/479},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/44,/**/576,/**/5,/**/44,/**/576,/**/5,/**/136,/**/720,/**/0,8,64,/**/8,4319,/**/8,4319,/**/719,/**/575},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/44,/**/576,/**/5,/**/44,/**/576,/**/5,/**/136,/**/720,/**/0,8,64,/**/8,4319,/**/8,4319,/**/719,/**/575},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/35,/**/480,/**/10,/**/35,/**/480,/**/10,/**/152,/**/640,/**/0,12,96,/**/12,1599,/**/12,1599,/**/639,/**/479},
+	{1,0,0,1,1,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/27,/**/600,/**/1,/**/27,/**/600,/**/1,/**/248,/**/800,/**/0,40,128,/**/40,3168,/**/40,3168,/**/799,/**/599},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/35,/**/768,/**/3,/**/35,/**/768,/**/3,/**/312,/**/1024,/**/0,24,136,/**/24,6720,/**/24,6720,/**/1023,/**/767},
+};
+
+struct_lds_clk_param ids_clk[10] = 
+{
+	{0x13,0 /* this value is removed, invoke lcd driver interface instead, apr.20.2011 */},
+	{0x24,0x0909},
+	{0x24,0x1515},
+	{0x1A,0x1D1D},
+	{0x1A,0x1D1D},
+	{0x1A,0x1D1D},
+	{0x1A,0x1D1D},
+	{0x18,0x1D1D},
+	{0x13,0x1515},
+	{0x40,0x1d1d},
+};
+
+static unsigned int LCDCON_DataBuf[6];
+static unsigned int LCDINT_DataBuf[3];
+static unsigned int OVLCON0_DataBuf[12];
+static unsigned int OVLCON1_DataBuf[12];
+static unsigned int OVLCON2_DataBuf[12];
+static unsigned int OVLCON3_DataBuf[10];
+static unsigned int OVLCOLCON_DataBuf[14];
+static unsigned int OVLPAL0_DataBuf[256];
+static unsigned int OVLPAL1_DataBuf[256];
+static unsigned int OVLPAL2_DataBuf[128];
+static unsigned int OVLPAL3_DataBuf[128];
+
+/*only for system UI*/
+void osd_excursion(LCD_TIMING timing)
+{
+	unsigned int lefttopx;
+	unsigned int lefttopy;
+	unsigned int rightbottomx;
+	unsigned int rightbottomy;
+	unsigned int excursionx = 0;
+	unsigned int excursiony = 0;
+
+	switch(timing)
+	{
+		case HDMI_1080P:                                 
+			excursionx = (1920 - imapfb_fimd.xres)/2;
+			excursiony = (1080 - imapfb_fimd.yres)/2;
+			break;                                   
+
+		case HDMI_720P:                                  
+			excursionx = (1280- imapfb_fimd.xres)/2; 
+			excursiony = (720- imapfb_fimd.yres)/2;  
+			break;                                   
+
+		case HDMI_480P_16_9:                             
+		case HDMI_480P_4_3:                              
+			excursionx = (720 - imapfb_fimd.xres)/2; 
+			excursiony = (480 - imapfb_fimd.yres)/2; 
+			break;                                   
+
+		case HDMI_576P_16_9:                             
+		case HDMI_576P_4_3:                              
+			excursionx = (720 - imapfb_fimd.xres)/2; 
+			excursiony = (576 - imapfb_fimd.yres)/2; 
+			break;                                   
+
+		case HDMI_640_480:                               
+			excursionx = (640- imapfb_fimd.xres)/2;  
+			excursiony = (480- imapfb_fimd.yres)/2;  
+			break;                                   
+
+		case HDMI_800_600:
+			excursionx = (800 - imapfb_fimd.xres)/2;
+			excursiony = (600 - imapfb_fimd.yres)/2;
+			break;
+
+		case HDMI_1024_768:
+			excursionx = (1024 - imapfb_fimd.xres)/2;
+			excursiony = (768 - imapfb_fimd.yres)/2;
+			break;
+		default:
+			printk("Not supported by now Maybe later\n");
+			break;
+	}
+
+	lefttopx = 0;//((__raw_readl(IMAP_OVCW0PCAR) >> 16) & (0x7ff));
+	lefttopy = 0;//((__raw_readl(IMAP_OVCW0PCAR) >> 0) & (0x7ff));
+	rightbottomx = imapfb_fimd.xres;//((__raw_readl(IMAP_OVCW0PCBR) >> 16) & (0x7ff));
+	rightbottomy = imapfb_fimd.yres;//((__raw_readl(IMAP_OVCW0PCBR) >> 0) & (0x7ff));
+	__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(lefttopx + excursionx) | IMAP_OVCWxPCAR_LEFTTOPY(lefttopy + excursiony), IMAP_OVCW0PCAR);
+	__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(rightbottomx + excursionx - 1) | IMAP_OVCWxPCBR_RIGHTBOTY(rightbottomy + excursiony - 1), IMAP_OVCW0PCBR);
+}
+
+BOOL lcd_change_timing(LCD_TIMING timing, BOOL tv_IF)
+{
+	unsigned int temp;
+	unsigned char temp_reg[4];
+	int i;
+
+/*close lcd screen*/
+//	if(timing != LCD)
+//	  imapbl_lowlevel_blctrl(0);
+
+	/*Save IDS register value before software reset*/
+	/*LCD controller*/
+	LCDCON_DataBuf[0] = __raw_readl(IMAP_LCDCON1);
+	LCDCON_DataBuf[1] = __raw_readl(IMAP_LCDCON2);
+	LCDCON_DataBuf[2] = __raw_readl(IMAP_LCDCON3);
+	LCDCON_DataBuf[3] = __raw_readl(IMAP_LCDCON4);
+	LCDCON_DataBuf[4] = __raw_readl(IMAP_LCDCON5);
+	LCDCON_DataBuf[5] = __raw_readl(IMAP_LCDVCLKFSR);
+
+/*Interrupt */	
+	LCDINT_DataBuf[0] = __raw_readl(IMAP_IDSINTPND);
+	LCDINT_DataBuf[1] = __raw_readl(IMAP_IDSSRCPND);
+	LCDINT_DataBuf[2] = __raw_readl(IMAP_IDSINTMSK);
+
+/*Overlay controller 0*/	
+	OVLCON0_DataBuf[0] = __raw_readl(IMAP_OVCDCR);
+	OVLCON0_DataBuf[1] = __raw_readl(IMAP_OVCPCR);	
+	OVLCON0_DataBuf[2] = __raw_readl(IMAP_OVCBKCOLOR);
+	OVLCON0_DataBuf[3] = __raw_readl(IMAP_OVCW0CR);
+	OVLCON0_DataBuf[4] = __raw_readl(IMAP_OVCW0PCAR);
+	OVLCON0_DataBuf[5] = __raw_readl(IMAP_OVCW0PCBR);
+	OVLCON0_DataBuf[6] = __raw_readl(IMAP_OVCW0B0SAR);
+	OVLCON0_DataBuf[7] = __raw_readl(IMAP_OVCW0B1SAR);
+	OVLCON0_DataBuf[8] = __raw_readl(IMAP_OVCW0VSSR);
+	OVLCON0_DataBuf[9] = __raw_readl(IMAP_OVCW0CMR);
+	OVLCON0_DataBuf[10] = __raw_readl(IMAP_OVCW0B2SAR);
+	OVLCON0_DataBuf[11] = __raw_readl(IMAP_OVCW0B3SAR);
+
+/*Overlay controller 1*/	
+	OVLCON1_DataBuf[0] = __raw_readl(IMAP_OVCW1CR);
+	OVLCON1_DataBuf[1] = __raw_readl(IMAP_OVCW1PCAR);
+	OVLCON1_DataBuf[2] = __raw_readl(IMAP_OVCW1PCBR);
+	OVLCON1_DataBuf[3] = __raw_readl(IMAP_OVCW1PCCR);
+	OVLCON1_DataBuf[4] = __raw_readl(IMAP_OVCW1B0SAR);
+	OVLCON1_DataBuf[5] = __raw_readl(IMAP_OVCW1B1SAR);
+	OVLCON1_DataBuf[6] = __raw_readl(IMAP_OVCW1VSSR);
+	OVLCON1_DataBuf[7] = __raw_readl(IMAP_OVCW1CKCR);
+	OVLCON1_DataBuf[8] = __raw_readl(IMAP_OVCW1CKR);
+	OVLCON1_DataBuf[9] = __raw_readl(IMAP_OVCW1CMR);
+	OVLCON1_DataBuf[10] = __raw_readl(IMAP_OVCW1B2SAR);
+	OVLCON1_DataBuf[11] = __raw_readl(IMAP_OVCW1B3SAR);
+
+/*Overlay controller 2*/	
+	OVLCON2_DataBuf[0] = __raw_readl(IMAP_OVCW2CR);
+	OVLCON2_DataBuf[1] = __raw_readl(IMAP_OVCW2PCAR);
+	OVLCON2_DataBuf[2] = __raw_readl(IMAP_OVCW2PCBR);
+	OVLCON2_DataBuf[3] = __raw_readl(IMAP_OVCW2PCCR);
+	OVLCON2_DataBuf[4] = __raw_readl(IMAP_OVCW2B0SAR);
+	OVLCON2_DataBuf[5] = __raw_readl(IMAP_OVCW2B1SAR);
+	OVLCON2_DataBuf[6] = __raw_readl(IMAP_OVCW2VSSR);
+	OVLCON2_DataBuf[7] = __raw_readl(IMAP_OVCW2CKCR);
+	OVLCON2_DataBuf[8] = __raw_readl(IMAP_OVCW2CKR);
+	OVLCON2_DataBuf[9] = __raw_readl(IMAP_OVCW2CMR);
+	OVLCON2_DataBuf[10] = __raw_readl(IMAP_OVCW2B2SAR);
+	OVLCON2_DataBuf[11] = __raw_readl(IMAP_OVCW2B3SAR);
+
+/*Overlay controller 3*/	
+	OVLCON3_DataBuf[0] = __raw_readl(IMAP_OVCW3CR);
+	OVLCON3_DataBuf[1] = __raw_readl(IMAP_OVCW3PCAR);
+	OVLCON3_DataBuf[2] = __raw_readl(IMAP_OVCW3PCBR);
+	OVLCON3_DataBuf[3] = __raw_readl(IMAP_OVCW3PCCR);
+	OVLCON3_DataBuf[4] = __raw_readl(IMAP_OVCW3BSAR);
+	OVLCON3_DataBuf[5] = __raw_readl(IMAP_OVCW3VSSR);
+	OVLCON3_DataBuf[6] = __raw_readl(IMAP_OVCW3CKCR);
+	OVLCON3_DataBuf[7] = __raw_readl(IMAP_OVCW3CKR);
+	OVLCON3_DataBuf[8] = __raw_readl(IMAP_OVCW3CMR);
+	OVLCON3_DataBuf[9] = __raw_readl(IMAP_OVCW3SABSAR);
+
+/*Overlay color controller*/	
+	OVLCOLCON_DataBuf[0] = __raw_readl(IMAP_OVCBRB0SAR);
+	OVLCOLCON_DataBuf[1] = __raw_readl(IMAP_OVCBRB1SAR);
+	OVLCOLCON_DataBuf[2] = __raw_readl(IMAP_OVCOEF11);
+	OVLCOLCON_DataBuf[3] = __raw_readl(IMAP_OVCOEF12);
+	OVLCOLCON_DataBuf[4] = __raw_readl(IMAP_OVCOEF13);
+	OVLCOLCON_DataBuf[5] = __raw_readl(IMAP_OVCOEF21);
+	OVLCOLCON_DataBuf[6] = __raw_readl(IMAP_OVCOEF22);
+	OVLCOLCON_DataBuf[7] = __raw_readl(IMAP_OVCOEF23);
+	OVLCOLCON_DataBuf[8] = __raw_readl(IMAP_OVCOEF31);
+	OVLCOLCON_DataBuf[9] = __raw_readl(IMAP_OVCOEF32);
+	OVLCOLCON_DataBuf[10] = __raw_readl(IMAP_OVCOEF33);
+	OVLCOLCON_DataBuf[11] = __raw_readl(IMAP_OVCOMC);
+	OVLCOLCON_DataBuf[12] = __raw_readl(IMAP_OVCBRB2SAR);
+	OVLCOLCON_DataBuf[13] = __raw_readl(IMAP_OVCBRB3SAR);
+
+/*Overlay PAL0 */
+	for(i=0;i<256;i++)	
+		OVLPAL0_DataBuf[i] = __raw_readl(IMAP_OVCW0PAL+i*0x4);
+
+/*Overlay PAL1 */
+	for(i=0;i<256;i++)	
+		OVLPAL1_DataBuf[i] = __raw_readl(IMAP_OVCW1PAL+i*0x4);
+
+/*Overlay PAL2 */
+	for(i=0;i<128;i++)	
+		OVLPAL2_DataBuf[i] = __raw_readl(IMAP_OVCW2PAL+i*0x4);
+
+/*Overlay PAL3 */
+	for(i=0;i<256;i++)	
+		OVLPAL3_DataBuf[i] = __raw_readl(IMAP_OVCW3PAL+i*0x4);
+
+/*Save lcd and osd open status*/
+	temp_reg[0] = (OVLCON0_DataBuf[3] & 0x1);
+	temp_reg[1]= (OVLCON1_DataBuf[0] & 0x1);
+	temp_reg[2]= (OVLCON2_DataBuf[0] & 0x1);
+	temp_reg[3]= (OVLCON3_DataBuf[0] & 0x1);
+
+/*LDS module software reset*/
+	temp = __raw_readl(rAHBP_RST);
+	temp |= 0x1<<6;
+	__raw_writel(temp, rAHBP_RST);
+
+	for(i=0;i<10;i++)
+		udelay(1000);
+
+	temp = __raw_readl(rAHBP_RST);
+	temp &= ~(0x1<<6);
+	__raw_writel(temp, rAHBP_RST);
+	
+/*Config LCD clock*/
+	lcd_config_clk(timing);
+
+/*write value back to register*/
+	__raw_writel(LCDINT_DataBuf[2], IMAP_IDSINTMSK);
+
+	__raw_writel(OVLCON0_DataBuf[0], IMAP_OVCDCR);
+	__raw_writel(OVLCON0_DataBuf[1], IMAP_OVCPCR);
+	__raw_writel(OVLCON0_DataBuf[2], IMAP_OVCBKCOLOR);
+	__raw_writel((OVLCON0_DataBuf[3] & ~0x1), IMAP_OVCW0CR);
+	__raw_writel(OVLCON0_DataBuf[4], IMAP_OVCW0PCAR);
+	__raw_writel(OVLCON0_DataBuf[5], IMAP_OVCW0PCBR);
+	__raw_writel(OVLCON0_DataBuf[6], IMAP_OVCW0B0SAR);
+	__raw_writel(OVLCON0_DataBuf[7], IMAP_OVCW0B1SAR);
+	__raw_writel(OVLCON0_DataBuf[8], IMAP_OVCW0VSSR);
+	__raw_writel(OVLCON0_DataBuf[9], IMAP_OVCW0CMR);
+	__raw_writel(OVLCON0_DataBuf[10], IMAP_OVCW0B2SAR);
+	__raw_writel(OVLCON0_DataBuf[11], IMAP_OVCW0B3SAR);
+	
+	__raw_writel((OVLCON1_DataBuf[0] & ~0x1), IMAP_OVCW1CR);
+	__raw_writel(OVLCON1_DataBuf[1], IMAP_OVCW1PCAR);
+	__raw_writel(OVLCON1_DataBuf[2], IMAP_OVCW1PCBR);
+	__raw_writel(OVLCON1_DataBuf[3], IMAP_OVCW1PCCR);
+	__raw_writel(OVLCON1_DataBuf[4], IMAP_OVCW1B0SAR);
+	__raw_writel(OVLCON1_DataBuf[5], IMAP_OVCW1B1SAR);
+	__raw_writel(OVLCON1_DataBuf[6], IMAP_OVCW1VSSR);
+	__raw_writel(OVLCON1_DataBuf[7], IMAP_OVCW1CKCR);
+	__raw_writel(OVLCON1_DataBuf[8], IMAP_OVCW1CKR);
+	__raw_writel(OVLCON1_DataBuf[9], IMAP_OVCW1CMR);
+	__raw_writel(OVLCON1_DataBuf[10], IMAP_OVCW1B2SAR);
+	__raw_writel(OVLCON1_DataBuf[11], IMAP_OVCW1B3SAR);
+	
+	__raw_writel((OVLCON2_DataBuf[0] & ~0x1), IMAP_OVCW2CR);
+	__raw_writel(OVLCON2_DataBuf[1], IMAP_OVCW2PCAR);
+	__raw_writel(OVLCON2_DataBuf[2], IMAP_OVCW2PCBR);
+	__raw_writel(OVLCON2_DataBuf[3], IMAP_OVCW2PCCR);
+	__raw_writel(OVLCON2_DataBuf[4], IMAP_OVCW2B0SAR);
+	__raw_writel(OVLCON2_DataBuf[5], IMAP_OVCW2B1SAR);
+	__raw_writel(OVLCON2_DataBuf[6], IMAP_OVCW2VSSR);
+	__raw_writel(OVLCON2_DataBuf[7], IMAP_OVCW2CKCR);
+	__raw_writel(OVLCON2_DataBuf[8], IMAP_OVCW2CKR);
+	__raw_writel(OVLCON2_DataBuf[9], IMAP_OVCW2CMR);
+	__raw_writel(OVLCON2_DataBuf[10], IMAP_OVCW2B2SAR);
+	__raw_writel(OVLCON2_DataBuf[11], IMAP_OVCW2B3SAR);
+
+	__raw_writel((OVLCON3_DataBuf[0] & ~0x1), IMAP_OVCW3CR);
+	__raw_writel(OVLCON3_DataBuf[1], IMAP_OVCW3PCAR);
+	__raw_writel(OVLCON3_DataBuf[2], IMAP_OVCW3PCBR);
+	__raw_writel(OVLCON3_DataBuf[3], IMAP_OVCW3PCCR);
+	__raw_writel(OVLCON3_DataBuf[4], IMAP_OVCW3BSAR);
+	__raw_writel(OVLCON3_DataBuf[5], IMAP_OVCW3VSSR);
+	__raw_writel(OVLCON3_DataBuf[6], IMAP_OVCW3CKCR);
+	__raw_writel(OVLCON3_DataBuf[7], IMAP_OVCW3CKR);
+	__raw_writel(OVLCON3_DataBuf[8], IMAP_OVCW3CMR);
+	__raw_writel(OVLCON3_DataBuf[9], IMAP_OVCW3SABSAR);
+
+	__raw_writel(OVLCOLCON_DataBuf[0], IMAP_OVCBRB0SAR);
+	__raw_writel(OVLCOLCON_DataBuf[1], IMAP_OVCBRB1SAR);
+	__raw_writel(OVLCOLCON_DataBuf[2], IMAP_OVCOEF11);
+	__raw_writel(OVLCOLCON_DataBuf[3], IMAP_OVCOEF12);
+	__raw_writel(OVLCOLCON_DataBuf[4], IMAP_OVCOEF13);
+	__raw_writel(OVLCOLCON_DataBuf[5], IMAP_OVCOEF21);
+	__raw_writel(OVLCOLCON_DataBuf[6], IMAP_OVCOEF22);
+	__raw_writel(OVLCOLCON_DataBuf[7], IMAP_OVCOEF23);
+	__raw_writel(OVLCOLCON_DataBuf[8], IMAP_OVCOEF31);
+	__raw_writel(OVLCOLCON_DataBuf[9], IMAP_OVCOEF32);
+	__raw_writel(OVLCOLCON_DataBuf[10], IMAP_OVCOEF33);
+	__raw_writel(OVLCOLCON_DataBuf[11], IMAP_OVCOMC);
+	__raw_writel(OVLCOLCON_DataBuf[12], IMAP_OVCBRB2SAR);
+	__raw_writel(OVLCOLCON_DataBuf[13], IMAP_OVCBRB3SAR);
+
+	for(i=0;i<256;i++)
+		__raw_writel(OVLPAL0_DataBuf[i], IMAP_OVCW0PAL + 0x4*i);
+	
+	for(i=0;i<256;i++)
+		__raw_writel(OVLPAL1_DataBuf[i], IMAP_OVCW1PAL + 0x4*i);
+	
+	for(i=0;i<128;i++)
+		__raw_writel(OVLPAL2_DataBuf[i], IMAP_OVCW2PAL + 0x4*i);
+	
+	for(i=0;i<128;i++)
+		__raw_writel(OVLPAL3_DataBuf[i], IMAP_OVCW3PAL + 0x4*i);
+	
+
+/*disable lcd output before change timing*/	
+//	WRITE_REG(IMAP_LCDCON1, (READ_REG(IMAP_LCDCON1) & ~IMAP_LCDCON1_ENVID_ENABLE));
+//	WRITE_REG(IMAP_OVCW0CR , (READ_REG(IMAP_OVCW0CR) & ~IMAP_OVCWxCR_ENWIN_ENABLE));	
+
+/*change osd window smaller than Hactive and Vactive back to system resolution if timing 12*/
+
+	if(timing == LCD || (imapfb_fimd.xres == 800 && timing == HDMI_800_600) || (imapfb_fimd.xres == 1024 && timing == HDMI_1024_768))
+	{
+		/* if LCD use imapfb_fimd configurations, apr.20.2011 */
+		__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0), IMAP_OVCW0PCAR);
+		__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(imapfb_fimd.xres - 1) |
+		   IMAP_OVCWxPCBR_RIGHTBOTY(imapfb_fimd.yres - 1), IMAP_OVCW0PCBR);
+
+	}
+	else
+	{
+		if(ids_timing[timing].HACTIVE < imapfb_fimd.xres)
+		{	
+			__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0), IMAP_OVCW0PCAR);
+			__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(ids_timing[timing].HACTIVE -1) | IMAP_OVCWxPCBR_RIGHTBOTY((__raw_readl(IMAP_OVCW0PCBR) & 0x7ff ) -1), IMAP_OVCW0PCBR);
+		}
+
+		if(ids_timing[timing].VACTIVE < imapfb_fimd.yres)
+		{	
+			__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0), IMAP_OVCW0PCAR);
+			__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(((__raw_readl(IMAP_OVCW0PCBR) & (0x7ff<<16)) >> 16) -1) | IMAP_OVCWxPCBR_RIGHTBOTY(ids_timing[timing].VACTIVE -1), IMAP_OVCW0PCBR);
+		}
+	}
+
+/*
+	WRITE_REG(IMAP_OVCW0PCAR , IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0));
+	WRITE_REG(IMAP_OVCW0PCBR , IMAP_OVCWxPCBR_RIGHTBOTX(639) | IMAP_OVCWxPCBR_RIGHTBOTY(479));
+*/
+	
+/*change timing*/
+	lcd_config_controller(timing);
+	if(tv_IF == 1)
+	{
+		if(timing == LCD)
+		{
+			__raw_writel((__raw_readl(IMAP_LCDCON5) & ~(0x3<<11)), IMAP_LCDCON5);
+		}
+		else
+		{
+			__raw_writel((__raw_readl(IMAP_LCDCON5) | (0x2<<11)), IMAP_LCDCON5);
+			tvif_config_controller(timing);
+		}
+	}
+
+/*enable lcd data output*/	
+	if(temp_reg[0])
+		__raw_writel((__raw_readl(IMAP_OVCW0CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW0CR);
+
+	if(temp_reg[1])
+		__raw_writel((__raw_readl(IMAP_OVCW1CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW1CR);
+
+	if(temp_reg[2])
+		__raw_writel((__raw_readl(IMAP_OVCW2CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW2CR);
+
+	if(temp_reg[3])
+		__raw_writel((__raw_readl(IMAP_OVCW3CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW3CR);
+
+	if(tv_IF == 1)
+	{
+		if(timing == LCD)
+		{
+			__raw_writel((__raw_readl(IMAP_TVICR) & ~(0x1<<31)), IMAP_TVICR);
+			__raw_writel((__raw_readl(IMAP_OVCDCR) & ~(0x3)), IMAP_OVCDCR);
+			__raw_writel((__raw_readl(IMAP_LCDCON1) | IMAP_LCDCON1_ENVID_ENABLE), IMAP_LCDCON1);
+		}
+//		else if (timing == HDMI_800_600 || timing == HDMI_1024_768 || timing == HDMI_720P){
+//			__raw_writel((__raw_readl(IMAP_OVCDCR) | (0x1<<1)), IMAP_OVCDCR);
+//			msleep(10);
+//			__raw_writel((__raw_readl(IMAP_TVICR) | (0x1<<31)), IMAP_TVICR);
+//		}
+		else{
+			__raw_writel((__raw_readl(IMAP_OVCDCR) | (0x1<<1)), IMAP_OVCDCR);
+			msleep(10);
+			__raw_writel((__raw_readl(IMAP_TVICR) | (0x1<<31)), IMAP_TVICR);
+		}
+	}
+	else
+	{
+		__raw_writel((__raw_readl(IMAP_LCDCON1) | IMAP_LCDCON1_ENVID_ENABLE), IMAP_LCDCON1);
+	}
+
+//	if(timing == LCD || timing == HDMI_800_600 || timing == HDMI_1024_768)
+//	{
+//		imapbl_lowlevel_blctrl(1);	
+//	}
+}
+
+
+void lcd_config_clk(LCD_TIMING timing)
+{
+	unsigned int temp;
+
+	/* if lcd, use imapfb_set_clk interface, apr.20.2011 */
+	if(timing == LCD)
+	{
+		imapfb_set_clk();
+		return ;
+	}
+
+	temp = readl(rDPLL_CFG); 
+	temp &=~(1<<31);
+	writel(temp,rDPLL_CFG);
+
+	temp = readl(rDPLL_CFG); 
+	temp = ids_clk[timing].DPLLCFG;
+	writel(temp,rDPLL_CFG);
+
+	//enable dpll	
+	temp = readl(rDPLL_CFG); 
+	temp |=(1<<31);
+	writel(temp,rDPLL_CFG);
+
+	/*wait untill dpll is locked*/
+	while(!(readl(rPLL_LOCKED) & 0x2));
+
+	temp = readl(rDIV_CFG4);
+	temp = ids_clk[timing].DIVCFG4;
+	writel(temp,rDIV_CFG4);
+}
+
+void tvif_config_controller(LCD_TIMING timing)
+{
+	unsigned int reg_temp[16];
+
+	reg_temp[0] = (tvif_timing[timing].Clock_enable << 31) |
+			(tvif_timing[timing].TV_PCLK_mode << 11) |
+			(tvif_timing[timing].Inv_clock << 9) |
+			(tvif_timing[timing].clock_sel << 8) |
+			(tvif_timing[timing].Clock_div << 0 );
+
+	reg_temp[1] = (tvif_timing[timing].tvif_enable << 31) |
+			(tvif_timing[timing].ITU601_656n << 30) |
+			(tvif_timing[timing].Bit16ofITU60 << 29) |
+			(tvif_timing[timing].Direct_data << 28 ) |
+			(tvif_timing[timing].Bitswap << 18 ) |
+			(tvif_timing[timing].Data_order << 16) |
+			(tvif_timing[timing].Inv_vsync << 13 ) |
+			(tvif_timing[timing].Inv_hsync << 12 ) |
+			(tvif_timing[timing].Inv_href << 11 ) |
+			(tvif_timing[timing].Inv_field << 10) |
+			(tvif_timing[timing].Begin_with_EAV << 0);
+
+	reg_temp[2] = (tvif_timing[timing].Matrix_mode << 31 ) |
+			(tvif_timing[timing].Passby << 30) |
+			(tvif_timing[timing].Inv_MSB_in << 29)|
+			(tvif_timing[timing].Inv_MSB_out << 28) |
+			(tvif_timing[timing].Matrix_oft_b << 8 ) |
+			(tvif_timing[timing].Matrix_oft_a << 0);
+
+	reg_temp[3] = tvif_timing[timing].UBA1_LEN;
+
+	reg_temp[4] = tvif_timing[timing].UNBA_LEN;
+
+	reg_temp[5] = tvif_timing[timing].UNBA2_LEN;
+
+	reg_temp[6] = tvif_timing[timing].LBA1_LEN;
+
+	reg_temp[7] = tvif_timing[timing].LNBA_LEN;
+
+	reg_temp[8] = tvif_timing[timing].LBA2_LEN;
+
+	reg_temp[9] = tvif_timing[timing].BLANK_LEN;
+
+	reg_temp[10] = tvif_timing[timing].VIDEO_LEN;
+
+	reg_temp[11] = (tvif_timing[timing].Hsync_VB1_ctrl << 30)|
+			(tvif_timing[timing].Hsync_delay << 16) |
+			(tvif_timing[timing].Hsync_extend);
+
+	reg_temp[12] = (tvif_timing[timing].Vsync_delay_upper << 16) |
+			(tvif_timing[timing].Vsync_extend_upper);
+
+	reg_temp[13] = (tvif_timing[timing].Vsync_delay_lower << 16) |
+			(tvif_timing[timing].Vsync_extend_lower);
+
+	reg_temp[14] = tvif_timing[timing].DISP_XSIZE;
+
+	reg_temp[15] = tvif_timing[timing].DISP_YSIZE;	
+
+	__raw_writel(reg_temp[0], IMAP_TVCCR);
+	__raw_writel(reg_temp[1], IMAP_TVICR);
+	__raw_writel(reg_temp[2], IMAP_TVCMCR);
+	__raw_writel(reg_temp[3], IMAP_TVUBA1);
+	__raw_writel(reg_temp[4], IMAP_TVUNBA);
+	__raw_writel(reg_temp[5], IMAP_TVUBA2);
+	__raw_writel(reg_temp[6], IMAP_TVLBA1);
+	__raw_writel(reg_temp[7], IMAP_TVLNBA);
+	__raw_writel(reg_temp[8], IMAP_TVLBA2);
+	__raw_writel(reg_temp[9], IMAP_TVBLEN);
+	__raw_writel(reg_temp[10], IMAP_TVVLEN);
+	__raw_writel(reg_temp[11], IMAP_TVHSCR);
+	__raw_writel(reg_temp[12], IMAP_TVVSHCR);
+	__raw_writel(reg_temp[13], IMAP_TVVSLCR);
+	__raw_writel(reg_temp[14], IMAP_TVXSIZE);
+	__raw_writel(reg_temp[15], IMAP_TVYSIZE);
+}
+
+void lcd_config_controller(LCD_TIMING timing)
+{	
+	unsigned int reg_temp[5];
+
+	if(timing == LCD)
+	{
+		/* if LCD , use imapfb_fimd configurations, apr.20.2011 */
+		writel(imapfb_fimd.lcdcon1, IMAP_LCDCON1); 
+		writel(imapfb_fimd.lcdcon2, IMAP_LCDCON2); 
+		writel(imapfb_fimd.lcdcon3, IMAP_LCDCON3); 
+		writel(imapfb_fimd.lcdcon4, IMAP_LCDCON4); 
+		writel(imapfb_fimd.lcdcon5, IMAP_LCDCON5); 
+
+		return ;
+	}
+
+	reg_temp[0] = (ids_timing[timing].VCLK <<	8) |		
+				(ids_timing[timing].EACH_FRAME << 7) |		
+				(ids_timing[timing].LCD_PANNEL << 5) |		
+				(ids_timing[timing].BPP_MODE << 1) |
+				(ids_timing[timing].LCD_OUTPUT);
+
+	reg_temp[1] = ((ids_timing[timing].VBPD -1) << 24) |
+				(((ids_timing[timing].VACTIVE -1) & ~0x400) <<14) |
+				((ids_timing[timing].VFPD -1 ) << 6) |
+				((ids_timing[timing].VSPW -1));
+
+	reg_temp[2] = (ids_timing[timing].VACTIVE_HIGHBIT <<31) |
+				((ids_timing[timing].HBPD -1) << 19) |
+				((ids_timing[timing].HACTIVE -1) << 8) |
+				((ids_timing[timing].HFPD -1));
+
+	reg_temp[3] = ((ids_timing[timing].HSPW -1));
+
+	reg_temp[4] = ((ids_timing[timing].COLOR_MODE) << 24)|
+				((ids_timing[timing].BPP24BL) << 12)|
+				((ids_timing[timing].FRM565) << 11) |
+				((ids_timing[timing].INVVCLK) << 10)|
+				((ids_timing[timing].INVVLINE) <<9 )|
+				((ids_timing[timing].INVVFRAME) <<8)|
+				((ids_timing[timing].INVVD) <<7) |
+				((ids_timing[timing].INVVDEN) << 6) |
+				((ids_timing[timing].INVPWREN) << 5)|
+				((ids_timing[timing].INVENDLINE) << 4)|
+				((ids_timing[timing].PWREN) << 3) |
+				((ids_timing[timing].ENLEND) <<2 ) |
+				((ids_timing[timing].BSWP) << 1) |
+				((ids_timing[timing].HWSWP));
+				
+	writel(reg_temp[0],IMAP_LCDCON1);
+	writel(reg_temp[1],IMAP_LCDCON2);
+	writel(reg_temp[2],IMAP_LCDCON3);
+	writel(reg_temp[3],IMAP_LCDCON4);
+	writel(reg_temp[4],IMAP_LCDCON5);
+}
+
+int HDMI_dev_init(struct i2c_client *client)
+{
+	unsigned int temp;
+
+	/* Enable HDMI power, by warits Dec 22, 2010 */
+	printk(KERN_ERR "Enabling HDMI power\n");
+
+	temp = __imapx_name_to_gpio(CONFIG_HDMI_EP932_POWER);
+	if(temp ==  IMAPX_GPIO_ERROR)
+	  printk(KERN_ERR "Get EP932 power pin failed.\n");
+	else
+	{
+		imapx_gpio_setcfg(temp, IG_OUTPUT, IG_NORMAL);
+		imapx_gpio_setpin(temp, 1, IG_NORMAL);
+	}
+
+	EP932_If_Initial();
+	EP_EP932M_Reset();
+
+	/* get and config interrupt */
+	/*
+	temp = __imapx_name_to_gpio(CONFIG_HDMI_EP932_INT);
+
+	if(temp == IMAPX_GPIO_ERROR)
+	{
+		printk(KERN_ERR "Get EP932 interrupt failed.\n");
+		return -ENOTTY;
+	}
+	*/
+
+	/* config irq status */
+	//imapx_gpio_setirq(temp, FILTER_MAX, IG_FALL, 1);
+
+	EP_EP932M_Reset();
+
+	return 0;
+}
+
+unsigned int hdmi_count = 0;
+
+static void hp_delayed_work(struct work_struct *work)
+{
+	unsigned int ret;
+	struct imap_HDMI_info *HDMI_info =
+		        container_of(to_delayed_work(work), struct imap_HDMI_info, delayed_work);
+	
+	ret = EP932_HotPlugMonitorInt();
+
+//	printk("ret %d HDMI_QUERY_MONITOR_FLAG %d \
+			VIDEO_MODE %d DOUBLE_DISPLAY_MODE %d HDMI_HOTPLUG_RESULT %d \
+			hdmi_count %d\n",ret, HDMI_QUERY_MONITOR_FLAG, VIDEO_MODE,\
+		       				DOUBLE_DISPLAY_MODE, HDMI_HOTPLUG_RESULT, hdmi_count);
+	if(ret == -1)
+	{ 
+		printk("[HDMI_Hotplug] no hotplug int detect\n");
+	}
+	else if((ret == 1) && \
+		(HDMI_QUERY_MONITOR_FLAG == 1) && \
+		(VIDEO_MODE == 0 || DOUBLE_DISPLAY_MODE == 0 || PANAUISION_MODE == 0) && \
+	       	HDMI_HOTPLUG_RESULT == 0 && \
+		hdmi_count >5)
+	{
+		HDMI_QUERY_MONITOR_FLAG = -1;
+		HDMI_HOTPLUG_IN = 1;
+		HDMI_HOTPLUG_RESULT = 1;
+		hdmi_count = 0;
+		complete(&Monitor_Wait);
+	}
+	else if((ret == 0) && \
+		(HDMI_QUERY_MONITOR_FLAG == 1) && \
+		(VIDEO_MODE == 1 || DOUBLE_DISPLAY_MODE == 1 || PANAUISION_MODE == 1) && \
+	       	HDMI_HOTPLUG_RESULT == 1 && \
+		hdmi_count >5)
+	{
+		HDMI_QUERY_MONITOR_FLAG = -1;
+		HDMI_HOTPLUG_IN= 0;
+		HDMI_HOTPLUG_RESULT = 0;
+		hdmi_count = 0;
+		complete(&Monitor_Wait);
+	}
+
+	hdmi_count ++ ;
+sche:
+	schedule_delayed_work(&HDMI_info->delayed_work,
+			msecs_to_jiffies(HDMI_HP_POLL_DELAY));
+
+}
+
+static int HDMI_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct device *dev = NULL;
+	struct task_struct *t;
+
+	printk(KERN_INFO "Device for HDMI will be Initializad\n");
+
+	/* register this i2c device with the driver core */
+	dev = device_create(HDMI_class, NULL, MKDEV(HDMI_MAJOR, HDMI_MINOR), NULL, "HDMI");
+	if (IS_ERR(dev))
+	{
+		ret = PTR_ERR(dev);
+		goto exit;
+	}
+
+	dev = device_create(HDMI_class, NULL, MKDEV(HDMI_POLL_MAJOR, HDMI_MINOR), NULL, "HDMI_poll");
+	if (IS_ERR(dev))
+	{
+		ret = PTR_ERR(dev);
+		goto exit;
+	}
+
+	memcpy(&gHDMIClient, client, sizeof(struct i2c_client));
+
+	mutex_init(&HDMI_lock);
+
+	/* HDMI device initialization */
+	ret = HDMI_dev_init(client);
+	if (ret < 0)
+	{
+		printk(KERN_ERR "HDMI_i2c_probe: failed to initialise EP932\n");
+		goto exit;
+	}
+
+	printk(KERN_INFO "Init HDMI device OK\n");
+
+	return 0;
+
+exit:
+	return ret;
+}
+
+static int HDMI_i2c_remove(struct i2c_client *client)
+{
+	printk(KERN_INFO "Remove HDMI device driver\n");
+
+	mutex_destroy(&HDMI_lock);
+
+	return 0;
+}
+
+static unsigned int 
+HDMI_poll(struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask;
+
+	poll_wait(file, &HDMI_wait, wait);
+
+	if(HDMI_HOTPLUG_IN == 1)
+		mask |= POLLIN | POLLRDNORM;
+	else
+		mask = POLLERR;
+
+	return mask;
+}
+
+static int HDMI_open(struct inode *inode, struct file *file)
+{
+	file->private_data = &gHDMIClient;
+	return 0;
+}
+
+static int HDMI_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static ssize_t
+HDMI_poll_write(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	HDMI_QUERY_MONITOR_FLAG = 1;
+	wait_for_completion(&Monitor_Wait);
+	printk("Monitor wait completion\n");
+
+	return 0;
+}
+
+static ssize_t
+HDMI_poll_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned int HDMI_HOTPLUG_TYPE = 0;
+	int ret = 0;
+
+	if(HDMI_HOTPLUG_IN == -1)
+	{
+		if(HDMI_MENU_SWITCH == -1)
+			HDMI_HOTPLUG_TYPE = 1;	/*No hotplug	No Menu button pressed*/
+		else if(HDMI_MENU_SWITCH == 0)
+			HDMI_HOTPLUG_TYPE = 2;	/*No hotplug	Menu Button Pressed to LCD*/
+		else if(HDMI_MENU_SWITCH == 1)
+			HDMI_HOTPLUG_TYPE = 3;	/*No hotplug	Menu Button Pressed to TV*/
+	}
+	else if(HDMI_HOTPLUG_IN == 0)
+	{
+		if(HDMI_MENU_SWITCH == -1)
+			HDMI_HOTPLUG_TYPE = 4;	/*hotplug out detected No menu button pressed*/
+		else if (HDMI_MENU_SWITCH == 0)
+			HDMI_HOTPLUG_TYPE = 5 ;	/*hotplug out detected menu button pressed to LCD*/
+		else if (HDMI_MENU_SWITCH == 1)
+			HDMI_HOTPLUG_TYPE = 6 ;	/*hotplug out detected menu button pressed to TV*/
+	}
+	else if(HDMI_HOTPLUG_IN == 1)
+	{
+		if(HDMI_MENU_SWITCH == -1)
+			HDMI_HOTPLUG_TYPE = 7;	/*hotplug in detected No menu button pressed*/
+		else if (HDMI_MENU_SWITCH == 0)
+			HDMI_HOTPLUG_TYPE = 8 ;	/*hotplug in detected menu button pressed to LCD*/
+		else if (HDMI_MENU_SWITCH == 1)
+			HDMI_HOTPLUG_TYPE = 9 ;	/*hotplug in detected menu button pressed to TV*/
+	}
+
+	if(copy_to_user((void __user *)buf, &HDMI_HOTPLUG_TYPE, sizeof(unsigned int)))
+	{
+		printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+		ret = -EFAULT;
+	}
+	HDMI_HOTPLUG_IN = -1;
+	HDMI_MENU_SWITCH = -1;
+
+	return ret;
+}
+
+static long HDMI_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	unsigned int temp1;
+	unsigned int temp2;
+	unsigned int check_result;
+	unsigned long flags;
+	void __user *argp = (void __user *)arg;
+	LCD_TIMING HDMI_TIMING_TYPE ;
+
+	mutex_lock(&HDMI_lock);
+
+	switch(cmd)
+	{
+		case HDMI_CHECK_MODE:
+			printk("%s commond :HDMI_CHECK previous_mode %d\n",__func__, previous_mode);
+			if(copy_to_user((void __user *)argp, &previous_mode, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+				ret = -EFAULT;
+			}
+			break;
+		case HDMI_CHECK_CONNECT:
+			printk("%s commond :HDMI_CHECK_CONNECT\n",__func__);
+			if(copy_to_user((void __user *)argp, &HDMI_HOTPLUG_RESULT, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+				ret = -EFAULT;
+			}
+			break;
+		case HDMI_SET_MODE:
+			printk("%s commond :HDMI_SET_MODE previous_mode %d\n",__func__, previous_mode);
+			if(copy_from_user(&previous_mode, argp, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy previous_mode from  user space error\n");
+				ret = -EFAULT;
+			}
+			break;
+		case HDMI_SET_NOTMAL_TIMING:  //return
+			if(VIDEO_MODE == 1 || DOUBLE_DISPLAY_MODE == 1 || PANAUISION_MODE == 1)
+			{
+				printk("%s commond : HDMI_SET_NOTMAL_TIMING\n",__func__);
+#ifdef CONFIG_UI_MAP_COLOR
+				if(VIDEO_MODE == 1)
+				{
+					__raw_writel(~0x1<<24, IMAP_OVCW0CMR);
+					__raw_writel(~0x1<<24, IMAP_OVCW3CMR);
+				}
+#endif
+				turn_off_backlight();
+				VIDEO_MODE = 0;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+				HDMI_Tx_Mute_Enable();
+				HDMI_Tx_Power_Down();
+				msleep(1000);
+				lcd_change_timing(LCD, 1);
+				imap_iokey_spken(1);
+				turn_on_backlight();
+			}
+			break;
+		case HDMI_SET_VIDEO_TIMING:  //enter hdmi mode
+			if(copy_from_user(&HDMI_TIMING_TYPE, argp, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy from user space error\n");
+				ret = -EFAULT;
+			}
+			if(VIDEO_MODE == 0)
+			{
+				turn_off_backlight();
+				imap_iokey_spken(0);
+				printk("%s commond : HDMI_SET_VIDEO_TIMING\n",__func__);
+#ifdef CONFIG_UI_MAP_COLOR
+				__raw_writel(0x1<<24 | ((0x0 & 0xffffff)<<0), IMAP_OVCW0CMR);
+				__raw_writel(0x1<<24 | ((0x0 & 0xffffff)<<0), IMAP_OVCW3CMR);
+#endif				
+				HDMI_Tx_Mute_Enable();
+				HDMI_Tx_Power_Down();
+				lcd_change_timing(HDMI_TIMING_TYPE - HDMI_640_480, 1);
+				hdmi_main(HDMI_TIMING_TYPE - HDMI_640_480);
+				VIDEO_MODE = 1;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+			}
+			break;
+		case HDMI_SET_DOUBLE_DISPLAY_TIMING:
+#ifdef CONFIG_DOUBLE_DISPLAY_MODE
+#ifdef CONFIG_UI_MAP_COLOR
+			if(VIDEO_MODE == 1)
+			{
+				__raw_writel(~0x1<<24, IMAP_OVCW0CMR);
+				__raw_writel(~0x1<<24, IMAP_OVCW3CMR);
+			}
+#endif
+			if(DOUBLE_DISPLAY_MODE == 0)
+			{
+				turn_off_backlight();
+				HDMI_Tx_Mute_Enable();
+				HDMI_Tx_Power_Down();
+				printk("%s commond :HDMI_SET_DOUBLE_DISPLAY_TIMING ",__func__);
+				if(imapfb_fimd.xres == 800){
+					lcd_change_timing(HDMI_800_600, 1);
+					hdmi_main(HDMI_800_600);
+				}else if(imapfb_fimd.xres == 1024){
+					lcd_change_timing(HDMI_1024_768, 1);
+					hdmi_main(HDMI_1024_768);
+				}
+				DOUBLE_DISPLAY_MODE = 1;
+				PANAUISION_MODE = 0;
+				VIDEO_MODE = 0;
+				previous_mode = 1;
+				msleep(1000);
+				turn_on_backlight();
+				imap_iokey_spken(1);
+			}
+#else
+			printk("double display mode not supported\n");
+			if(VIDEO_MODE == 1|| PANAUISION_MODE == 1 || DOUBLE_DISPLAY_MODE == 1)
+			{
+				VIDEO_MODE = 0;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+				HDMI_Tx_Mute_Enable();
+				HDMI_Tx_Power_Down();
+				lcd_change_timing(LCD, 1);
+				imap_iokey_spken(1);
+				turn_on_backlight();
+			}
+			ret = -1;
+#endif
+			break;
+		case HDMI_SET_PANAUISION_TIMING:
+#ifdef CONFIG_PANAUISION_MODE
+#ifdef CONFIG_UI_MAP_COLOR
+			if(VIDEO_MODE == 1)
+			{
+				__raw_writel(~0x1<<24, IMAP_OVCW0CMR);
+				__raw_writel(~0x1<<24, IMAP_OVCW3CMR);
+			}
+#endif
+			if(PANAUISION_MODE == 0)
+			{
+				turn_off_backlight();
+				imap_iokey_spken(0);
+				HDMI_Tx_Mute_Enable();
+				HDMI_Tx_Power_Down();
+				printk("%s commond :HDMI_PANAUISION_TIMING ",__func__);
+				if(imapfb_fimd.xres == 800){
+					lcd_change_timing(HDMI_1024_768, 1);
+					osd_excursion(HDMI_1024_768);
+					hdmi_main(HDMI_1024_768);
+				}else if(imapfb_fimd.xres == 1024){
+					lcd_change_timing(HDMI_720P, 1);
+					osd_excursion(HDMI_720P);
+					hdmi_main(HDMI_720P);
+				}
+				PANAUISION_MODE = 1;
+				DOUBLE_DISPLAY_MODE = 0;
+				VIDEO_MODE = 0;
+				previous_mode = 2;
+			}
+#else
+			printk("panauision mode not supported\n");
+			if(VIDEO_MODE == 1|| PANAUISION_MODE == 1 || DOUBLE_DISPLAY_MODE == 1)
+			{
+				VIDEO_MODE = 0;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+				HDMI_Tx_Mute_Enable();
+				HDMI_Tx_Power_Down();
+				lcd_change_timing(LCD, 1);
+				imap_iokey_spken(1);
+				turn_on_backlight();
+			}
+			ret = -1;
+#endif
+			break;
+
+		default:
+			printk(KERN_ERR "[HDMI_ioctl]: unknown command type\n");
+			ret = -EFAULT;
+			break;
+	}
+	mutex_unlock(&HDMI_lock);
+	return ret;
+}
+
+#if defined(CONFIG_PM)
+int HDMI_i2c_suspend(struct i2c_client *client, pm_message_t state)
+{
+	printk(KERN_INFO "Suspend EP932\n");
+
+	if(HDMI_HOTPLUG_RESULT == 1 && (( VIDEO_MODE == 1) || (DOUBLE_DISPLAY_MODE == 1) || (PANAUISION_MODE == 1)))
+	{
+		HDMI_Tx_Mute_Enable();
+		HDMI_Tx_Power_Down();
+		lcd_change_timing(LCD, 1);
+		VIDEO_MODE = 0;
+		DOUBLE_DISPLAY_MODE = 0;
+		PANAUISION_MODE = 0;
+		HDMI_HOTPLUG_RESULT = 0;
+	}
+
+	return 0;
+}
+
+int HDMI_i2c_resume(struct i2c_client *client)
+{
+	int ret;
+
+        printk(KERN_INFO "Resume EP932\n");
+
+	EP_EP932M_Reset();
+	HDMI_Tx_Power_Up();
+
+	return 0;
+}		
+#endif
+
+static const struct file_operations HDMI_fops = {
+	.owner                  = THIS_MODULE,
+	.unlocked_ioctl = HDMI_ioctl,
+	.open                   = HDMI_open,
+	.poll		= HDMI_poll,
+	.release                        = HDMI_release,
+};
+
+static const struct file_operations HDMI_poll_fops = {
+	.owner                  = THIS_MODULE,
+	.read		= HDMI_poll_read,
+	.write		= HDMI_poll_write,
+};
+
+static struct i2c_driver HDMI_i2c_driver = {
+	.driver = {
+		.name = "imap_HDMI-i2c",
+		.owner = THIS_MODULE,
+	},
+	.probe = HDMI_i2c_probe,
+	.remove = HDMI_i2c_remove,
+#if defined(CONFIG_PM) 
+	.suspend = HDMI_i2c_suspend,
+	.resume = HDMI_i2c_resume,
+#endif
+	.id_table = HDMI_i2c_id,
+};
+
+static int __init HDMI_probe(struct platform_device *pdev)
+{
+	struct i2c_board_info info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct imap_HDMI_info *HDMI_info;
+	int ret;
+
+#ifdef CONFIG_FAKE_PM
+	if_in_suspend = 0;
+#endif
+
+	printk(KERN_INFO "HDMI Probe to add i2c driver for HDMI device\n");
+
+	HDMI_info =(struct imap_HDMI_info *) kzalloc(sizeof(struct imap_HDMI_info), GFP_KERNEL);
+	if(!HDMI_info)
+	{
+		printk(KERN_ERR "Cannot allocate for HDMI_info\n");
+		return -ENOMEM;
+	}
+
+	ret = register_chrdev(HDMI_MAJOR, "imap-HDMI", &HDMI_fops);
+	if (ret)
+		goto out;
+
+	ret = register_chrdev(HDMI_POLL_MAJOR, "imap-HDMI_poll", &HDMI_poll_fops);
+	if (ret)
+		goto out;
+
+	HDMI_class = class_create(THIS_MODULE, "HDMI_dev");
+	if (IS_ERR(HDMI_class))
+	{
+		printk(KERN_ERR "HDMI_init: fail to create HDMI device class\n");
+		ret = PTR_ERR(HDMI_class);
+		goto out_unreg_chrdev;
+	}
+
+	/* Add i2c_driver */
+	ret = i2c_add_driver(&HDMI_i2c_driver);
+	if(ret)
+	{
+		printk(KERN_ERR "HDMI_init: fail to register i2c driver\n");
+		goto out_unreg_class;
+	}
+
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	info.addr = i2c_device_address;
+	strlcpy(info.type, "imap_HDMI", I2C_NAME_SIZE);
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_EP932_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "HDMI_init: can't get i2c adapter\n");
+		goto err_adapter;
+	}
+
+	HDMI_info->client = i2c_new_device(adapter, &info);
+	i2c_put_adapter(adapter);
+	if (!(HDMI_info->client))
+	{
+		printk(KERN_ERR "HDMI_init: can't add i2c device at 0x%x\n", (unsigned int)info.addr);
+		goto err_adapter;
+	}
+
+	spin_lock_init(&lock);
+	init_completion(&Monitor_Wait);
+	
+	HDMI_info->dev = &(pdev->dev);
+
+	INIT_DELAYED_WORK(&HDMI_info->delayed_work, hp_delayed_work);
+
+	schedule_delayed_work(&HDMI_info->delayed_work,
+	                      msecs_to_jiffies(HDMI_HP_POLL_DELAY));
+
+
+	platform_set_drvdata(pdev, HDMI_info);
+
+	printk(KERN_INFO "HDMI device add i2c driver OK!\n");
+
+	return 0;
+
+err_adapter:
+	i2c_del_driver(&HDMI_i2c_driver);
+out_unreg_class:
+	class_destroy(HDMI_class);
+out_unreg_chrdev:
+	unregister_chrdev(HDMI_MAJOR, "imap-HDMI");
+	unregister_chrdev(HDMI_POLL_MAJOR, "imap-HDMI_poll");
+
+out:
+	printk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);
+
+	return ret;
+}
+
+static int HDMI_remove(struct platform_device *pdev)
+{
+	struct imap_HDMI_info *info = (struct imap_HDMI_info *)platform_get_drvdata(pdev);
+
+	i2c_unregister_device(info->client);
+	i2c_del_driver(&HDMI_i2c_driver);
+	class_destroy(HDMI_class);
+	unregister_chrdev(HDMI_MAJOR, "imap-HDMI");
+	unregister_chrdev(HDMI_POLL_MAJOR, "imap-HDMI_poll");
+
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+int HDMI_suspend(struct platform_device *dev, pm_message_t state)
+{
+	printk(KERN_INFO "Suspend EP932\n");
+	return 0;
+}
+	
+int HDMI_resume(struct platform_device *dev)
+{
+        printk(KERN_INFO "Resume EP932\n");
+	return 0;
+}		
+#endif
+
+
+static struct platform_driver HDMI_driver = {
+	.driver = {
+		.name = "imap-HDMI",
+		.owner = THIS_MODULE,
+	},
+	.probe = HDMI_probe,
+	.suspend = HDMI_suspend,
+	.resume = HDMI_resume,
+	.remove = HDMI_remove,
+};
+
+static int __init HDMI_init(void)
+{
+	return platform_driver_register(&HDMI_driver);
+}
+
+static void __exit HDMI_exit(void)
+{
+	platform_driver_unregister(&HDMI_driver);
+}
+
+module_init(HDMI_init);
+module_exit(HDMI_exit);
+
+MODULE_DESCRIPTION("Infotm HDMI driver");
+MODULE_AUTHOR("Alex Zhang, <alex.zhang@infotmic.com.cn>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/hdmi/ep932/imap_HDMI.h b/drivers/video/hdmi/ep932/imap_HDMI.h
new file mode 100644
index 0000000..3277aba
--- /dev/null
+++ b/drivers/video/hdmi/ep932/imap_HDMI.h
@@ -0,0 +1,264 @@
+/***************************************************************************** 
+ * ** drivers/video/infotm_HDMI/imap_HDMI.h
+ * ** 
+ * ** Copyright (c) 2009~2014 ShangHai Infotm Ltd all rights reserved. 
+ * ** 
+ * ** Use of Infotm's code is governed by terms and conditions 
+ * ** stated in the accompanying licensing statement. 
+ * ** 
+ * ** Description: Head file of Infotm HDMI.
+ * **
+ * ** Author:
+ * **     Alex Zhang <alex.zhang@infotmic.com.cn>
+ * **      
+ * ** Revision History: 
+ * ** ----------------- 
+ * ** 1.0  06/11/2010 Alex Zhang 
+* *****************************************************************************/
+#ifndef __IMAP_HDMI_H__
+#define __IMAP_HDMI_H__
+
+
+//typedef unsigned long UINT32;
+#define UINT32 unsigned long
+typedef unsigned long BOOL; 
+
+typedef struct{
+/*LCDCON1*/
+	UINT32 VCLK;
+	UINT32 EACH_FRAME;
+	UINT32 LCD_PANNEL;
+	UINT32 BPP_MODE;
+	UINT32 LCD_OUTPUT;
+
+/*LCDCON2*/
+	UINT32 VBPD;
+	UINT32 VACTIVE;
+	UINT32 VFPD;
+	UINT32 VSPW;
+
+/*LCDCON3*/	
+	UINT32 VACTIVE_HIGHBIT;
+	UINT32 HBPD;
+	UINT32 HACTIVE;
+	UINT32 HFPD;
+
+/*LCDCON4*/	
+	UINT32 HSPW;
+
+/*LCDCON5*/
+	UINT32 COLOR_MODE;
+	UINT32 BPP24BL;
+	UINT32 FRM565;
+	UINT32 INVVCLK;
+	UINT32 INVVLINE;
+	UINT32 INVVFRAME;
+	UINT32 INVVD;
+	UINT32 INVVDEN;
+	UINT32 INVPWREN;
+	UINT32 INVENDLINE;
+	UINT32 PWREN;
+	UINT32 ENLEND;
+	UINT32 BSWP;
+	UINT32 HWSWP;
+} struct_lcd_timing_param;
+
+typedef struct{
+/*IMAP_TVCCR*/
+	UINT32 Clock_enable;
+	UINT32 TV_PCLK_mode;
+	UINT32 Inv_clock;
+	UINT32 clock_sel;
+       	UINT32 Clock_div;
+
+/*TVICR*/
+	UINT32 tvif_enable;
+	UINT32 ITU601_656n;
+	UINT32 Bit16ofITU60;
+	UINT32 Direct_data;
+	UINT32 Bitswap;
+	UINT32 Data_order;
+	UINT32 Inv_vsync;
+	UINT32 Inv_hsync;
+	UINT32 Inv_href;
+	UINT32 Inv_field;
+	UINT32 Begin_with_EAV;
+
+/*TVCMCR*/
+	UINT32 Matrix_mode;
+	UINT32 Passby;
+	UINT32 Inv_MSB_in;
+	UINT32 Inv_MSB_out;
+	UINT32 Matrix_oft_b;
+	UINT32 Matrix_oft_a;
+
+/*TVUBA1
+ *
+ *VBPD+VSPW
+ *
+ */
+	UINT32 UBA1_LEN;
+
+/*TVUNBA
+ *
+ *vACTIVE
+ *
+ */	
+	UINT32 UNBA_LEN;
+
+/*TVUBA2
+ *
+ *VFPD
+ *
+ */
+	UINT32 UNBA2_LEN;
+
+/*TVLBA1
+ *
+ *VBPD+VSPW
+ *
+ */
+	UINT32 LBA1_LEN;
+
+/*TVLNBA
+ *
+ *VACTIVE
+ *
+ */
+	UINT32 LNBA_LEN;
+
+/*TVLBA2
+ *
+ *VFPD
+ *
+ */
+	UINT32 LBA2_LEN;
+
+/*TVBLEN
+ *
+ *HFPD+HSPW+HBPD-8
+ *
+ */
+	UINT32 BLANK_LEN;
+
+/*TVVLEN
+ *
+ *HACTIVE
+ *
+ */	
+	UINT32 VIDEO_LEN;
+
+/*TVHSCR
+ *
+ *0
+ *HFPD
+ *HSPW
+ *
+ */
+	UINT32 Hsync_VB1_ctrl;
+	UINT32 Hsync_delay;
+	UINT32 Hsync_extend;
+
+/*TVVSHCR
+ *
+ *HFPD
+ *VSPW*HTOTAL-1
+ *
+ */
+	UINT32 Vsync_delay_upper;
+	UINT32 Vsync_extend_upper;
+
+/*TVVSLCR
+ *
+ *HFPD
+ *VSPW*HTOTAL-1
+ */
+	UINT32 Vsync_delay_lower;
+	UINT32 Vsync_extend_lower;
+
+/*TVXSIZE
+ *
+ *HACTIVE-1
+ *
+ */
+	UINT32 DISP_XSIZE;
+
+/*TVYSIZE
+ *
+ *VACTIVE-1
+ *
+ */
+	UINT32 DISP_YSIZE;
+	
+}struct_tvif_timing_param;
+
+typedef struct{
+/*DPLLCFG*/
+	UINT32 DPLLCFG;
+
+/*DIVCFG4*/	
+	UINT32 DIVCFG4;
+} struct_lds_clk_param;
+
+typedef enum
+{
+	LCD = 0,
+	HDMI_1080P,
+//	HDMI_1080I,
+	HDMI_720P,
+	HDMI_480P_16_9,
+	HDMI_480P_4_3,
+//	HDMI_480I_16_9,
+//	HDMI_480I_4_3,
+	HDMI_576P_16_9,
+	HDMI_576P_4_3,
+//	HDMI_576I_16_9,
+//	HDMI_576I_4_3,
+	HDMI_640_480,	
+	HDMI_800_600,	
+	HDMI_1024_768,	
+	HDMI_1080P_TV,
+//	HDMI_1080I,
+	HDMI_720P_TV,
+	HDMI_480P_16_9_TV,
+	HDMI_480P_4_3_TV,
+//	HDMI_480I_16_9,
+//	HDMI_480I_4_3,
+	HDMI_576P_16_9_TV,
+	HDMI_576P_4_3_TV,
+//	HDMI_576I_16_9,
+//	HDMI_576I_4_3,
+	HDMI_640_480_TV,	
+	HDMI_800_600_TV,	
+	HDMI_1024_768_TV,	
+}LCD_TIMING;
+
+/*
+struct imap_HDMI_info {
+	void (* ClearPending)(void);
+	void (* HotplugMonitor)(void);
+	struct tasklet_struct my_tasklet;
+	struct i2c_client *client
+};
+*/
+
+BOOL lcd_change_timing(LCD_TIMING timing, BOOL tv_IF);
+void lcd_config_clk(LCD_TIMING timing);
+void lcd_config_controller(LCD_TIMING timing);
+void tvif_config_controller(LCD_TIMING timing);
+
+#define HDMI_CHECK_HOTPLUG	_IOR('H', 301, UINT32)
+#define HDMI_SET_NOTMAL_TIMING	_IO('H', 302)
+#define HDMI_SET_VIDEO_TIMING	_IOW('H', 303, UINT32)
+#define HDMI_SET_DOUBLE_DISPLAY_TIMING	_IO('H', 311)
+#define HDMI_SET_PANAUISION_TIMING	_IO('H', 312)
+#define HDMI_QUERY_APP		_IO('H', 304)
+#define HDMI_QUERY_RENDER	_IO('H', 305)
+#define HDMI_CHECK_MENUSWITCH	_IOR('H', 306, UINT32)
+#define HDMI_CHECK_MODE		_IOR('H', 307, UINT32)
+#define HDMI_CHECK_CONNECT		_IOR('H', 314, UINT32)
+#define HDMI_SET_MODE		_IOW('H', 313, UINT32)
+#define HDMI_QUERY_MONITOR	_IO('H', 308)
+#define HDMI_TV_SUPPORT_V_MODE  _IOR('H', 310, UINT32)
+
+#endif
diff --git a/drivers/video/hdmi/ep932/imap_HDMI.o b/drivers/video/hdmi/ep932/imap_HDMI.o
new file mode 100644
index 0000000..e813d5f
Binary files /dev/null and b/drivers/video/hdmi/ep932/imap_HDMI.o differ
diff --git a/drivers/video/hdmi/ep932/modules.order b/drivers/video/hdmi/ep932/modules.order
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/video/hdmi/ep932/type.h b/drivers/video/hdmi/ep932/type.h
new file mode 100644
index 0000000..23243ff
--- /dev/null
+++ b/drivers/video/hdmi/ep932/type.h
@@ -0,0 +1,109 @@
+/******************************************************************************\
+
+          (c) Copyright Explore Semiconductor, Inc. Limited 2006
+                           ALL RIGHTS RESERVED 
+
+--------------------------------------------------------------------------------
+
+ Please review the terms of the license agreement before using this file.
+ If you are not an authorized user, please destroy this source code file  
+ and notify Explore Semiconductor Inc. immediately that you inadvertently 
+ received an unauthorized copy.  
+
+--------------------------------------------------------------------------------
+
+  File        :  type.h   
+
+  Description :  Define the C-compiler variable syntax
+                  (modified from Gordon's ICP10 souce code) 
+
+\******************************************************************************/
+
+#ifndef _TYPE_H
+#define _TYPE_H
+
+
+// =============================================================================
+// =============================================================================
+
+typedef unsigned char BYTE;
+//typedef BYTE *PBYTE;
+//typedef unsigned int WORD;
+//typedef unsigned int *PWORD;
+//typedef unsigned long DWORD;
+//typedef DWORD *PDWORD;
+
+//typedef unsigned long ULONG;
+//typedef unsigned long *PULONG;
+//typedef unsigned short USHORT;
+//typedef USHORT *PUSHORT;
+//typedef unsigned char UCHAR;
+//typedef UCHAR *PUCHAR;
+
+
+// =============================================================================
+// =============================================================================
+
+//typedef void (*FVN)(void);
+
+// =============================================================================
+// =============================================================================
+
+//#define FALSE               (0)
+//#define TRUE                (!FALSE)
+//#define OFF                 (0)
+//#define ON                  (!OFF)
+//#define ARRAYSIZE(ary)      (sizeof(ary)/sizeof(ary[0])) 
+
+// =============================================================================
+// =============================================================================
+
+//for big endian 
+//#define LOBYTE(x)           (BYTE)((x)>>8) 
+//#define HIBYTE(x)           (BYTE)((x) & 0x00FF) 
+//#define MKWORD(hi,lo)       (WORD)(((lo)<<8) | hi)                     
+
+// =============================================================================
+// =============================================================================
+
+#define setb0(x)                (x |= 0x01)
+#define setb1(x)                (x |= 0x02)
+#define setb2(x)                (x |= 0x04)
+#define setb3(x)                (x |= 0x08)
+#define setb4(x)                (x |= 0x10)
+#define setb5(x)                (x |= 0x20)
+#define setb6(x)                (x |= 0x40)
+#define setb7(x)                (x |= 0x80)
+
+#define clrb0(x)                (x &= 0xFE)
+#define clrb1(x)                (x &= 0xFD)
+#define clrb2(x)                (x &= 0xFB)
+#define clrb3(x)                (x &= 0xF7)
+#define clrb4(x)                (x &= 0xEF)
+#define clrb5(x)                (x &= 0xDF)
+#define clrb6(x)                (x &= 0xBF)
+#define clrb7(x)                (x &= 0x7F)
+
+#define getb0(x)                (x & 0x01)
+#define getb1(x)                ((x & 0x02)>>1)
+#define getb2(x)                ((x & 0x04)>>2)
+#define getb3(x)                ((x & 0x08)>>3)
+#define getb4(x)                ((x & 0x10)>>4)
+#define getb5(x)                ((x & 0x20)>>5)
+#define getb6(x)                ((x & 0x40)>>6)
+#define getb7(x)                ((x & 0x80)>>7)
+
+
+// =============================================================================
+// =============================================================================
+
+// math
+#ifndef min
+#define min(a,b) (((a)<(b))? (a):(b))
+#endif
+
+#ifndef max
+#define max(a,b) (((a)>(b))? (a):(b))
+#endif
+
+#endif
diff --git a/drivers/video/hdmi/si9022/Externals.h b/drivers/video/hdmi/si9022/Externals.h
new file mode 100755
index 0000000..8702788
--- /dev/null
+++ b/drivers/video/hdmi/si9022/Externals.h
@@ -0,0 +1,42 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+//typedef unsigned int unsigned int;
+
+extern unsigned char CmdTableIndex;                  // Command Table index
+extern unsigned char vid_mode;
+
+// CEC Globals
+//============
+
+extern unsigned int CEC_DeviceList[];              // List of logical addresses and their status (taken/free)
+extern unsigned char CEC_Initiator;                  // Logical address of THIS device
+
+// Patches
+//========
+extern unsigned char EmbeddedSynPATCH;
+
+//UART
+//====
+extern unsigned char TXBusy;
+
+extern unsigned char IDX_InChar;
+extern unsigned char NumOfArgs;
+extern unsigned int F_SBUF_DataReady;
+extern unsigned int F_CollectingData;
+
+
+#ifndef DEBUG_EDID
+extern unsigned int F_IgnoreEDID;                   // Allow setting of any video input format regardless of Sink's EDID (for debuggin puroses)
+#endif
+
+extern unsigned char pvid_mode;
+extern unsigned int dvi_mode;
+
+extern unsigned char g_audio_Checksum;	// Audio checksum
+
diff --git a/drivers/video/hdmi/si9022/Globals.c b/drivers/video/hdmi/si9022/Globals.c
new file mode 100755
index 0000000..1092a26
--- /dev/null
+++ b/drivers/video/hdmi/si9022/Globals.c
@@ -0,0 +1,49 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+#include "SIIdefs.h"
+#include "SIITypeDefs.h"
+#include "SIIConstants.h"
+//#include "AMF_Lib.h"
+
+
+unsigned char CmdTableIndex;                 // Command Table index
+unsigned char vid_mode;
+
+
+// CEC Globals
+//============
+unsigned int CEC_DeviceList[16];                // List of logical addresses and their status (taken/free)
+unsigned char CEC_Initiator;                 // Logical address of THIS device
+
+
+// Patches
+//========
+unsigned char EmbeddedSynPATCH;
+
+
+//UART
+//====
+unsigned char TXBusy;
+
+unsigned char IDX_InChar;
+unsigned char NumOfArgs;
+unsigned int F_SBUF_DataReady;
+unsigned int F_CollectingData;
+
+
+
+#ifndef DEBUG_EDID
+unsigned int F_IgnoreEDID;                  // Allow setting of any video input format regardless of Sink's EDID (for debuggin puroses)
+#endif
+
+unsigned char pvid_mode;
+unsigned int dvi_mode;
+
+// Checksums
+unsigned char g_audio_Checksum;	// Audio checksum
+
diff --git a/drivers/video/hdmi/si9022/Kconfig b/drivers/video/hdmi/si9022/Kconfig
new file mode 100644
index 0000000..8d9972d
--- /dev/null
+++ b/drivers/video/hdmi/si9022/Kconfig
@@ -0,0 +1,11 @@
+#
+## TV/VGA Output configuration
+#
+
+config HDMI_OUTPUT_SUPPORT
+tristate "HDMI Output Support"
+depends on FB
+default n
+---help---
+TBA
+
diff --git a/drivers/video/hdmi/si9022/Makefile b/drivers/video/hdmi/si9022/Makefile
new file mode 100644
index 0000000..9f2b6a0
--- /dev/null
+++ b/drivers/video/hdmi/si9022/Makefile
@@ -0,0 +1,7 @@
+#
+## Makefile for the HDMI output interface driver
+#
+
+obj-y += imap_HDMI.o SIIAV_Config.o SIIEDID.o SIIHDCP.o SIISiI9022A72.o SIITPI_Access.o	 \
+		 SIITPI.o SIIVideoModeTable.o Globals.o
+
diff --git a/drivers/video/hdmi/si9022/SIIAV_Config.c b/drivers/video/hdmi/si9022/SIIAV_Config.c
new file mode 100755
index 0000000..35af6a8
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIAV_Config.c
@@ -0,0 +1,1390 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+
+#include "SIIdefs.h"
+#include "SIITypeDefs.h"
+#include "SIITPI_Regs.h"
+#include "SIIConstants.h"
+#include "SIIMacros.h"
+#include "SIITPI_Access.h"
+#include "SIITPI.h"
+#include "SIIAV_Config.h"
+#include "SIIVideoModeTable.h"
+#include "Externals.h"
+#include "SerialPort.h"
+
+#include "SIIedid.h"
+#include "SIIHDCP.h"
+
+// VSIF Constants
+//===============
+#define VSIF_TYPE  						0x81
+#define VSIF_VERSION					0x01
+#define VSIF_LEN						0x07
+
+//zhy + Begin
+unsigned char AudioI2SConfig = 0xb0;
+
+unsigned char I2SSDSet[4] =
+{
+	0x80,
+	0x11,
+	0x22,
+	0x33
+};
+
+unsigned char I2SStreamHeader[5] =
+{
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x02
+};
+unsigned char VideoMode[9]=
+{
+	0x02,
+	0x60,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x0F
+};
+
+unsigned char AudioMode[6]=
+{
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x20,
+	0x01
+};
+extern bool tmdsPoweredUp;
+void TxPowerState(unsigned char powerState);
+//zhy + End
+
+#ifdef DEV_SUPPORT_EDID
+void Set_VSIF(unsigned char, unsigned char);
+#endif
+
+#ifdef RX_ONBOARD
+extern VideoFormat_t video_information;
+extern AVIInfoFormat_t avi_information;
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  InitVideo()
+//
+// PURPOSE       :  Set the 9022/4 to the video mode determined by GetVideoMode()
+//
+// INPUT PARAMS  :  Index of video mode to set; Flag that distinguishes between
+//                  calling this function after power up and after input
+//                  resolution change
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  VModesTable, VideoCommandImage
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool InitVideo(unsigned char Mode, unsigned char TclkSel, bool Init, unsigned char _3D_Struct)
+{
+	unsigned char V_Mode;
+
+	unsigned char B_Data[8];
+
+#ifdef DEV_EMBEDDED
+	unsigned char EMB_Status;
+#endif
+#ifdef USE_DE_GENERATOR
+	unsigned char DE_Status;
+#endif
+
+#ifndef DEV_INDEXED_PLL
+	unsigned char Pattern;
+#endif
+	TPI_TRACE_PRINT((">>InitVideo()\n"));
+
+	V_Mode = ConvertVIC_To_VM_Index(Mode, _3D_Struct & FOUR_LSBITS);  // convert 861-D VIC into VModesTable[] index.
+
+#ifdef DEV_INDEXED_PLL
+	SetPLL(TclkSel);
+#else
+	Pattern = (TclkSel << 6) & TWO_MSBITS;              // Use TPI 0x08[7:6] for 9022A/24A video clock multiplier
+	ReadSetWriteTPI(TPI_PIX_REPETITION, Pattern);//-------------------------------------------------------------------Configur TPI 0x08 TClkSel bits, other bits set to 0
+#endif
+
+	/* Start configure TPI 0x00~0x07 TPI Video Mode Data, PR Table 5.*/
+	B_Data[0] = VModesTable[V_Mode].PixClk & 0x00FF;             // write Pixel clock to TPI registers 0x00, 0x01
+	B_Data[1] = (VModesTable[V_Mode].PixClk >> 8) & 0xFF;
+
+	B_Data[2] = VModesTable[V_Mode].Tag.VFreq & 0x00FF;          // write Vertical Frequency to TPI registers 0x02, 0x03
+	B_Data[3] = (VModesTable[V_Mode].Tag.VFreq >> 8) & 0xFF;
+
+	B_Data[4] = VModesTable[V_Mode].Tag.Total.Pixels & 0x00FF;   // write total number of pixels to TPI registers 0x04, 0x05
+	B_Data[5] = (VModesTable[V_Mode].Tag.Total.Pixels >> 8) & 0xFF;
+
+	B_Data[6] = VModesTable[V_Mode].Tag.Total.Lines & 0x00FF;    // write total number of lines to TPI registers 0x06, 0x07
+	B_Data[7] = (VModesTable[V_Mode].Tag.Total.Lines >> 8) & 0xFF;
+
+	//Result=TxTPI_WriteBlock(TPI_PIX_CLK_LSB, 8, (unsigned char *)(&W_Data[0]));  // Write TPI Mode data in one burst (8 unsigned chars);
+	WriteBlockTPI(TPI_PIX_CLK_LSB, 8, B_Data);  // Write TPI Mode data in one burst (8 unsigned chars);   ------------------------------//Configur TPI 0x00~0x07, TPI Video Mode Data, PR Table 5.
+	/* End configure TPI 0x00~0x07 TPI Video Mode Data, PR Table 5.*/
+
+	/* Start set Embedded sync data, and enable embedded sync extraction, but not select use embedded sync yet*/
+#ifdef DEV_EMBEDDED
+	EMB_Status = SetEmbeddedSync(Mode);
+	EnableEmbeddedSync();
+#endif
+	/* End set Embedded sync data, and enable embedded sync extraction, but not select use embedded sync yet*/
+
+	/* Start Set DE Generator data */
+#ifdef USE_DE_GENERATOR
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 0 for External Sync
+	DE_Status = SetDE(Mode);                              // Call SetDE() with Video Mode as a parameter
+#endif
+	/* End Set DE Generator data */
+
+
+	/* Start configureTPI 0x09 and 0x0A TPI video input and output format data */
+#ifdef DEV_EMBEDDED
+	B_Data[0] = ((B_Data[0] & 0xFC) | 0x02);
+#endif
+
+	B_Data[1] = (BITS_OUT_RGB | BITS_OUT_AUTO_RANGE) & ~BIT_BT_709;
+
+
+#ifdef DEV_SUPPORT_EDID
+	if (dvi_mode == TRUE)
+	{
+		B_Data[1] = ((B_Data[1] & 0xFC) | 0x03);
+	}
+	else
+	{
+		// Set YCbCr color space depending on EDID
+		if (EDID_Data.YCbCr_4_4_4)
+		{
+			B_Data[1] = ((B_Data[1] & 0xFC) | 0x01);
+		}
+		else
+		{
+			if (EDID_Data.YCbCr_4_2_2)
+			{
+				B_Data[1] = ((B_Data[1] & 0xFC) | 0x02);
+			}
+		}
+	}
+#else
+	B_Data[1] = 0x00;
+#endif
+
+	SetFormat(B_Data);	//Config TPI 0x09 and 0x0A TPI video input and output format data
+	/* End configureTPI 0x09 and 0x0A TPI video input and output format data */
+
+
+	if (Init)
+	{
+
+		/* Start configur for TPI 0x08*/
+		B_Data[0] = (VModesTable[V_Mode].PixRep) & LOW_BYTE;        // Set pixel replication field of 0x08
+		B_Data[0] |= BIT_BUS_24;                                    // Set 24 bit bus
+
+#ifndef DEV_INDEXED_PLL
+		B_Data[0] |= (TclkSel << 6) & TWO_MSBITS;
+#endif
+
+#ifdef CLOCK_EDGE_FALLING
+		B_Data[0] &= ~BIT_EDGE_RISE;                                // Set to falling edge
+#endif
+
+#ifdef CLOCK_EDGE_RISING
+		B_Data[0] |= BIT_EDGE_RISE;                                                                     // Set to rising edge
+#endif
+
+		WriteByteTPI(TPI_PIX_REPETITION, B_Data[0]);       //-------------------------TPI  0x08 input Bus and Pixel Repetition Data
+		/* End configur for TPI 0x08*/
+
+
+#ifdef DEV_EMBEDDED
+		EMB_Status = SetEmbeddedSync(Mode);
+		EnableEmbeddedSync();
+#endif
+
+		/* Start configur for TPI 0x09 and 0x0A*/
+		// default to full range RGB at the input:
+#ifndef USE_DE_GENERATOR
+		B_Data[0] = (((BITS_IN_RGB | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE);  // 0x09
+#else
+		B_Data[0] = (((BITS_IN_YCBCR422 | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE);  // 0x09
+#endif
+
+
+#ifdef DEV_EMBEDDED
+		B_Data[0] = ((B_Data[0] & 0xFC) | 0x02);
+#endif
+		B_Data[1] = (BITS_OUT_RGB | BITS_OUT_AUTO_RANGE) & ~BIT_BT_709;
+
+
+#ifdef DEV_SUPPORT_EDID
+		if (dvi_mode == TRUE)
+		{
+			B_Data[1] = ((B_Data[1] & 0xFC) | 0x03);
+		}
+		else
+		{
+			// Set YCbCr color space depending on EDID
+			if (EDID_Data.YCbCr_4_4_4)
+			{
+				B_Data[1] = ((B_Data[1] & 0xFC) | 0x01);
+			}
+			else
+			{
+				if (EDID_Data.YCbCr_4_2_2)
+				{
+					B_Data[1] = ((B_Data[1] & 0xFC) | 0x02);
+				}
+			}
+		}
+#else
+		B_Data[1] = 0x00;
+#endif
+
+		SetFormat(B_Data);
+		/* End configur for TPI 0x09 and 0x0A*/
+
+
+		ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, BIT_2); // // Number HSync pulses from VSync active edge to Video Data Period should be 20 (VS_TO_VIDEO)
+	}
+
+#ifdef SOURCE_TERMINATION_ON
+	V_Mode = ReadIndexedRegister(INDEXED_PAGE_1, TMDS_CONT_REG);
+	V_Mode = (V_Mode & 0x3F) | 0x25;
+	WriteIndexedRegister(INDEXED_PAGE_1, TMDS_CONT_REG, V_Mode);
+#endif
+
+	return TRUE;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetFormat(unsigned char * Data)
+//
+// PURPOSE      :   
+//
+// INPUT PARAMS :   
+//
+// OUTPUT PARAMS:   
+//
+// GLOBALS USED :   
+//
+// RETURNS      :   
+//
+//////////////////////////////////////////////////////////////////////////////
+void SetFormat(unsigned char *Data)
+{
+	if (dvi_mode)
+	{
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_HDMI); // Set HDMI mode to allow color space conversion
+	}
+
+	WriteBlockTPI(TPI_INPUT_FORMAT_REG, 2, Data);   // Program TPI AVI Input and Output Format
+	WriteByteTPI(TPI_END_RIGHT_BAR_MSB, 0x00);	    // Set last unsigned char of TPI AVI InfoFrame for TPI AVI I/O Format to take effect
+
+	if (dvi_mode == TRUE) 
+	{
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_DVI);
+	}
+
+#ifdef DEV_EMBEDDED
+	EnableEmbeddedSync();							// Last unsigned char of TPI AVI InfoFrame resets Embedded Sync Extraction
+#endif
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetEmbeddedSync(V_Mode)
+//
+// PURPOSE      :   Set the 9022/4 registers to extract embedded sync.
+//
+// INPUT PARAMS :   Index of video mode to set
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   VModesTable[]
+//
+// RETURNS      :   TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool SetEmbeddedSync(unsigned char V_Mode)
+{
+	unsigned int H_Bit_2_H_Sync;
+	unsigned int Field2Offset;
+	unsigned int H_SyncWidth;
+
+	unsigned char V_Bit_2_V_Sync;
+	unsigned char V_SyncWidth;
+	unsigned char B_Data[8];
+
+	TPI_TRACE_PRINT((">>SetEmbeddedSync()\n"));
+
+	ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x01, 0x01);
+
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	 // set 0x60[7] = 0 for DE mode
+	WriteByteTPI(0x63, 0x30);							//modify Vsync, Hsync Poliarity, See PR Table14 note2 for detail. This can only be done after set 0x60[7] to 0 for DE mode
+	ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 1 for Embedded Sync
+
+	V_Mode = ConvertVIC_To_VM_Index(V_Mode, NO_3D_SUPPORT);                // convert 861-D VIC into VModesTable[] index. No 3D with embedded sync
+
+	H_Bit_2_H_Sync = VModesTable[V_Mode]._656.HBit2HSync;
+	Field2Offset = VModesTable[V_Mode]._656.Field2Offset;
+	H_SyncWidth = VModesTable[V_Mode]._656.HLength;
+	V_Bit_2_V_Sync = VModesTable[V_Mode]._656.VBit2VSync;
+	V_SyncWidth = VModesTable[V_Mode]._656.VLength;
+
+	B_Data[0] = H_Bit_2_H_Sync & LOW_BYTE;                  // Setup HBIT_TO_HSYNC 8 LSBits (0x62)
+
+	B_Data[1] = (H_Bit_2_H_Sync >> 8) & TWO_LSBITS;         // HBIT_TO_HSYNC 2 MSBits
+	//B_Data[1] |= BIT_EN_SYNC_EXTRACT;                     // and Enable Embedded Sync to 0x63
+
+	EmbeddedSynPATCH = B_Data[1];				//--------------------------------Store TPI 0x63 value for future use, because when AVI infoframe register TPI 0x19 is written, TPI 0x63[6] Embedded Sync Mode information will be reset to defaule
+	//Place it here correct?? At this moment, 0x63[6]= 0 means use external sync. Embedded is enabled in another function EnableEmbeddedSync(). Maybe shoud move this sentence to EnableEmbeddedSync().
+	B_Data[2] = Field2Offset & LOW_BYTE;                    // 8 LSBits of "Field2 Offset" to 0x64
+	B_Data[3] = (Field2Offset >> 8) & LOW_NIBBLE;           // 2 MSBits of "Field2 Offset" to 0x65
+
+	B_Data[4] = H_SyncWidth & LOW_BYTE;
+	B_Data[5] = (H_SyncWidth >> 8) & TWO_LSBITS;                    // HWIDTH to 0x66, 0x67
+	B_Data[6] = V_Bit_2_V_Sync;                                     // VBIT_TO_VSYNC to 0x68
+	B_Data[7] = V_SyncWidth;                                        // VWIDTH to 0x69
+
+	WriteBlockTPI(TPI_HBIT_TO_HSYNC_7_0, 8, &B_Data[0]);	//---------------------Configur Embedded Sync Extraction Register, PR Table14.
+	return TRUE;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   EnableEmbeddedSync
+//
+// PURPOSE      :
+//
+// INPUT PARAMS :
+//
+// OUTPUT PARAMS:
+//
+// GLOBALS USED :
+//
+// RETURNS      :
+//
+//////////////////////////////////////////////////////////////////////////////
+void EnableEmbeddedSync()
+{
+	TPI_TRACE_PRINT((">>EnableEmbeddedSync()\n"));
+
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	 // set 0x60[7] = 0 for DE mode
+	WriteByteTPI(0x63, 0x30);			//------------------modify Vsync, Hsync Poliarity, See PR Table14 note2 for detail. This can only be done after set 0x60[7] to 0 for DE mode
+	ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 1 for Embedded Sync
+	ReadSetWriteTPI(TPI_DE_CTRL, BIT_6);			//-----------------set 0x63 bit 6 to enable Embedded Sync Extraction, note: Extraction not means use Embedded Syne. 0x60[7] determins use embedded or external sync
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetDE(V_Mode)
+//
+// PURPOSE      :   Set the 9022/4 internal DE generator parameters
+//
+// INPUT PARAMS :   Index of video mode to set
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   DE_SET_OK
+//
+// NOTE         :   0x60[7] must be set to "0" for the follwing settings to
+//                  take effect
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char SetDE(unsigned char V_Mode)
+{
+	unsigned char RegValue;
+
+	unsigned int H_StartPos;
+	unsigned int V_StartPos;
+	unsigned int Htotal;
+	unsigned int Vtotal;
+	unsigned int H_Res;
+	unsigned int V_Res;
+
+	unsigned char Polarity;
+	unsigned char B_Data[12];
+
+	TPI_TRACE_PRINT((">>SetDE()\n"));
+
+	if (VModesTable[V_Mode]._3D_Struct != NO_3D_SUPPORT)
+	{
+		return DE_CANNOT_BE_SET_WITH_3D_MODE;
+		TPI_TRACE_PRINT((">>SetDE() not allowed with 3D video format\n"));
+
+	}
+	// Make sure that External Sync method is set before enableing the DE Generator:
+	RegValue = ReadByteTPI(TPI_SYNC_GEN_CTRL);
+
+	if (RegValue & BIT_7)
+	{
+		return DE_CANNOT_BE_SET_WITH_EMBEDDED_SYNC;
+	}
+
+	V_Mode = ConvertVIC_To_VM_Index(V_Mode, NO_3D_SUPPORT);                // convert 861-D VIC into VModesTable[] index. No 3D with internal DE
+
+	H_StartPos = VModesTable[V_Mode].Pos.H;
+	V_StartPos = VModesTable[V_Mode].Pos.V;
+
+	Htotal = VModesTable[V_Mode].Tag.Total.Pixels;
+	Vtotal = VModesTable[V_Mode].Tag.Total.Lines;
+
+	Polarity = (~VModesTable[V_Mode].Tag.RefrTypeVHPol) & TWO_LSBITS;
+
+	H_Res = VModesTable[V_Mode].Res.H;
+
+	if ((VModesTable[V_Mode].Tag.RefrTypeVHPol & 0x04))
+	{
+		V_Res = (VModesTable[V_Mode].Res.V) >> 1;
+	}
+	else
+	{
+		V_Res = (VModesTable[V_Mode].Res.V);
+	}
+
+	B_Data[0] = H_StartPos & LOW_BYTE;              // 8 LSB of DE DLY in 0x62
+
+	B_Data[1] = (H_StartPos >> 8) & TWO_LSBITS;     // 2 MSBits of DE DLY to 0x63
+	B_Data[1] |= (Polarity << 4);                   // V and H polarity
+	B_Data[1] |= BIT_EN_DE_GEN;                     // enable DE generator
+
+	B_Data[2] = V_StartPos & SEVEN_LSBITS;      // DE_TOP in 0x64
+	B_Data[3] = 0x00;                           // 0x65 is reserved
+	B_Data[4] = H_Res & LOW_BYTE;               // 8 LSBits of DE_CNT in 0x66
+	B_Data[5] = (H_Res >> 8) & LOW_NIBBLE;      // 4 MSBits of DE_CNT in 0x67
+	B_Data[6] = V_Res & LOW_BYTE;               // 8 LSBits of DE_LIN in 0x68
+	B_Data[7] = (V_Res >> 8) & THREE_LSBITS;    // 3 MSBits of DE_LIN in 0x69
+	B_Data[8] = Htotal & LOW_BYTE;				// 8 LSBits of H_RES in 0x6A
+	B_Data[9] =	(Htotal >> 8) & LOW_NIBBLE;		// 4 MSBITS of H_RES in 0x6B
+	B_Data[10] = Vtotal & LOW_BYTE;				// 8 LSBits of V_RES in 0x6C
+	B_Data[11] = (Vtotal >> 8) & BITS_2_1_0;	// 3 MSBITS of V_RES in 0x6D
+
+	WriteBlockTPI(TPI_DE_DLY, 12, &B_Data[0]);	//--------------Configure TPI 0x62 to 0x6D for Explicit Sync DE Generator
+
+	//MessageIndex     EnqueueMessageIndex(DE_SET_OK);                   // For GetStatus()
+	return DE_SET_OK;                               // Write completed successfully
+}
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : SetBasicAudio()
+//
+// PURPOSE       : Set the 9022/4 audio interface to basic audio.
+//
+// INPUT PARAMS  : None
+//
+// OUTPUT PARAMS : None
+//
+// GLOBALS USED  : None
+//
+// RETURNS       : void.
+//
+//////////////////////////////////////////////////////////////////////////////
+void SetBasicAudio(void)
+{
+
+	TPI_TRACE_PRINT((">>SetBasicAudio()\n"));
+
+#ifdef I2S_AUDIO
+	WriteByteTPI(TPI_AUDIO_INTERFACE_REG,  AUD_IF_I2S);                             // 0x26
+	WriteByteTPI(TPI_AUDIO_HANDLING, 0x08 | AUD_DO_NOT_CHECK);          // 0x25
+#else
+	WriteByteTPI(TPI_AUDIO_INTERFACE_REG, AUD_IF_SPDIF);                    // 0x26 = 0x40
+	WriteByteTPI(TPI_AUDIO_HANDLING, AUD_PASS_BASIC);                   // 0x25 = 0x00
+#endif
+
+#ifndef F_9022A_9334
+	SetChannelLayout(TWO_CHANNELS);             // Always 2 channesl in S/PDIF
+#else
+	ReadClearWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] for 9022A/24A and 9334 channel layout
+#endif
+
+#ifdef I2S_AUDIO
+	// I2S - Map channels - replace with call to API MAPI2S
+	WriteByteTPI(TPI_I2S_EN, 0x80); // 0x1F
+	//        WriteByteTPI(TPI_I2S_EN, 0x91);
+	//        WriteByteTPI(TPI_I2S_EN, 0xA2);
+	//        WriteByteTPI(TPI_I2S_EN, 0xB3);
+
+	// I2S - Stream Header Settings - replace with call to API SetI2S_StreamHeader
+	WriteByteTPI(TPI_I2S_CHST_0, 0x00); // 0x21
+	WriteByteTPI(TPI_I2S_CHST_1, 0x00);
+	WriteByteTPI(TPI_I2S_CHST_2, 0x00);
+	WriteByteTPI(TPI_I2S_CHST_3, 0x02);
+	WriteByteTPI(TPI_I2S_CHST_4, 0x02);
+
+	// I2S - Input Configuration - replace with call to API ConfigI2SInput
+	WriteByteTPI(TPI_I2S_IN_CFG, 0x10); // 0x20
+#endif
+
+	WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, TWO_CHANNELS);  // 0x27 = 0x01
+	SetAudioInfoFrames(TWO_CHANNELS, 0x00, 0x00, 0x00, 0x00);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ChangeVideoMode()
+//
+// PURPOSE       :  Changes the 9022/4 video resolution following a command from
+//                  System Control
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters, sent from
+//                  the system controller
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  RxCommand, F_IgnoreEDID
+//
+// RETURNS       :  Success message if video resolution changed successfully.
+//                  Error Code if resolution change failed
+//
+// NOTE         :   Function calls InitVideo() with the 2nd parameter set to
+//                  MODE_CHANGE (==0). That will initialized only the basic
+//                  parameters (Pix. Clk; VFreq; H. # of pixels;...). Other
+//                  parmeters will not be set by InitVideo(), and will be set
+//                  by this function, based on the values passed in the
+//                  API_Cmd typed parameter
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char ChangeVideoMode(API_Cmd Command)
+{
+	unsigned char Result;
+	unsigned char Status;
+
+	TPI_TRACE_PRINT((">>ChangeVideoMode()\n"));
+
+	vid_mode = Command.Arg[0];//zhy 2009 11 24
+#ifdef DEV_SUPPORT_HDCP
+	HDCP_Off();
+#endif
+
+	DisableTMDS();                  // turn off TMDS output
+	DelayMS(T_RES_CHANGE_DELAY);    // allow control InfoFrames to pass through to the sink device.
+
+#if 0
+#ifndef DEBUG_EDID
+	if (!F_IgnoreEDID)
+	{
+		Result = IsVideoModeSupported (vid_mode);
+		if (!Result)
+			return V_MODE_NOT_SUPPORTED;                // Sink does not support this video mode
+	}
+#endif
+#endif
+	// Do not change vid_mode via IForm
+	//vid_mode = Command.Arg[0];
+
+	InitVideo(vid_mode, ((Command.Arg[1] >> 6) & TWO_LSBITS), MODE_CHANGE, Command.Arg[8]);        // Will set values based on VModesTable[Arg[0])
+
+
+	//        WriteByteTPI(TPI_PIX_REPETITION, Command.Arg[1]);  // 0x08
+
+
+	Command.Arg[2] &= ~BITS_5_4;                         // No Deep Color in 9022A/24A, 9022/4
+
+	WriteByteTPI(TPI_INPUT_FORMAT_REG, Command.Arg[2]);    //Write input formats to TPI 0x09     /* // Write output formats to register 0x0A*/
+
+	if ((Command.Arg[3] & TWO_LSBITS) == CS_DVI_RGB)
+	{
+		ReadClearWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPT_MODE_HDMI);        // Set 0x1A[0] to DVI
+		ReadModifyWriteTPI(TPI_OUTPUT_FORMAT_REG, TWO_LSBITS, CS_DVI_RGB);   // Set 0x0A[1:0] to DVI RGB
+	}
+
+	else if (((Command.Arg[3] & TWO_LSBITS) >= CS_HDMI_RGB) && ((Command.Arg[3] & TWO_LSBITS) < CS_DVI_RGB)) // An HDMI CS
+	{
+
+#ifdef DEV_SUPPORT_EDID
+		if (IsHDMI_Sink())                                                  // sink suppurts HDMI
+		{
+			ReadSetWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPT_MODE_HDMI);  // Set 0x1A[0] to HDMI
+
+			//zhy + Begin Out color space selected
+			if (dvi_mode == TRUE)
+			{
+				Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x03);
+			}
+			else
+			{
+				// Set YCbCr color space depending on EDID
+				if (EDID_Data.YCbCr_4_4_4)
+				{
+					Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x01);		//Set Command.Arg[3] output color space YC444
+				}
+				else
+				{
+					if (EDID_Data.YCbCr_4_2_2)
+					{
+						Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x02);	//Set Command.Arg[3] output color space YC422
+					}
+					else
+					{
+						Command.Arg[3] = (Command.Arg[3] & 0xFC) ;		//Set Command.Arg[3] output color space RGB
+					}
+				}
+			}
+			//zhy + End Out color space selected
+		}
+		//zhy+  Begin DVI compliance 	
+		else
+		{
+			ReadClearWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPT_MODE_HDMI);        // Set 0x1A[0] to DVI
+			// ReadClearWriteTPI(TPI_OUTPUT_FORMAT, CS_DVI_RGB);              // Set 0x0A[1:0] to DVI RGB
+			Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x03);
+		}
+		//zhy+  End DVI compliance 	
+
+		// No else?
+#endif
+	}
+
+	WriteByteTPI(TPI_PIX_REPETITION, Command.Arg[1]);  // TIP 0x08
+
+	WriteByteTPI(TPI_OUTPUT_FORMAT_REG, Command.Arg[3]);   // Write input and output formats to registers 0x09, 0x0A
+
+	/* Start configur Embeded Sync and DE generator*/
+	if (Command.Arg[4] & MSBIT)             // set embedded sync
+	{
+		ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT); // set 0x60[7] = 1 for Embedded Sync,select use Embedded sync
+
+		if (Command.Arg[5] & BIT_6)	//Bit6 set means use DE generator-------?????????????????
+		{
+			Result = SetEmbeddedSync(vid_mode);       // Call SetEmbeddedSync() with Video Mode as a parameter
+			if (!Result)
+			{
+				return SET_EMBEDDED_SYC_FAILURE;
+			}
+			EnableEmbeddedSync();
+		}	
+		else
+		{
+			ReadClearWriteTPI(TPI_DE_CTRL, BIT_6);     // clear 0x63[6] = 0 to disable internal DE
+		}	
+	}
+	else                                    // Set external sync
+	{
+		ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 0 for External Sync
+
+		if (Command.Arg[5] & BIT_6)     // set Internal DE Generator only if 0x60[7] == 0
+		{
+			ReadSetWriteTPI(TPI_DE_CTRL, BIT_6);               // set 0x63[6] = 1 for DE
+
+			Status = SetDE(vid_mode);         // Call SetDE() with Video Mode as a parameter
+			if (Status != DE_SET_OK)
+			{
+				return Status;
+			}
+		}
+
+		else if (!(Command.Arg[5] & BIT_6))
+		{
+			ReadClearWriteTPI(TPI_DE_CTRL, BIT_6);     // clear 0x63[6] = 0 to disable internal DE
+		}
+	}
+	/* End configur Embeded Sync and DE generator*/
+
+	TxPowerState(TX_POWER_STATE_D0);//zhy +
+
+#ifdef DEV_SUPPORT_EDID
+	if (IsHDMI_Sink())
+	{
+		SetAVI_InfoFrames(Command);             // InfoFrames - only if output mode is HDMI
+	}
+	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+	// PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!
+	//
+
+	// THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63 and 0x60[5]
+
+	WriteByteTPI(TPI_SYNC_GEN_CTRL, Command.Arg[4]);    // Set 0x60 according to Command.Arg[4]
+	// THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63 and 0x60[5]
+
+	if(Command.Arg[4] & MSBIT)              // THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63
+	{
+		WriteByteTPI(TPI_DE_CTRL, EmbeddedSynPATCH); // (set in function SetEmbeddedSync())TO 0.
+	}
+	//
+	// PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!
+	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#endif
+
+	// Command.Arg[6][3:2] -> 0x0E[7:6] Colorimetry
+	ReadModifyWriteTPI(TPI_AVI_BYTE_2, BITS_7_6, Command.Arg[6] << 4);
+
+	// Command.Arg[6][6:4] -> 0x0F[6:4] Extended Colorimetry
+	if ((Command.Arg[6] & BITS_3_2) == SET_EX_COLORIMETRY)
+	{
+		ReadModifyWriteTPI(TPI_AVI_BYTE_3, BITS_6_5_4, Command.Arg[6]);
+	}
+
+	//==========================================================
+
+
+	// YC Input Mode Select - Command.Arg[7] - offset 0x0B
+	//printf("before set Arg[7] = 0x%x\n", (int)Command.Arg[7]);
+
+	WriteByteTPI(TPI_YC_Input_Mode, Command.Arg[7]);
+	//		tmp = ReadByteTPI(TPI_YC_Input_Mode);
+	//		printf("after set Arg[7] = 0x%x\n", (int)tmp);
+
+	//zhy + Begin
+	// This check needs to be changed to if HDCP is required by the content... once support has been added by RX-side library.
+	if (HDCP_TxSupports == TRUE)
+	{
+		// AV MUTE
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, LINK_INTEGRITY_MODE_MASK | TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK, LINK_INTEGRITY_DYNAMIC | TMDS_OUTPUT_CONTROL_ACTIVE | AV_MUTE_MUTED);
+		tmdsPoweredUp = TRUE;
+	}
+	else
+	{
+		EnableTMDS();
+	}
+	//EnableTMDS();
+	//zhy + End
+
+	return VIDEO_MODE_SET_OK;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetAudioMode()
+//
+// PURPOSE       :  Changes the 9022/4 audio mode as defined by a command from
+//                  the System Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if audio mode set successfully. Error
+//                  Code if failed
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char SetAudioMode(API_Cmd Command)
+{
+	bool Result;
+
+	TPI_TRACE_PRINT((">>SetAudioMode()\n"));
+
+//	Result = IsAudioModeSupported(Command.Arg[0] & LOW_NIBBLE);
+	Result = 1;
+
+	if (!Result)
+	{
+		//MessageIndex         EnqueueMessageIndex(AUD_MODE_NOT_SUPPORTED);
+		return AUD_MODE_NOT_SUPPORTED;
+	}
+	else
+	{
+		SetAudioMute(AUDIO_MUTE_MUTED);
+
+		//  	    ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, HI_NIBBLE, Command.Arg[0]);    // Arg[0][7:4] - 0x26[7:4] - Set audio interface, layout, and mute/unmute
+		WriteByteTPI(TPI_AUDIO_INTERFACE_REG, Command.Arg[0]);
+
+		/// //     	WriteByteTPI(TPI_SPEAKER_CFG, Command.Arg[2]);              // 0x28 - Speaker Configuration - for both S/PDIF and I2S/DSD
+
+		if ((Command.Arg[0] & TWO_MSBITS) == AUD_IF_SPDIF)          // S/PDIF audio interface
+		{
+			ReadModifyWriteTPI(TPI_AUDIO_HANDLING, BITS_1_0, Command.Arg[3]);       // 0x25[1:0] - Audio Handling (S/PDIF only)
+
+			//          WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, Command.Arg[1]);   // 0x27 - Sample Frequency; Sample Size
+			ReadModifyWriteTPI(TPI_AUDIO_SAMPLE_CTRL, BITS_7_6 | BITS_5_4_3, Command.Arg[1]); // Sample Frequency 0x27[5:3]; Sample Size 0x27[7:6]
+
+			ReadClearWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] for 9022A/24A and 9334 channel layout
+		}
+		else                                                        // I2S or DSD Audio interface
+		{
+			WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, Command.Arg[1]);   // 0x27 - HBR; Sample Frequency; Sample Size
+
+			if ((Command.Arg[0] & TWO_MSBITS) == AUD_IF_DSD)     // DSD audio interface
+				ReadSetWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] to set to Layout_1
+			else if ((Command.Arg[0] & TWO_MSBITS) == AUD_IF_I2S) // I2S audio interface
+				ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5, Command.Arg[0]); // Set user's channel layout selection to TPI 0x26[5]
+
+		}
+
+//		SetAudioMute(AUDIO_MUTE_NORMAL);
+
+		SetAudioInfoFrames(Command.Arg[5] & THREE_LSBITS, Command.Arg[0] & FOUR_LSBITS, Command.Arg[1] & BITS_7_6, Command.Arg[1] & BITS_5_4_3, Command.Arg[2]); //channel count, spk config,coding type, sample size, sample freq.	
+
+//		ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_4, Command.Arg[0]);		// Set audio mute/unmute bit.
+
+		return AUDIO_MODE_SET_OK;
+	}
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  MapI2S()
+//
+// PURPOSE       :  Changes the 9022/4 I2S channel mapping as defined by a
+//                  command sent from the System Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if channel mapping successful. Error
+//                  Code if failed
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char MapI2S(API_Cmd Command)
+{
+	unsigned char B_Data;
+	int i;
+	// unsigned char temp;
+
+	TPI_TRACE_PRINT((">>MapI2S()\n"));
+
+	B_Data = ReadByteTPI(TPI_AUDIO_INTERFACE_REG);
+
+	if ((B_Data & TWO_MSBITS) != AUD_IF_I2S)    // 0x26 not set to I2S interface
+	{
+		return I2S_NOT_SET;
+	}
+
+	//      WriteByteTPI(TPI_I2S_EN, Command.Arg[0]);
+
+	//      printf("I2sMapping:\n");
+
+	for (i = 0; i < I2S_MAPPING_CMD_LEN; i++)
+	{
+		WriteByteTPI(TPI_I2S_EN, Command.Arg[i]);
+
+		//			temp = ReadByteTPI(TPI_I2S_EN);
+		//         	printf("    FIFO#%d = 0x%2X\n", i, (int)temp);
+
+		if ((Command.Arg[i+1] & BITS_1_0) == 0)
+			return 0;
+	}
+	return I2S_MAPPING_SUCCESSFUL;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ConfigI2SInput()
+//
+// PURPOSE       :  Sets the 9022/4 I2S channel bit direction, justification
+//                  and polarity as defined by acommand sent from the System
+//                  Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if video I2S channels configuredsuccessfully.
+//                  Error Code if setting failed
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char ConfigI2SInput(API_Cmd Command)
+{
+	unsigned char B_Data;
+
+	TPI_TRACE_PRINT((">>ConfigI2SInput()\n"));
+
+	B_Data = ReadByteTPI(TPI_AUDIO_INTERFACE_REG);
+
+	if ((B_Data & TWO_MSBITS) != AUD_IF_I2S)    // 0x26 not set to I2S interface
+	{
+		return I2S_NOT_SET;
+	}
+
+	WriteByteTPI(TPI_I2S_IN_CFG, Command.Arg[0]);
+
+	return I2S_INPUT_CONFIG_SUCCESSFUL;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetI2S_StreamHeader()
+//
+// PURPOSE       :  Sets the 9022/4 I2S Channel Status unsigned chars, as defined by
+//                  a command sent from the System Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if stream header set successfully. Error
+//                  Code if failed
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char SetI2S_StreamHeader(API_Cmd Command)
+{
+	unsigned char B_Data;
+	int i;
+
+	TPI_TRACE_PRINT((">>SetI2S_StreamHeader()\n"));
+
+	B_Data = ReadByteTPI(TPI_AUDIO_INTERFACE_REG);
+
+	if ((B_Data & TWO_MSBITS) != AUD_IF_I2S)    // 0x26 not set to I2S interface
+	{
+		return I2S_NOT_SET;
+	}
+
+	for (i = 0; i < Command.CommandLength; i++)
+	{
+		WriteByteTPI(TPI_I2S_CHST_0 + i, Command.Arg[i]);
+	}
+
+	return I2S_HEADER_SET_SUCCESSFUL;
+}
+
+
+#ifdef F_9022A_9334
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetGBD_InfoFrame(()
+//
+// PURPOSE      :   Sets and sends the the 9022A/4A GBD InfoFrames according
+//                  to data sent from the System Controller
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   Success message if GBD packet set successfully. Error
+//                  Code if failed
+//
+// NOTE         :   Currently this function is a place holder. It always
+//                  returns a Success message
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char SetGBD_InfoFrame()
+{
+	unsigned char CheckSum;
+
+	TPI_TRACE_PRINT((">>SetGBD_InfoFrame()\n"));
+
+	// Set MPEG InfoFrame Header to GBD InfoFrame Header values:
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, MPEG_INFOFRAME_CODE);                       // 0xBF = Use MPEG      InfoFrame for GBD - 0x03
+	WriteByteTPI(MISC_INFO_FRAMES_TYPE, TYPE_GBD_INFOFRAME);                        // 0xC0 = 0x0A
+	WriteByteTPI(MISC_INFO_FRAMES_VER, NEXT_FIELD | GBD_PROFILE | AFFECTED_GAMUT_SEQ_NUM);   // 0x0C1 = 0x81
+	WriteByteTPI(MISC_INFO_FRAMES_LEN, ONLY_PACKET | CURRENT_GAMUT_SEQ_NUM);                                // 0x0C2 = 0x31
+
+	CheckSum = TYPE_GBD_INFOFRAME +
+		NEXT_FIELD +
+		GBD_PROFILE +
+		AFFECTED_GAMUT_SEQ_NUM +
+		ONLY_PACKET +
+		CURRENT_GAMUT_SEQ_NUM;
+
+	CheckSum = 0x100 - CheckSum;
+
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_MPEG);  // Enable and Repeat MPEG InfoFrames
+	WriteByteTPI(MISC_INFO_FRAMES_CHKSUM, CheckSum);                        // 0X00 - Send header only
+
+	return GBD_SET_SUCCESSFULLY;
+}
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  IsVideoModeSupported()
+//
+// PURPOSE       :  Checks if the video mode passed as parameter is supported
+//                  by the connected sink (as read from its EDID).
+//
+// INPUT PARAMS  :  Video mode number
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE if mode is supported by the sink. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+bool IsVideoModeSupported(unsigned char V_Mode)
+{
+#ifdef DEV_SUPPORT_EDID
+	int i;
+
+	TPI_TRACE_PRINT((">>IsVideoModeSupported()\n"));
+
+	for (i = 0; i < MAX_V_DESCRIPTORS; i++)
+	{
+		if ((EDID_Data.VideoDescriptor[i] & SEVEN_LSBITS) == V_Mode)
+			return TRUE;
+	}
+	return FALSE;
+#else
+	V_Mode = V_Mode;        // dummy usage of parameter to avoid compiler warning
+	TPI_TRACE_PRINT((">>IsVideoModeSupported()\n"));
+	return TRUE;            // Just return true for now... what other mechanism should be used to determine support?
+#endif
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  IsAudioModeSupported()
+//
+// PURPOSE       :  Checks if the audio mode passed as parameter is supported
+//                  by the connected sink (as read from its EDID).
+//
+// INPUT PARAMS  :  Video mode number
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE if mode is supporter by the sink. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char IsAudioModeSupported(unsigned char A_Mode)
+{
+#ifdef DEV_SUPPORT_EDID
+	int i;
+
+	TPI_TRACE_PRINT((">>IsAudioModeSupported()\n"));
+
+	for (i = 0; i < MAX_A_DESCRIPTORS; i++)
+	{
+		if ((((EDID_Data.AudioDescriptor[i][0]) & SEVEN_LSBITS) >> 3) == A_Mode)
+			return TRUE;
+	}
+	return FALSE;
+#else
+	A_Mode = A_Mode;        // dummy usage of parameter to avoid compiler warning
+	TPI_TRACE_PRINT((">>IsAudioModeSupported()\n"));
+	return TRUE;            // Just return true for now... what other mechanism should be used to determine support?
+#endif
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetAVI_InfoFrames()
+//
+// PURPOSE       :  Load AVI InfoFrame data into registers and send to sink
+//
+// INPUT PARAMS  :  An API_Cmd parameter that holds the data to be sent
+//                  in the InfoFrames
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool SetAVI_InfoFrames(API_Cmd Command)
+{
+	unsigned char B_Data[SIZE_AVI_INFOFRAME];
+	unsigned char VideoMode;                     // pointer to VModesTable[]
+	unsigned char i;
+	unsigned char TmpVal;
+
+	TPI_TRACE_PRINT((">>SetAVI_InfoFrames()\n"));
+
+	for (i = 0; i < SIZE_AVI_INFOFRAME; i++)
+		B_Data[i] = 0;
+
+	//zhy - Begin
+	//if (Command.CommandLength > VIDEO_SETUP_CMD_LEN)    // Command length > 9. AVI InfoFrame is set by the host
+	//{
+	//     for (i = 1; i < Command.CommandLength - VIDEO_SETUP_CMD_LEN; i++)
+	//         B_Data[i] = Command.Arg[VIDEO_SETUP_CMD_LEN + i - 1];
+	//}
+	//else                                                // Command length == 7. AVI InfoFrame is set by the FW
+	//zhy - End
+	{
+		if ((Command.Arg[3] & TWO_LSBITS) == 1)         // AVI InfoFrame DByte1
+			TmpVal = 2;
+		else if ((Command.Arg[3] & TWO_LSBITS) == 2)
+			TmpVal = 1;
+		else
+			TmpVal = 0;
+
+		B_Data[1] = (TmpVal << 5) & BITS_OUT_FORMAT;                    // AVI Byte1: Y1Y0 (output color indictor RGB/YC422/YC444)
+
+		if (((Command.Arg[6] >> 2) & TWO_LSBITS) == 3)                  // Extended colorimetry - xvYCC
+		{
+			B_Data[2] = 0xC0;                                           // Extended colorimetry info (B_Data[3] valid (CEA-861D, Table 11)
+
+			if (((Command.Arg[6] >> 4) & THREE_LSBITS) == 0)            // xvYCC601
+				B_Data[3] &= ~BITS_6_5_4;
+
+			else if (((Command.Arg[6] >> 4) & THREE_LSBITS) == 1)       // xvYCC709
+				B_Data[3] = (B_Data[3] & ~BITS_6_5_4) | BIT_4;
+		}
+
+		else if (((Command.Arg[6] >> 2) & TWO_LSBITS) == 2)             // BT.709
+			B_Data[2] = 0x80;                                           // AVI Byte2: C1C0
+
+		else if (((Command.Arg[6] >> 2) & TWO_LSBITS) == 1)             // BT.601
+			B_Data[2] = 0x40;                                           // AVI Byte2: C1C0
+
+		else															// Carries no data
+		{																// AVI Byte2: C1C0
+			B_Data[2] &= ~BITS_7_6;										// colorimetry = 0
+			B_Data[3] &= ~BITS_6_5_4;									// Extended colorimetry = 0
+		}
+
+		VideoMode = ConvertVIC_To_VM_Index(vid_mode, Command.Arg[8] & LOW_NIBBLE);              /// //
+
+		B_Data[4] = vid_mode;
+
+#ifdef RX_ONBOARD
+		if ((avi_information.unsigned char_2 & PICTURE_ASPECT_RATIO_MASK) == PICTURE_ASPECT_RATIO_16x9)
+		{
+			B_Data[2] |= _16_To_9;                          // AVI Byte2: M1M0
+			if (VModesTable[VideoMode].AspectRatio == _4or16 && AspectRatioTable[vid_mode-1] == _4)
+			{
+				vid_mode++;
+				B_Data[4]++;
+			}
+		}
+		else
+		{
+			B_Data[2] |= _4_To_3;                           // AVI Byte4: VIC
+		}
+#else
+		B_Data[2] |= _4_To_3;                           // AVI Byte4: VIC
+#endif
+
+		B_Data[2] |= SAME_AS_AR;                                        // AVI Byte2: R3..R1
+		B_Data[5] = VModesTable[VideoMode].PixRep;                      // AVI Byte5: Pixel Replication - PR3..PR0
+	}
+
+	B_Data[0] = 0x82 + 0x02 +0x0D;                                          // AVI InfoFrame ChecKsum
+
+	for (i = 1; i < SIZE_AVI_INFOFRAME; i++)
+		B_Data[0] += B_Data[i];
+
+	B_Data[0] = 0x100 - B_Data[0];
+
+	WriteBlockTPI(TPI_AVI_BYTE_0, SIZE_AVI_INFOFRAME, B_Data);
+#ifdef DEV_EMBEDDED
+	EnableEmbeddedSync();
+#endif
+
+	return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetAudioInfoFrames()
+//
+// PURPOSE       :  Load Audio InfoFrame data into registers and send to sink
+//
+// INPUT PARAMS  :  (1) Channel count (2) speaker configuration per CEA-861D
+//                  Tables 19, 20 (3) Coding type: 0x09 for DSD Audio. 0 (refer
+//                                      to stream header) for all the rest (4) Sample Frequency. Non
+//                                      zero for HBR only (5) Audio Sample Length. Non zero for HBR
+//                                      only.
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool SetAudioInfoFrames(unsigned char ChannelCount, unsigned char CodingType, unsigned char SS, unsigned char Fs, unsigned char SpeakerConfig)
+{
+	unsigned char B_Data[SIZE_AUDIO_INFOFRAME];  // 14
+	unsigned char i;
+	unsigned char TmpVal = 0;
+
+	TPI_TRACE_PRINT((">>SetAudioInfoFrames()\n"));
+
+	for (i = 0; i < SIZE_AUDIO_INFOFRAME +1; i++)
+		B_Data[i] = 0;
+
+	B_Data[0] = EN_AUDIO_INFOFRAMES;        // 0xC2
+	B_Data[1] = TYPE_AUDIO_INFOFRAMES;      // 0x84
+	B_Data[2] = AUDIO_INFOFRAMES_VERSION;   // 0x01
+	B_Data[3] = AUDIO_INFOFRAMES_LENGTH;    // 0x0A
+
+	B_Data[5] = ChannelCount;               // 0 for "Refer to Stream Header" or for 2 Channels. 0x07 for 8 Channels
+	B_Data[5] |= (CodingType << 4);                 // 0xC7[7:4] == 0b1001 for DSD Audio
+	B_Data[4] = 0x84 + 0x01 + 0x0A;         // Calculate checksum
+
+	//    B_Data[6] = (Fs << 2) | SS;
+	B_Data[6] = (Fs >> 1) | (SS >> 6);
+
+	//write Fs to 0x27[5:3] and SS to 0x27[7:6] to update the IForm with the current value.
+	//	ReadModifyWriteTPI(TPI_AUDIO_SAMPLE_CTRL, BITS_7_6 | BITS_5_4_3, (B_Data[6] & BITS_1_0) << 6 | (B_Data[6] & 0x1C) << 1);
+
+	B_Data[8] = SpeakerConfig;
+
+	for (i = 5; i < SIZE_AUDIO_INFOFRAME; i++)
+		B_Data[4] += B_Data[i];
+
+	B_Data[4] = 0x100 - B_Data[4];
+	g_audio_Checksum = B_Data[4];	// Audio checksum for global use
+
+	WriteBlockTPI(TPI_AUDIO_BYTE_0, SIZE_AUDIO_INFOFRAME, B_Data);
+#ifdef DEV_EMBEDDED
+	EnableEmbeddedSync();
+#endif
+	return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  Set_VSIF(()
+//
+// PURPOSE       :  Construct Vendor Specific InfoFrame for3D support. use
+//                                      MPEG InfoFrame
+//
+// INPUT PARAMS  :  (1) 3D_Structure value per HDMI 1.4, table H-2.
+//                                      (2) 3D_Ext_Data value per HDMI 1.4, table H-6.
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  void
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef DEV_SUPPORT_EDID
+void Set_VSIF(unsigned char _3D_Struct, unsigned char _3D_Ext_Data)
+{
+	unsigned char i;
+	unsigned char Data[16];
+
+	Data[0] = VSIF_TYPE;                // 0x81
+	Data[1] = VSIF_VERSION;             // 0x01
+	Data[2] = VSIF_LEN;                 // 5
+
+	Data[3] = VSIF_TYPE+                // partial checksum
+		VSIF_VERSION+
+		VSIF_LEN;
+
+	Data[4] = 0x03;                     // HDMI Signature LS Byte
+	Data[5] = 0x0C;                     // HDMI Signature middle unsigned char
+	Data[6] = 0x00;                     // HDMI Signature MS Byte
+
+	Data[7] = _3D_STRUC_PRESENT << 5;   // 3D format indication present. 3D_Structure follows.
+	Data[8] = _3D_Struct << 4;   // 3D format indication present. 3D_Structure follows.
+
+	if (_3D_Struct == SIDE_BY_SIDE_HALF)
+		Data[9] = _3D_Ext_Data << 4;       // 3D_Structure - 0x00 for Frame Packing
+
+	for (i = 4; i < 10; i++)
+		Data[3] += Data[i];
+
+	Data[3] %= 0x100;
+	Data[3] = 100 - Data[3];            // Final checksum
+
+	WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_MPEG);                           // Enable and Repeat MPEG InfoFrames
+	WriteBlockTPI(MISC_INFO_FRAMES_TYPE, 10, Data );               // Write VSIF to MPEG registers and start transmission
+}
+#endif
+
+//zhy + for Audio/video Change Begin
+void SetI2S(void)
+{
+	API_Cmd Command;
+
+	Command.Arg[0] = AudioI2SConfig;
+	ConfigI2SInput(Command);
+	Command.Arg[0] = I2SSDSet[0];
+	Command.Arg[1] = I2SSDSet[1];
+	Command.Arg[2] = I2SSDSet[2];
+	Command.Arg[3] = I2SSDSet[3];
+	MapI2S(Command);
+	Command.Arg[0] = I2SStreamHeader[0];
+	Command.Arg[1] = I2SStreamHeader[1];
+	Command.Arg[2] = I2SStreamHeader[2];
+	Command.Arg[3] = I2SStreamHeader[3];
+	Command.Arg[4] = I2SStreamHeader[4];
+	Command.CommandLength = 5;
+	SetI2S_StreamHeader(Command);
+}
+
+void VideoModeSetbymain(void)
+{
+	API_Cmd Command;
+
+
+	Command.Arg[0] = VideoMode[0];
+	Command.Arg[1] = VideoMode[1];
+	Command.Arg[2] = VideoMode[2];
+	Command.Arg[3] = VideoMode[3];
+	Command.Arg[4] = VideoMode[4];
+	Command.Arg[5] = VideoMode[5];
+	Command.Arg[6] = VideoMode[6];
+	Command.Arg[7] = VideoMode[7];
+	Command.Arg[8] = VideoMode[8];
+	ChangeVideoMode(Command);
+}
+
+void AudioModeSetbymain(void)
+{
+	API_Cmd Command;
+
+	Command.Arg[0] = AudioMode[0];
+	Command.Arg[1] = AudioMode[1];
+	Command.Arg[2] = AudioMode[2];
+	Command.Arg[3] = AudioMode[3];
+	Command.Arg[4] = AudioMode[4];
+	Command.Arg[5] = AudioMode[5];
+
+	SetAudioMode(Command);
+
+	if((AudioMode[0]>>6)==2)
+	{
+		SetI2S();
+		Command.Arg[0] = AudioMode[0];
+		Command.Arg[1] = AudioMode[1];
+		Command.Arg[2] = AudioMode[2];
+		Command.Arg[3] = AudioMode[3];
+		Command.Arg[4] = AudioMode[4];
+		Command.Arg[5] = AudioMode[5];
+		SetAudioInfoFrames(Command.Arg[5] & THREE_LSBITS, Command.Arg[0] & FOUR_LSBITS, Command.Arg[1] & BITS_7_6, Command.Arg[1] & BITS_5_4_3, Command.Arg[2]); //channel count, spk config,coding type, sample size, sample freq.	
+		ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_4, Command.Arg[0]);		// Set audio mute/unmute bit.
+
+	}
+
+}
+//zhy + for Audio/video Change Begin
+
diff --git a/drivers/video/hdmi/si9022/SIIAV_Config.h b/drivers/video/hdmi/si9022/SIIAV_Config.h
new file mode 100755
index 0000000..54814f4
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIAV_Config.h
@@ -0,0 +1,65 @@
+///***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+enum AV_ConfigErrorCodes {
+        DE_CANNOT_BE_SET_WITH_EMBEDDED_SYNC,
+        V_MODE_NOT_SUPPORTED,
+        SET_EMBEDDED_SYC_FAILURE,
+        I2S_MAPPING_SUCCESSFUL,
+        I2S_INPUT_CONFIG_SUCCESSFUL,
+        I2S_HEADER_SET_SUCCESSFUL,
+		EHDMI_ARC_SINGLE_SET_SUCCESSFUL,
+		EHDMI_ARC_COMMON_SET_SUCCESSFUL,
+		EHDMI_HEC_SET_SUCCESSFUL,
+		EHDMI_ARC_CM_WITH_HEC_SET_SUCCESSFUL,
+        AUD_MODE_NOT_SUPPORTED,
+        I2S_NOT_SET,
+        DE_SET_OK,
+        VIDEO_MODE_SET_OK,
+        AUDIO_MODE_SET_OK,
+        GBD_SET_SUCCESSFULLY,
+        DE_CANNOT_BE_SET_WITH_3D_MODE,
+        };
+
+// Time Constants Used in AV_Config.c only
+//========================================
+#define T_RES_CHANGE_DELAY      128         // delay between turning TMDS bus off and changing output resolution
+
+// Deep Color Constants
+//=====================
+#define DC_48                                   3
+
+// Prototype Declarations
+//=======================
+void SetBasicAudio(void);
+bool InitVideo(unsigned char, unsigned char, bool, unsigned char);
+void SetFormat(unsigned char *Data);
+bool SetEmbeddedSync(unsigned char);
+void EnableEmbeddedSync(void);
+unsigned char SetDE(unsigned char);
+
+unsigned char ChangeVideoMode(API_Cmd);
+unsigned char MapI2S(API_Cmd);
+unsigned char ConfigI2SInput(API_Cmd);
+unsigned char SetAudioMode(API_Cmd);
+
+unsigned char SetI2S_StreamHeader(API_Cmd);
+unsigned char SetEHDMI_ARC_sm(API_Cmd);
+unsigned char SetEHDMI_ARC_cm(API_Cmd);
+unsigned char SetEHDMI_HEC(API_Cmd);
+unsigned char SetEHDMI_ARCcm_with_HEC(API_Cmd);
+
+bool IsVideoModeSupported(unsigned char);
+unsigned char IsAudioModeSupported(unsigned char);
+bool SetAVI_InfoFrames(API_Cmd);
+bool SetAudioInfoFrames(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char);
+
+#ifdef F_9022A_9334
+unsigned char SetGBD_InfoFrame();
+#endif
+
diff --git a/drivers/video/hdmi/si9022/SIIAV_Config_bak.c b/drivers/video/hdmi/si9022/SIIAV_Config_bak.c
new file mode 100755
index 0000000..74de7cd
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIAV_Config_bak.c
@@ -0,0 +1,1386 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+
+#include <stdio.h>
+
+#include "MCU_Regs.h"
+#include "SIIdefs.h"
+#include "SIItypedefs.h"
+#include "AMF_Lib.h"
+#include "SIITPI_REGS.h"
+#include "SIIConstants.h"
+#include "Externals.h"
+#include "SIIMacros.h"
+#include "SIITPI_Access.h"
+#include "SIITPI.h"
+#include "Util.h"
+#include "SIIAV_Config.h"
+#include "i2c_master_sw.h"
+#include "SIIVideoModeTable.h"
+#include "SerialPort.h"
+
+#include "SIIedid.h"
+#include "SIIHDCP.h"
+
+// VSIF Constants
+//===============
+#define VSIF_TYPE  						0x81
+#define VSIF_VERSION					0x01
+#define VSIF_LEN						0x07
+
+//zhy + Begin
+byte AudioI2SConfig = 0x10;
+
+byte I2SSDSet[4] =
+{
+0x80,
+0x91,
+0xA2,
+0xB3
+};
+
+byte I2SStreamHeader[5] =
+{
+0x00,
+0x00,
+0x00,
+0x02,
+0x02
+};
+byte VideoMode[9]=
+{
+	0x02,
+	0x60,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x0F
+};
+
+byte AudioMode[6]=
+{
+	
+	0x80,
+	0x00,
+	0x00,
+	0x00,
+	0x20,
+	0x01
+};
+extern bool tmdsPoweredUp;
+void TxPowerState(byte powerState);
+//zhy + End
+
+#ifdef DEV_SUPPORT_EDID
+void Set_VSIF(byte, byte);
+#endif
+
+#ifdef RX_ONBOARD
+extern VideoFormat_t video_information;
+extern AVIInfoFormat_t avi_information;
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  InitVideo()
+//
+// PURPOSE       :  Set the 9022/4 to the video mode determined by GetVideoMode()
+//
+// INPUT PARAMS  :  Index of video mode to set; Flag that distinguishes between
+//                  calling this function after power up and after input
+//                  resolution change
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  VModesTable, VideoCommandImage
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool InitVideo(byte Mode, byte TclkSel, bool Init, byte _3D_Struct)
+{
+    byte V_Mode;
+
+    byte B_Data[8];
+
+#ifdef DEV_EMBEDDED
+	byte EMB_Status;
+#endif
+#ifdef USE_DE_GENERATOR
+    byte DE_Status;
+#endif
+
+#ifndef DEV_INDEXED_PLL
+    byte Pattern;
+#endif
+        TPI_TRACE_PRINT((">>InitVideo()\n"));
+
+        V_Mode = ConvertVIC_To_VM_Index(Mode, _3D_Struct & FOUR_LSBITS);  // convert 861-D VIC into VModesTable[] index.
+
+#ifdef DEV_INDEXED_PLL
+    SetPLL(TclkSel);
+#else
+    Pattern = (TclkSel << 6) & TWO_MSBITS;              // Use TPI 0x08[7:6] for 9022A/24A video clock multiplier
+    ReadSetWriteTPI(TPI_PIX_REPETITION, Pattern);//-------------------------------------------------------------------Configur TPI 0x08 TClkSel bits, other bits set to 0
+#endif
+
+/* Start configure TPI 0x00~0x07 TPI Video Mode Data, PR Table 5.*/
+    B_Data[0] = VModesTable[V_Mode].PixClk & 0x00FF;             // write Pixel clock to TPI registers 0x00, 0x01
+    B_Data[1] = (VModesTable[V_Mode].PixClk >> 8) & 0xFF;
+
+    B_Data[2] = VModesTable[V_Mode].Tag.VFreq & 0x00FF;          // write Vertical Frequency to TPI registers 0x02, 0x03
+    B_Data[3] = (VModesTable[V_Mode].Tag.VFreq >> 8) & 0xFF;
+
+    B_Data[4] = VModesTable[V_Mode].Tag.Total.Pixels & 0x00FF;   // write total number of pixels to TPI registers 0x04, 0x05
+    B_Data[5] = (VModesTable[V_Mode].Tag.Total.Pixels >> 8) & 0xFF;
+
+    B_Data[6] = VModesTable[V_Mode].Tag.Total.Lines & 0x00FF;    // write total number of lines to TPI registers 0x06, 0x07
+    B_Data[7] = (VModesTable[V_Mode].Tag.Total.Lines >> 8) & 0xFF;
+
+    //Result=TxTPI_WriteBlock(TPI_PIX_CLK_LSB, 8, (byte *)(&W_Data[0]));  // Write TPI Mode data in one burst (8 bytes);
+    WriteBlockTPI(TPI_PIX_CLK_LSB, 8, B_Data);  // Write TPI Mode data in one burst (8 bytes);   ------------------------------//Configur TPI 0x00~0x07, TPI Video Mode Data, PR Table 5.
+/* End configure TPI 0x00~0x07 TPI Video Mode Data, PR Table 5.*/
+
+/* Start set Embedded sync data, and enable embedded sync extraction, but not select use embedded sync yet*/
+#ifdef DEV_EMBEDDED
+	EMB_Status = SetEmbeddedSync(Mode);
+	EnableEmbeddedSync();
+#endif
+/* End set Embedded sync data, and enable embedded sync extraction, but not select use embedded sync yet*/
+
+/* Start Set DE Generator data */
+#ifdef USE_DE_GENERATOR
+    ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 0 for External Sync
+    DE_Status = SetDE(Mode);                              // Call SetDE() with Video Mode as a parameter
+#endif
+/* End Set DE Generator data */
+
+
+/* Start configureTPI 0x09 and 0x0A TPI video input and output format data */
+#ifdef DEV_EMBEDDED
+ 		B_Data[0] = ((B_Data[0] & 0xFC) | 0x02);
+#endif
+
+   		B_Data[1] = (BITS_OUT_RGB | BITS_OUT_AUTO_RANGE) & ~BIT_BT_709;
+
+
+#ifdef DEV_SUPPORT_EDID
+		if (dvi_mode == TRUE)
+		{
+	        B_Data[1] = ((B_Data[1] & 0xFC) | 0x03);
+		}
+		else
+		{
+	        // Set YCbCr color space depending on EDID
+	        if (EDID_Data.YCbCr_4_4_4)
+	        {
+	                B_Data[1] = ((B_Data[1] & 0xFC) | 0x01);
+	        }
+	        else
+	        {
+	                if (EDID_Data.YCbCr_4_2_2)
+	                {
+	                        B_Data[1] = ((B_Data[1] & 0xFC) | 0x02);
+	                }
+	        }
+		}
+#else
+        B_Data[1] = 0x00;
+#endif
+
+		SetFormat(B_Data);	//Config TPI 0x09 and 0x0A TPI video input and output format data
+/* End configureTPI 0x09 and 0x0A TPI video input and output format data */
+
+
+    if (Init)
+    {
+
+	/* Start configur for TPI 0x08*/
+        B_Data[0] = (VModesTable[V_Mode].PixRep) & LOW_BYTE;        // Set pixel replication field of 0x08
+        B_Data[0] |= BIT_BUS_24;                                    // Set 24 bit bus
+
+        #ifndef DEV_INDEXED_PLL
+        B_Data[0] |= (TclkSel << 6) & TWO_MSBITS;
+        #endif
+
+#ifdef CLOCK_EDGE_FALLING
+        B_Data[0] &= ~BIT_EDGE_RISE;                                // Set to falling edge
+#endif
+
+#ifdef CLOCK_EDGE_RISING
+                B_Data[0] |= BIT_EDGE_RISE;                                                                     // Set to rising edge
+#endif
+
+        WriteByteTPI(TPI_PIX_REPETITION, B_Data[0]);       //-------------------------TPI  0x08 input Bus and Pixel Repetition Data
+	/* End configur for TPI 0x08*/
+
+
+#ifdef DEV_EMBEDDED
+	EMB_Status = SetEmbeddedSync(Mode);
+	EnableEmbeddedSync();
+#endif
+
+/* Start configur for TPI 0x09 and 0x0A*/
+        // default to full range RGB at the input:
+#ifndef USE_DE_GENERATOR
+        B_Data[0] = (((BITS_IN_RGB | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE);  // 0x09
+#else
+        B_Data[0] = (((BITS_IN_YCBCR422 | BITS_IN_AUTO_RANGE) & ~BIT_EN_DITHER_10_8) & ~BIT_EXTENDED_MODE);  // 0x09
+#endif
+
+
+#ifdef DEV_EMBEDDED
+		B_Data[0] = ((B_Data[0] & 0xFC) | 0x02);
+#endif
+        B_Data[1] = (BITS_OUT_RGB | BITS_OUT_AUTO_RANGE) & ~BIT_BT_709;
+
+
+#ifdef DEV_SUPPORT_EDID
+		if (dvi_mode == TRUE)
+		{
+	        B_Data[1] = ((B_Data[1] & 0xFC) | 0x03);
+		}
+		else
+		{
+	        // Set YCbCr color space depending on EDID
+	        if (EDID_Data.YCbCr_4_4_4)
+	        {
+	                B_Data[1] = ((B_Data[1] & 0xFC) | 0x01);
+	        }
+	        else
+	        {
+	                if (EDID_Data.YCbCr_4_2_2)
+	                {
+	                        B_Data[1] = ((B_Data[1] & 0xFC) | 0x02);
+	                }
+	        }
+		}
+#else
+        B_Data[1] = 0x00;
+#endif
+
+		SetFormat(B_Data);
+/* End configur for TPI 0x09 and 0x0A*/
+
+
+		ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, BIT_2); // // Number HSync pulses from VSync active edge to Video Data Period should be 20 (VS_TO_VIDEO)
+    }
+
+#ifdef SOURCE_TERMINATION_ON
+        V_Mode = ReadIndexedRegister(INDEXED_PAGE_1, TMDS_CONT_REG);
+        V_Mode = (V_Mode & 0x3F) | 0x25;
+        WriteIndexedRegister(INDEXED_PAGE_1, TMDS_CONT_REG, V_Mode);
+#endif
+
+    return TRUE;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetFormat(byte * Data)
+//
+// PURPOSE      :   
+//
+// INPUT PARAMS :   
+//
+// OUTPUT PARAMS:   
+//
+// GLOBALS USED :   
+//
+// RETURNS      :   
+//
+//////////////////////////////////////////////////////////////////////////////
+void SetFormat(byte *Data)
+{
+	if (dvi_mode)
+	{
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_HDMI); // Set HDMI mode to allow color space conversion
+	}
+
+	WriteBlockTPI(TPI_INPUT_FORMAT_REG, 2, Data);   // Program TPI AVI Input and Output Format
+	WriteByteTPI(TPI_END_RIGHT_BAR_MSB, 0x00);	    // Set last byte of TPI AVI InfoFrame for TPI AVI I/O Format to take effect
+
+	if (dvi_mode == TRUE) 
+	{
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_DVI);
+	}
+
+#ifdef DEV_EMBEDDED
+	EnableEmbeddedSync();							// Last byte of TPI AVI InfoFrame resets Embedded Sync Extraction
+#endif
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetEmbeddedSync(V_Mode)
+//
+// PURPOSE      :   Set the 9022/4 registers to extract embedded sync.
+//
+// INPUT PARAMS :   Index of video mode to set
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   VModesTable[]
+//
+// RETURNS      :   TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool SetEmbeddedSync(byte V_Mode)
+{
+    word H_Bit_2_H_Sync;
+    word Field2Offset;
+    word H_SyncWidth;
+
+    byte V_Bit_2_V_Sync;
+    byte V_SyncWidth;
+    byte B_Data[8];
+
+    TPI_TRACE_PRINT((">>SetEmbeddedSync()\n"));
+
+	ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x01, 0x01);
+
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	 // set 0x60[7] = 0 for DE mode
+	WriteByteTPI(0x63, 0x30);							//modify Vsync, Hsync Poliarity, See PR Table14 note2 for detail. This can only be done after set 0x60[7] to 0 for DE mode
+    ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 1 for Embedded Sync
+
+    V_Mode = ConvertVIC_To_VM_Index(V_Mode, NO_3D_SUPPORT);                // convert 861-D VIC into VModesTable[] index. No 3D with embedded sync
+
+    H_Bit_2_H_Sync = VModesTable[V_Mode]._656.HBit2HSync;
+    Field2Offset = VModesTable[V_Mode]._656.Field2Offset;
+    H_SyncWidth = VModesTable[V_Mode]._656.HLength;
+    V_Bit_2_V_Sync = VModesTable[V_Mode]._656.VBit2VSync;
+    V_SyncWidth = VModesTable[V_Mode]._656.VLength;
+
+    B_Data[0] = H_Bit_2_H_Sync & LOW_BYTE;                  // Setup HBIT_TO_HSYNC 8 LSBits (0x62)
+
+    B_Data[1] = (H_Bit_2_H_Sync >> 8) & TWO_LSBITS;         // HBIT_TO_HSYNC 2 MSBits
+    //B_Data[1] |= BIT_EN_SYNC_EXTRACT;                     // and Enable Embedded Sync to 0x63
+
+    EmbeddedSynPATCH = B_Data[1];				//--------------------------------Store TPI 0x63 value for future use, because when AVI infoframe register TPI 0x19 is written, TPI 0x63[6] Embedded Sync Mode information will be reset to defaule
+												//Place it here correct?? At this moment, 0x63[6]= 0 means use external sync. Embedded is enabled in another function EnableEmbeddedSync(). Maybe shoud move this sentence to EnableEmbeddedSync().
+    B_Data[2] = Field2Offset & LOW_BYTE;                    // 8 LSBits of "Field2 Offset" to 0x64
+    B_Data[3] = (Field2Offset >> 8) & LOW_NIBBLE;           // 2 MSBits of "Field2 Offset" to 0x65
+
+    B_Data[4] = H_SyncWidth & LOW_BYTE;
+    B_Data[5] = (H_SyncWidth >> 8) & TWO_LSBITS;                    // HWIDTH to 0x66, 0x67
+    B_Data[6] = V_Bit_2_V_Sync;                                     // VBIT_TO_VSYNC to 0x68
+    B_Data[7] = V_SyncWidth;                                        // VWIDTH to 0x69
+
+	WriteBlockTPI(TPI_HBIT_TO_HSYNC_7_0, 8, &B_Data[0]);	//---------------------Configur Embedded Sync Extraction Register, PR Table14.
+    return TRUE;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   EnableEmbeddedSync
+//
+// PURPOSE      :
+//
+// INPUT PARAMS :
+//
+// OUTPUT PARAMS:
+//
+// GLOBALS USED :
+//
+// RETURNS      :
+//
+//////////////////////////////////////////////////////////////////////////////
+void EnableEmbeddedSync()
+{
+    TPI_TRACE_PRINT((">>EnableEmbeddedSync()\n"));
+
+	ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);	 // set 0x60[7] = 0 for DE mode
+	WriteByteTPI(0x63, 0x30);			//------------------modify Vsync, Hsync Poliarity, See PR Table14 note2 for detail. This can only be done after set 0x60[7] to 0 for DE mode
+    ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 1 for Embedded Sync
+	ReadSetWriteTPI(TPI_DE_CTRL, BIT_6);			//-----------------set 0x63 bit 6 to enable Embedded Sync Extraction, note: Extraction not means use Embedded Syne. 0x60[7] determins use embedded or external sync
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetDE(V_Mode)
+//
+// PURPOSE      :   Set the 9022/4 internal DE generator parameters
+//
+// INPUT PARAMS :   Index of video mode to set
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   DE_SET_OK
+//
+// NOTE         :   0x60[7] must be set to "0" for the follwing settings to
+//                  take effect
+//
+//////////////////////////////////////////////////////////////////////////////
+byte SetDE(byte V_Mode)
+{
+    byte RegValue;
+
+    word H_StartPos;
+    word V_StartPos;
+	word Htotal;
+	word Vtotal;
+    word H_Res;
+    word V_Res;
+
+    byte Polarity;
+    byte B_Data[12];
+
+    TPI_TRACE_PRINT((">>SetDE()\n"));
+
+        if (VModesTable[V_Mode]._3D_Struct != NO_3D_SUPPORT)
+        {
+                return DE_CANNOT_BE_SET_WITH_3D_MODE;
+                TPI_TRACE_PRINT((">>SetDE() not allowed with 3D video format\n"));
+
+        }
+    // Make sure that External Sync method is set before enableing the DE Generator:
+    RegValue = ReadByteTPI(TPI_SYNC_GEN_CTRL);
+
+    if (RegValue & BIT_7)
+    {
+        return DE_CANNOT_BE_SET_WITH_EMBEDDED_SYNC;
+    }
+
+    V_Mode = ConvertVIC_To_VM_Index(V_Mode, NO_3D_SUPPORT);                // convert 861-D VIC into VModesTable[] index. No 3D with internal DE
+
+    H_StartPos = VModesTable[V_Mode].Pos.H;
+    V_StartPos = VModesTable[V_Mode].Pos.V;
+
+   	Htotal = VModesTable[V_Mode].Tag.Total.Pixels;
+	Vtotal = VModesTable[V_Mode].Tag.Total.Lines;
+
+    Polarity = (~VModesTable[V_Mode].Tag.RefrTypeVHPol) & TWO_LSBITS;
+
+    H_Res = VModesTable[V_Mode].Res.H;
+
+        if ((VModesTable[V_Mode].Tag.RefrTypeVHPol & 0x04))
+        {
+        V_Res = (VModesTable[V_Mode].Res.V) >> 1;
+        }
+        else
+        {
+                V_Res = (VModesTable[V_Mode].Res.V);
+        }
+
+    B_Data[0] = H_StartPos & LOW_BYTE;              // 8 LSB of DE DLY in 0x62
+
+    B_Data[1] = (H_StartPos >> 8) & TWO_LSBITS;     // 2 MSBits of DE DLY to 0x63
+    B_Data[1] |= (Polarity << 4);                   // V and H polarity
+    B_Data[1] |= BIT_EN_DE_GEN;                     // enable DE generator
+
+    B_Data[2] = V_StartPos & SEVEN_LSBITS;      // DE_TOP in 0x64
+    B_Data[3] = 0x00;                           // 0x65 is reserved
+    B_Data[4] = H_Res & LOW_BYTE;               // 8 LSBits of DE_CNT in 0x66
+    B_Data[5] = (H_Res >> 8) & LOW_NIBBLE;      // 4 MSBits of DE_CNT in 0x67
+    B_Data[6] = V_Res & LOW_BYTE;               // 8 LSBits of DE_LIN in 0x68
+    B_Data[7] = (V_Res >> 8) & THREE_LSBITS;    // 3 MSBits of DE_LIN in 0x69
+	B_Data[8] = Htotal & LOW_BYTE;				// 8 LSBits of H_RES in 0x6A
+	B_Data[9] =	(Htotal >> 8) & LOW_NIBBLE;		// 4 MSBITS of H_RES in 0x6B
+	B_Data[10] = Vtotal & LOW_BYTE;				// 8 LSBits of V_RES in 0x6C
+	B_Data[11] = (Vtotal >> 8) & BITS_2_1_0;	// 3 MSBITS of V_RES in 0x6D
+
+    WriteBlockTPI(TPI_DE_DLY, 12, &B_Data[0]);	//--------------Configure TPI 0x62 to 0x6D for Explicit Sync DE Generator
+
+//MessageIndex     EnqueueMessageIndex(DE_SET_OK);                   // For GetStatus()
+    return DE_SET_OK;                               // Write completed successfully
+}
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : SetBasicAudio()
+//
+// PURPOSE       : Set the 9022/4 audio interface to basic audio.
+//
+// INPUT PARAMS  : None
+//
+// OUTPUT PARAMS : None
+//
+// GLOBALS USED  : None
+//
+// RETURNS       : void.
+//
+//////////////////////////////////////////////////////////////////////////////
+void SetBasicAudio(void)
+{
+
+        TPI_TRACE_PRINT((">>SetBasicAudio()\n"));
+
+#ifdef I2S_AUDIO
+    WriteByteTPI(TPI_AUDIO_INTERFACE_REG,  AUD_IF_I2S);                             // 0x26
+    WriteByteTPI(TPI_AUDIO_HANDLING, 0x08 | AUD_DO_NOT_CHECK);          // 0x25
+#else
+    WriteByteTPI(TPI_AUDIO_INTERFACE_REG, AUD_IF_SPDIF);                    // 0x26 = 0x40
+    WriteByteTPI(TPI_AUDIO_HANDLING, AUD_PASS_BASIC);                   // 0x25 = 0x00
+#endif
+
+#ifndef F_9022A_9334
+            SetChannelLayout(TWO_CHANNELS);             // Always 2 channesl in S/PDIF
+#else
+            ReadClearWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] for 9022A/24A and 9334 channel layout
+#endif
+
+#ifdef I2S_AUDIO
+        // I2S - Map channels - replace with call to API MAPI2S
+        WriteByteTPI(TPI_I2S_EN, 0x80); // 0x1F
+//        WriteByteTPI(TPI_I2S_EN, 0x91);
+//        WriteByteTPI(TPI_I2S_EN, 0xA2);
+//        WriteByteTPI(TPI_I2S_EN, 0xB3);
+
+        // I2S - Stream Header Settings - replace with call to API SetI2S_StreamHeader
+        WriteByteTPI(TPI_I2S_CHST_0, 0x00); // 0x21
+        WriteByteTPI(TPI_I2S_CHST_1, 0x00);
+        WriteByteTPI(TPI_I2S_CHST_2, 0x00);
+        WriteByteTPI(TPI_I2S_CHST_3, 0x02);
+        WriteByteTPI(TPI_I2S_CHST_4, 0x02);
+
+        // I2S - Input Configuration - replace with call to API ConfigI2SInput
+        WriteByteTPI(TPI_I2S_IN_CFG, 0x10); // 0x20
+#endif
+
+    WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, TWO_CHANNELS);  // 0x27 = 0x01
+    SetAudioInfoFrames(TWO_CHANNELS, 0x00, 0x00, 0x00, 0x00);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ChangeVideoMode()
+//
+// PURPOSE       :  Changes the 9022/4 video resolution following a command from
+//                  System Control
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters, sent from
+//                  the system controller
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  RxCommand, F_IgnoreEDID
+//
+// RETURNS       :  Success message if video resolution changed successfully.
+//                  Error Code if resolution change failed
+//
+// NOTE         :   Function calls InitVideo() with the 2nd parameter set to
+//                  MODE_CHANGE (==0). That will initialized only the basic
+//                  parameters (Pix. Clk; VFreq; H. # of pixels;...). Other
+//                  parmeters will not be set by InitVideo(), and will be set
+//                  by this function, based on the values passed in the
+//                  API_Cmd typed parameter
+//
+//////////////////////////////////////////////////////////////////////////////
+byte ChangeVideoMode(API_Cmd Command)
+{
+    byte Result;
+    byte Status;
+
+  	TPI_TRACE_PRINT((">>ChangeVideoMode()\n"));
+
+	vid_mode = Command.Arg[0];//zhy 2009 11 24
+#ifdef DEV_SUPPORT_HDCP
+    HDCP_Off();
+#endif
+
+    DisableTMDS();                  // turn off TMDS output
+    DelayMS(T_RES_CHANGE_DELAY);    // allow control InfoFrames to pass through to the sink device.
+
+
+#ifndef DEBUG_EDID
+    if (!F_IgnoreEDID)
+    {
+        Result = IsVideoModeSupported (vid_mode);
+        if (!Result)
+            return V_MODE_NOT_SUPPORTED;                // Sink does not support this video mode
+    }
+#endif
+		// Do not change vid_mode via IForm
+	  	//vid_mode = Command.Arg[0];
+
+        InitVideo(vid_mode, ((Command.Arg[1] >> 6) & TWO_LSBITS), MODE_CHANGE, Command.Arg[8]);        // Will set values based on VModesTable[Arg[0])
+
+
+//        WriteByteTPI(TPI_PIX_REPETITION, Command.Arg[1]);  // 0x08
+
+
+        Command.Arg[2] &= ~BITS_5_4;                         // No Deep Color in 9022A/24A, 9022/4
+
+        WriteByteTPI(TPI_INPUT_FORMAT_REG, Command.Arg[2]);    //Write input formats to TPI 0x09     /* // Write output formats to register 0x0A*/
+
+        if ((Command.Arg[3] & TWO_LSBITS) == CS_DVI_RGB)
+        {
+            	ReadClearWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPT_MODE_HDMI);        // Set 0x1A[0] to DVI
+		ReadModifyWriteTPI(TPI_OUTPUT_FORMAT_REG, TWO_LSBITS, CS_DVI_RGB);   // Set 0x0A[1:0] to DVI RGB
+	}
+
+        else if (((Command.Arg[3] & TWO_LSBITS) >= CS_HDMI_RGB) && ((Command.Arg[3] & TWO_LSBITS) < CS_DVI_RGB)) // An HDMI CS
+        {
+
+#ifdef DEV_SUPPORT_EDID
+            if (IsHDMI_Sink())                                                  // sink suppurts HDMI
+            {
+                ReadSetWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPT_MODE_HDMI);  // Set 0x1A[0] to HDMI
+                
+		//zhy + Begin Out color space selected
+		if (dvi_mode == TRUE)
+		{
+	        Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x03);
+		}
+		else
+		{
+	        // Set YCbCr color space depending on EDID
+	        if (EDID_Data.YCbCr_4_4_4)
+	        {
+	                Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x01);		//Set Command.Arg[3] output color space YC444
+	        }
+	        else
+	        {
+	                if (EDID_Data.YCbCr_4_2_2)
+	                {
+	                        Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x02);	//Set Command.Arg[3] output color space YC422
+	                }
+			  else
+			  	{
+			  	Command.Arg[3] = (Command.Arg[3] & 0xFC) ;		//Set Command.Arg[3] output color space RGB
+			  	}
+	        }
+		}
+ 		//zhy + End Out color space selected
+            }
+		//zhy+  Begin DVI compliance 	
+		else
+		{
+            ReadClearWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPT_MODE_HDMI);        // Set 0x1A[0] to DVI
+            // ReadClearWriteTPI(TPI_OUTPUT_FORMAT, CS_DVI_RGB);              // Set 0x0A[1:0] to DVI RGB
+			Command.Arg[3] = ((Command.Arg[3] & 0xFC) | 0x03);
+		}
+		//zhy+  End DVI compliance 	
+
+                        // No else?
+#endif
+        }
+
+		WriteByteTPI(TPI_PIX_REPETITION, Command.Arg[1]);  // TIP 0x08
+
+        WriteByteTPI(TPI_OUTPUT_FORMAT_REG, Command.Arg[3]);   // Write input and output formats to registers 0x09, 0x0A
+        
+/* Start configur Embeded Sync and DE generator*/
+	if (Command.Arg[4] & MSBIT)             // set embedded sync
+        {
+            ReadSetWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT); // set 0x60[7] = 1 for Embedded Sync,select use Embedded sync
+
+			if (Command.Arg[5] & BIT_6)	//Bit6 set means use DE generator-------?????????????????
+			{
+            			Result = SetEmbeddedSync(vid_mode);       // Call SetEmbeddedSync() with Video Mode as a parameter
+			        if (!Result)
+			        {
+					return SET_EMBEDDED_SYC_FAILURE;
+		            	  }
+				EnableEmbeddedSync();
+			}	
+			else
+			{
+                		ReadClearWriteTPI(TPI_DE_CTRL, BIT_6);     // clear 0x63[6] = 0 to disable internal DE
+			}	
+        }
+    	else                                    // Set external sync
+        {
+            ReadClearWriteTPI(TPI_SYNC_GEN_CTRL, MSBIT);       // set 0x60[7] = 0 for External Sync
+
+            if (Command.Arg[5] & BIT_6)     // set Internal DE Generator only if 0x60[7] == 0
+            {
+                ReadSetWriteTPI(TPI_DE_CTRL, BIT_6);               // set 0x63[6] = 1 for DE
+
+                Status = SetDE(vid_mode);         // Call SetDE() with Video Mode as a parameter
+                if (Status != DE_SET_OK)
+                {
+                    return Status;
+                }
+            }
+
+            else if (!(Command.Arg[5] & BIT_6))
+            {
+                ReadClearWriteTPI(TPI_DE_CTRL, BIT_6);     // clear 0x63[6] = 0 to disable internal DE
+            }
+        }
+/* End configur Embeded Sync and DE generator*/
+
+	TxPowerState(TX_POWER_STATE_D0);//zhy +
+	
+#ifdef DEV_SUPPORT_EDID
+		if (IsHDMI_Sink())
+        	{
+			SetAVI_InfoFrames(Command);             // InfoFrames - only if output mode is HDMI
+		}
+//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+// PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!
+//
+
+// THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63 and 0x60[5]
+
+            WriteByteTPI(TPI_SYNC_GEN_CTRL, Command.Arg[4]);    // Set 0x60 according to Command.Arg[4]
+                                                                // THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63 and 0x60[5]
+
+        if(Command.Arg[4] & MSBIT)              // THIS PATCH IS NEEDED BECAUSE SETTING UP AVI InfoFrames CLEARS 0x63
+		{
+            WriteByteTPI(TPI_DE_CTRL, EmbeddedSynPATCH); // (set in function SetEmbeddedSync())TO 0.
+		}
+//
+// PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!PATCH!!!
+//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+#endif
+
+        // Command.Arg[6][3:2] -> 0x0E[7:6] Colorimetry
+        ReadModifyWriteTPI(TPI_AVI_BYTE_2, BITS_7_6, Command.Arg[6] << 4);
+
+        // Command.Arg[6][6:4] -> 0x0F[6:4] Extended Colorimetry
+        if ((Command.Arg[6] & BITS_3_2) == SET_EX_COLORIMETRY)
+        {
+			ReadModifyWriteTPI(TPI_AVI_BYTE_3, BITS_6_5_4, Command.Arg[6]);
+        }
+
+        //==========================================================
+
+
+        // YC Input Mode Select - Command.Arg[7] - offset 0x0B
+		//printf("before set Arg[7] = 0x%x\n", (int)Command.Arg[7]);
+
+        WriteByteTPI(TPI_YC_Input_Mode, Command.Arg[7]);
+//		tmp = ReadByteTPI(TPI_YC_Input_Mode);
+//		printf("after set Arg[7] = 0x%x\n", (int)tmp);
+
+	//zhy + Begin
+ 	// This check needs to be changed to if HDCP is required by the content... once support has been added by RX-side library.
+	if (HDCP_TxSupports == TRUE)
+	{
+	// AV MUTE
+        ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, LINK_INTEGRITY_MODE_MASK | TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK, LINK_INTEGRITY_DYNAMIC | TMDS_OUTPUT_CONTROL_ACTIVE | AV_MUTE_MUTED);
+		tmdsPoweredUp = TRUE;
+	}
+	else
+	{
+		EnableTMDS();
+	}
+       //EnableTMDS();
+	//zhy + End
+
+        return VIDEO_MODE_SET_OK;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetAudioMode()
+//
+// PURPOSE       :  Changes the 9022/4 audio mode as defined by a command from
+//                  the System Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if audio mode set successfully. Error
+//                  Code if failed
+//
+//////////////////////////////////////////////////////////////////////////////
+byte SetAudioMode(API_Cmd Command)
+{
+    bool Result;
+
+    TPI_TRACE_PRINT((">>SetAudioMode()\n"));
+
+    Result = IsAudioModeSupported(Command.Arg[0] & LOW_NIBBLE);
+
+    if (!Result)
+    {
+//MessageIndex         EnqueueMessageIndex(AUD_MODE_NOT_SUPPORTED);
+        return AUD_MODE_NOT_SUPPORTED;
+    }
+    else
+    {
+		SetAudioMute(AUDIO_MUTE_MUTED);
+
+//  	    ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, HI_NIBBLE, Command.Arg[0]);    // Arg[0][7:4] - 0x26[7:4] - Set audio interface, layout, and mute/unmute
+		WriteByteTPI(TPI_AUDIO_INTERFACE_REG, Command.Arg[0]);
+
+/// //     	WriteByteTPI(TPI_SPEAKER_CFG, Command.Arg[2]);              // 0x28 - Speaker Configuration - for both S/PDIF and I2S/DSD
+
+        if ((Command.Arg[0] & TWO_MSBITS) == AUD_IF_SPDIF)          // S/PDIF audio interface
+        {
+            ReadModifyWriteTPI(TPI_AUDIO_HANDLING, BITS_1_0, Command.Arg[3]);       // 0x25[1:0] - Audio Handling (S/PDIF only)
+
+//          WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, Command.Arg[1]);   // 0x27 - Sample Frequency; Sample Size
+            ReadModifyWriteTPI(TPI_AUDIO_SAMPLE_CTRL, BITS_7_6 | BITS_5_4_3, Command.Arg[1]); // Sample Frequency 0x27[5:3]; Sample Size 0x27[7:6]
+
+            ReadClearWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] for 9022A/24A and 9334 channel layout
+        }
+        else                                                        // I2S or DSD Audio interface
+        {
+            WriteByteTPI(TPI_AUDIO_SAMPLE_CTRL, Command.Arg[1]);   // 0x27 - HBR; Sample Frequency; Sample Size
+
+        if ((Command.Arg[0] & TWO_MSBITS) == AUD_IF_DSD)     // DSD audio interface
+			ReadSetWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5); // Use TPI 0x26[5] to set to Layout_1
+		else if ((Command.Arg[0] & TWO_MSBITS) == AUD_IF_I2S) // I2S audio interface
+			ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_5, Command.Arg[0]); // Set user's channel layout selection to TPI 0x26[5]
+
+        }
+
+		SetAudioMute(AUDIO_MUTE_NORMAL);
+
+		SetAudioInfoFrames(Command.Arg[5] & THREE_LSBITS, Command.Arg[0] & FOUR_LSBITS, Command.Arg[1] & BITS_7_6, Command.Arg[1] & BITS_5_4_3, Command.Arg[2]); //channel count, spk config,coding type, sample size, sample freq.	
+
+		ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, BIT_4, Command.Arg[0]);		// Set audio mute/unmute bit.
+
+        return AUDIO_MODE_SET_OK;
+    }
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  MapI2S()
+//
+// PURPOSE       :  Changes the 9022/4 I2S channel mapping as defined by a
+//                  command sent from the System Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if channel mapping successful. Error
+//                  Code if failed
+//
+//////////////////////////////////////////////////////////////////////////////
+byte MapI2S(API_Cmd Command)
+{
+    byte B_Data;
+	int i;
+	// byte temp;
+
+        TPI_TRACE_PRINT((">>MapI2S()\n"));
+
+    B_Data = ReadByteTPI(TPI_AUDIO_INTERFACE_REG);
+
+    if ((B_Data & TWO_MSBITS) != AUD_IF_I2S)    // 0x26 not set to I2S interface
+    {
+        return I2S_NOT_SET;
+    }
+
+//      WriteByteTPI(TPI_I2S_EN, Command.Arg[0]);
+
+//      printf("I2sMapping:\n");
+
+		for (i = 0; i < I2S_MAPPING_CMD_LEN; i++)
+        {
+			WriteByteTPI(TPI_I2S_EN, Command.Arg[i]);
+
+//			temp = ReadByteTPI(TPI_I2S_EN);
+//         	printf("    FIFO#%d = 0x%2X\n", i, (int)temp);
+
+			if ((Command.Arg[i+1] & BITS_1_0) == 0)
+				return 0;
+        }
+    return I2S_MAPPING_SUCCESSFUL;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ConfigI2SInput()
+//
+// PURPOSE       :  Sets the 9022/4 I2S channel bit direction, justification
+//                  and polarity as defined by acommand sent from the System
+//                  Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if video I2S channels configuredsuccessfully.
+//                  Error Code if setting failed
+//
+//////////////////////////////////////////////////////////////////////////////
+byte ConfigI2SInput(API_Cmd Command)
+{
+    byte B_Data;
+
+        TPI_TRACE_PRINT((">>ConfigI2SInput()\n"));
+
+    B_Data = ReadByteTPI(TPI_AUDIO_INTERFACE_REG);
+
+    if ((B_Data & TWO_MSBITS) != AUD_IF_I2S)    // 0x26 not set to I2S interface
+    {
+        return I2S_NOT_SET;
+    }
+
+    WriteByteTPI(TPI_I2S_IN_CFG, Command.Arg[0]);
+
+    return I2S_INPUT_CONFIG_SUCCESSFUL;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetI2S_StreamHeader()
+//
+// PURPOSE       :  Sets the 9022/4 I2S Channel Status bytes, as defined by
+//                  a command sent from the System Controller
+//
+// INPUT PARAMS  :  API_Cmd type structure with command parameters
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  Success message if stream header set successfully. Error
+//                  Code if failed
+//
+//////////////////////////////////////////////////////////////////////////////
+byte SetI2S_StreamHeader(API_Cmd Command)
+{
+    byte B_Data;
+    int i;
+
+        TPI_TRACE_PRINT((">>SetI2S_StreamHeader()\n"));
+
+    B_Data = ReadByteTPI(TPI_AUDIO_INTERFACE_REG);
+
+    if ((B_Data & TWO_MSBITS) != AUD_IF_I2S)    // 0x26 not set to I2S interface
+    {
+        return I2S_NOT_SET;
+    }
+
+    for (i = 0; i < Command.CommandLength; i++)
+    {
+        WriteByteTPI(TPI_I2S_CHST_0 + i, Command.Arg[i]);
+    }
+
+    return I2S_HEADER_SET_SUCCESSFUL;
+}
+
+
+#ifdef F_9022A_9334
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetGBD_InfoFrame(()
+//
+// PURPOSE      :   Sets and sends the the 9022A/4A GBD InfoFrames according
+//                  to data sent from the System Controller
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   Success message if GBD packet set successfully. Error
+//                  Code if failed
+//
+// NOTE         :   Currently this function is a place holder. It always
+//                  returns a Success message
+//
+//////////////////////////////////////////////////////////////////////////////
+byte SetGBD_InfoFrame()
+{
+        byte CheckSum;
+
+        TPI_TRACE_PRINT((">>SetGBD_InfoFrame()\n"));
+
+        // Set MPEG InfoFrame Header to GBD InfoFrame Header values:
+        WriteByteTPI(MISC_INFO_FRAMES_CTRL, MPEG_INFOFRAME_CODE);                       // 0xBF = Use MPEG      InfoFrame for GBD - 0x03
+        WriteByteTPI(MISC_INFO_FRAMES_TYPE, TYPE_GBD_INFOFRAME);                        // 0xC0 = 0x0A
+        WriteByteTPI(MISC_INFO_FRAMES_VER, NEXT_FIELD | GBD_PROFILE | AFFECTED_GAMUT_SEQ_NUM);   // 0x0C1 = 0x81
+        WriteByteTPI(MISC_INFO_FRAMES_LEN, ONLY_PACKET | CURRENT_GAMUT_SEQ_NUM);                                // 0x0C2 = 0x31
+
+        CheckSum = TYPE_GBD_INFOFRAME +
+                           NEXT_FIELD +
+                           GBD_PROFILE +
+                           AFFECTED_GAMUT_SEQ_NUM +
+                           ONLY_PACKET +
+                           CURRENT_GAMUT_SEQ_NUM;
+
+        CheckSum = 0x100 - CheckSum;
+
+            WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_MPEG);  // Enable and Repeat MPEG InfoFrames
+        WriteByteTPI(MISC_INFO_FRAMES_CHKSUM, CheckSum);                        // 0X00 - Send header only
+
+        return GBD_SET_SUCCESSFULLY;
+}
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  IsVideoModeSupported()
+//
+// PURPOSE       :  Checks if the video mode passed as parameter is supported
+//                  by the connected sink (as read from its EDID).
+//
+// INPUT PARAMS  :  Video mode number
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE if mode is supported by the sink. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+bool IsVideoModeSupported(byte V_Mode)
+{
+#ifdef DEV_SUPPORT_EDID
+    int i;
+
+        TPI_TRACE_PRINT((">>IsVideoModeSupported()\n"));
+
+    for (i = 0; i < MAX_V_DESCRIPTORS; i++)
+    {
+        if ((EDID_Data.VideoDescriptor[i] & SEVEN_LSBITS) == V_Mode)
+            return TRUE;
+    }
+    return FALSE;
+#else
+        V_Mode = V_Mode;        // dummy usage of parameter to avoid compiler warning
+        TPI_TRACE_PRINT((">>IsVideoModeSupported()\n"));
+        return TRUE;            // Just return true for now... what other mechanism should be used to determine support?
+#endif
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  IsAudioModeSupported()
+//
+// PURPOSE       :  Checks if the audio mode passed as parameter is supported
+//                  by the connected sink (as read from its EDID).
+//
+// INPUT PARAMS  :  Video mode number
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE if mode is supporter by the sink. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+byte IsAudioModeSupported(byte A_Mode)
+{
+#ifdef DEV_SUPPORT_EDID
+        int i;
+
+        TPI_TRACE_PRINT((">>IsAudioModeSupported()\n"));
+
+        for (i = 0; i < MAX_A_DESCRIPTORS; i++)
+        {
+                if ((((EDID_Data.AudioDescriptor[i][0]) & SEVEN_LSBITS) >> 3) == A_Mode)
+                        return TRUE;
+        }
+        return FALSE;
+#else
+        A_Mode = A_Mode;        // dummy usage of parameter to avoid compiler warning
+        TPI_TRACE_PRINT((">>IsAudioModeSupported()\n"));
+        return TRUE;            // Just return true for now... what other mechanism should be used to determine support?
+#endif
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetAVI_InfoFrames()
+//
+// PURPOSE       :  Load AVI InfoFrame data into registers and send to sink
+//
+// INPUT PARAMS  :  An API_Cmd parameter that holds the data to be sent
+//                  in the InfoFrames
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool SetAVI_InfoFrames(API_Cmd Command)
+{
+    byte B_Data[SIZE_AVI_INFOFRAME];
+    byte VideoMode;                     // pointer to VModesTable[]
+    byte i;
+    byte TmpVal;
+
+    TPI_TRACE_PRINT((">>SetAVI_InfoFrames()\n"));
+
+    for (i = 0; i < SIZE_AVI_INFOFRAME; i++)
+        B_Data[i] = 0;
+
+    //zhy - Begin
+    //if (Command.CommandLength > VIDEO_SETUP_CMD_LEN)    // Command length > 9. AVI InfoFrame is set by the host
+    //{
+   //     for (i = 1; i < Command.CommandLength - VIDEO_SETUP_CMD_LEN; i++)
+   //         B_Data[i] = Command.Arg[VIDEO_SETUP_CMD_LEN + i - 1];
+    //}
+    //else                                                // Command length == 7. AVI InfoFrame is set by the FW
+    //zhy - End
+    {
+        if ((Command.Arg[3] & TWO_LSBITS) == 1)         // AVI InfoFrame DByte1
+            TmpVal = 2;
+        else if ((Command.Arg[3] & TWO_LSBITS) == 2)
+            TmpVal = 1;
+        else
+            TmpVal = 0;
+
+            B_Data[1] = (TmpVal << 5) & BITS_OUT_FORMAT;                    // AVI Byte1: Y1Y0 (output color indictor RGB/YC422/YC444)
+
+            if (((Command.Arg[6] >> 2) & TWO_LSBITS) == 3)                  // Extended colorimetry - xvYCC
+            {
+                B_Data[2] = 0xC0;                                           // Extended colorimetry info (B_Data[3] valid (CEA-861D, Table 11)
+
+                if (((Command.Arg[6] >> 4) & THREE_LSBITS) == 0)            // xvYCC601
+                    B_Data[3] &= ~BITS_6_5_4;
+
+                else if (((Command.Arg[6] >> 4) & THREE_LSBITS) == 1)       // xvYCC709
+                    B_Data[3] = (B_Data[3] & ~BITS_6_5_4) | BIT_4;
+            }
+
+            else if (((Command.Arg[6] >> 2) & TWO_LSBITS) == 2)             // BT.709
+                B_Data[2] = 0x80;                                           // AVI Byte2: C1C0
+
+            else if (((Command.Arg[6] >> 2) & TWO_LSBITS) == 1)             // BT.601
+                B_Data[2] = 0x40;                                           // AVI Byte2: C1C0
+
+			else															// Carries no data
+			{																// AVI Byte2: C1C0
+				B_Data[2] &= ~BITS_7_6;										// colorimetry = 0
+				B_Data[3] &= ~BITS_6_5_4;									// Extended colorimetry = 0
+			}
+
+            VideoMode = ConvertVIC_To_VM_Index(vid_mode, Command.Arg[8] & LOW_NIBBLE);              /// //
+
+			B_Data[4] = vid_mode;
+
+#ifdef RX_ONBOARD
+			if ((avi_information.byte_2 & PICTURE_ASPECT_RATIO_MASK) == PICTURE_ASPECT_RATIO_16x9)
+			{
+                B_Data[2] |= _16_To_9;                          // AVI Byte2: M1M0
+				if (VModesTable[VideoMode].AspectRatio == _4or16 && AspectRatioTable[vid_mode-1] == _4)
+				{
+					vid_mode++;
+					B_Data[4]++;
+				}
+			}
+            else
+            {
+                B_Data[2] |= _4_To_3;                           // AVI Byte4: VIC
+			}
+#else
+			B_Data[2] |= _4_To_3;                           // AVI Byte4: VIC
+#endif
+
+            B_Data[2] |= SAME_AS_AR;                                        // AVI Byte2: R3..R1
+            B_Data[5] = VModesTable[VideoMode].PixRep;                      // AVI Byte5: Pixel Replication - PR3..PR0
+    }
+
+    B_Data[0] = 0x82 + 0x02 +0x0D;                                          // AVI InfoFrame ChecKsum
+
+    for (i = 1; i < SIZE_AVI_INFOFRAME; i++)
+        B_Data[0] += B_Data[i];
+
+    B_Data[0] = 0x100 - B_Data[0];
+
+    WriteBlockTPI(TPI_AVI_BYTE_0, SIZE_AVI_INFOFRAME, B_Data);
+#ifdef DEV_EMBEDDED
+    EnableEmbeddedSync();
+#endif
+
+    return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  SetAudioInfoFrames()
+//
+// PURPOSE       :  Load Audio InfoFrame data into registers and send to sink
+//
+// INPUT PARAMS  :  (1) Channel count (2) speaker configuration per CEA-861D
+//                  Tables 19, 20 (3) Coding type: 0x09 for DSD Audio. 0 (refer
+//                                      to stream header) for all the rest (4) Sample Frequency. Non
+//                                      zero for HBR only (5) Audio Sample Length. Non zero for HBR
+//                                      only.
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool SetAudioInfoFrames(byte ChannelCount, byte CodingType, byte SS, byte Fs, byte SpeakerConfig)
+{
+    byte B_Data[SIZE_AUDIO_INFOFRAME];  // 14
+    byte i;
+    byte TmpVal = 0;
+
+    TPI_TRACE_PRINT((">>SetAudioInfoFrames()\n"));
+
+    for (i = 0; i < SIZE_AUDIO_INFOFRAME +1; i++)
+        B_Data[i] = 0;
+
+    B_Data[0] = EN_AUDIO_INFOFRAMES;        // 0xC2
+    B_Data[1] = TYPE_AUDIO_INFOFRAMES;      // 0x84
+    B_Data[2] = AUDIO_INFOFRAMES_VERSION;   // 0x01
+    B_Data[3] = AUDIO_INFOFRAMES_LENGTH;    // 0x0A
+
+    B_Data[5] = ChannelCount;               // 0 for "Refer to Stream Header" or for 2 Channels. 0x07 for 8 Channels
+	B_Data[5] |= (CodingType << 4);                 // 0xC7[7:4] == 0b1001 for DSD Audio
+    B_Data[4] = 0x84 + 0x01 + 0x0A;         // Calculate checksum
+
+//    B_Data[6] = (Fs << 2) | SS;
+	B_Data[6] = (Fs >> 1) | (SS >> 6);
+
+	//write Fs to 0x27[5:3] and SS to 0x27[7:6] to update the IForm with the current value.
+//	ReadModifyWriteTPI(TPI_AUDIO_SAMPLE_CTRL, BITS_7_6 | BITS_5_4_3, (B_Data[6] & BITS_1_0) << 6 | (B_Data[6] & 0x1C) << 1);
+
+	B_Data[8] = SpeakerConfig;
+
+    for (i = 5; i < SIZE_AUDIO_INFOFRAME; i++)
+        B_Data[4] += B_Data[i];
+
+    B_Data[4] = 0x100 - B_Data[4];
+	g_audio_Checksum = B_Data[4];	// Audio checksum for global use
+
+    WriteBlockTPI(TPI_AUDIO_BYTE_0, SIZE_AUDIO_INFOFRAME, B_Data);
+	#ifdef DEV_EMBEDDED
+    EnableEmbeddedSync();
+	#endif
+    return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  Set_VSIF(()
+//
+// PURPOSE       :  Construct Vendor Specific InfoFrame for3D support. use
+//                                      MPEG InfoFrame
+//
+// INPUT PARAMS  :  (1) 3D_Structure value per HDMI 1.4, table H-2.
+//                                      (2) 3D_Ext_Data value per HDMI 1.4, table H-6.
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  void
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef DEV_SUPPORT_EDID
+void Set_VSIF(byte _3D_Struct, byte _3D_Ext_Data)
+{
+    byte i;
+    byte Data[16];
+	   
+    Data[0] = VSIF_TYPE;                // 0x81
+    Data[1] = VSIF_VERSION;             // 0x01
+    Data[2] = VSIF_LEN;                 // 5
+
+    Data[3] = VSIF_TYPE+                // partial checksum
+              VSIF_VERSION+
+              VSIF_LEN;
+
+    Data[4] = 0x03;                     // HDMI Signature LS Byte
+    Data[5] = 0x0C;                     // HDMI Signature middle byte
+    Data[6] = 0x00;                     // HDMI Signature MS Byte
+
+    Data[7] = _3D_STRUC_PRESENT << 5;   // 3D format indication present. 3D_Structure follows.
+    Data[8] = _3D_Struct << 4;   // 3D format indication present. 3D_Structure follows.
+
+        if (_3D_Struct == SIDE_BY_SIDE_HALF)
+            Data[9] = _3D_Ext_Data << 4;       // 3D_Structure - 0x00 for Frame Packing
+
+    for (i = 4; i < 10; i++)
+        Data[3] += Data[i];
+
+    Data[3] %= 0x100;
+    Data[3] = 100 - Data[3];            // Final checksum
+
+    WriteByteTPI(MISC_INFO_FRAMES_CTRL, EN_AND_RPT_MPEG);                           // Enable and Repeat MPEG InfoFrames
+    WriteBlockTPI(MISC_INFO_FRAMES_TYPE, 10, Data );               // Write VSIF to MPEG registers and start transmission
+}
+#endif
+
+//zhy + for Audio/video Change Begin
+void SetI2S(void)
+{
+	API_Cmd Command;
+	
+	Command.Arg[0] = AudioI2SConfig;
+	ConfigI2SInput(Command);
+	Command.Arg[0] = I2SSDSet[0];
+	Command.Arg[1] = I2SSDSet[1];
+	Command.Arg[2] = I2SSDSet[2];
+	Command.Arg[3] = I2SSDSet[3];
+	MapI2S(Command);
+	Command.Arg[0] = I2SStreamHeader[0];
+	Command.Arg[1] = I2SStreamHeader[1];
+	Command.Arg[2] = I2SStreamHeader[2];
+	Command.Arg[3] = I2SStreamHeader[3];
+	Command.Arg[4] = I2SStreamHeader[4];
+	Command.CommandLength = 5;
+	SetI2S_StreamHeader(Command);
+}
+
+void VideoModeSetbymain(void)
+{
+	API_Cmd Command;
+
+
+	Command.Arg[0] = VideoMode[0];
+	Command.Arg[1] = VideoMode[1];
+	Command.Arg[2] = VideoMode[2];
+	Command.Arg[3] = VideoMode[3];
+	Command.Arg[4] = VideoMode[4];
+	Command.Arg[5] = VideoMode[5];
+	Command.Arg[6] = VideoMode[6];
+	Command.Arg[7] = VideoMode[7];
+	Command.Arg[8] = VideoMode[8];
+	ChangeVideoMode(Command);
+}
+
+void AudioModeSetbymain(void)
+{
+	API_Cmd Command;
+	
+	Command.Arg[0] = AudioMode[0];
+	Command.Arg[1] = AudioMode[1];
+	Command.Arg[2] = AudioMode[2];
+	Command.Arg[3] = AudioMode[3];
+	Command.Arg[4] = AudioMode[4];
+	Command.Arg[5] = AudioMode[5];
+
+	SetAudioMode(Command);
+	
+	if((AudioMode[0]>>6)==2)
+	{
+		SetI2S();
+	}
+	
+}
+//zhy + for Audio/video Change Begin
+
diff --git a/drivers/video/hdmi/si9022/SIIConstants.h b/drivers/video/hdmi/si9022/SIIConstants.h
new file mode 100755
index 0000000..5b62576
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIConstants.h
@@ -0,0 +1,248 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+// Generic Constants
+//==================
+#define FALSE                   0
+#define TRUE                    1
+
+#define OFF                     0
+#define ON                      1
+
+#define LOW                     0
+#define HIGH                    1
+
+#define AFTER_INIT              1
+#define MODE_CHANGE             0
+
+// Generic Masks
+//==============
+#define LOW_BYTE                0x00FF
+
+#define LOW_NIBBLE              0x0F
+#define HI_NIBBLE               0xF0
+
+#define MSBIT                   0x80
+#define LSBIT                   0x01
+
+#define BIT_0                   0x01
+#define BIT_1                   0x02
+#define BIT_2                   0x04
+#define BIT_3                   0x08
+#define BIT_4                   0x10
+#define BIT_5                   0x20
+#define BIT_6                   0x40
+#define BIT_7                   0x80
+
+#define TWO_LSBITS              0x03
+#define THREE_LSBITS            0x07
+#define FOUR_LSBITS             0x0F
+#define FIVE_LSBITS             0x1F
+#define SEVEN_LSBITS            0x7F
+#define TWO_MSBITS              0xC0
+#define EIGHT_BITS              0xFF
+#define BYTE_SIZE               0x08
+#define BITS_1_0                0x03
+#define BITS_2_1                0x06
+#define BITS_2_1_0              0x07
+#define BITS_3_2                0x0C
+#define BITS_4_3_2              0x1C  
+#define BITS_5_4                0x30
+#define BITS_5_4_3				0x38
+#define BITS_6_5                0x60
+#define BITS_6_5_4              0x70
+#define BITS_7_6                0xC0
+
+
+// Interrupt Masks
+//================
+#define HOT_PLUG_EVENT          0x01
+#define RX_SENSE_EVENT          0x02
+#define HOT_PLUG_STATE          0x04
+#define RX_SENSE_STATE          0x08
+
+#define AUDIO_ERROR_EVENT       0x10
+#define SECURITY_CHANGE_EVENT   0x20
+#define V_READY_EVENT           0x40
+#define HDCP_CHANGE_EVENT       0x80
+
+#define NON_MASKABLE_INT		0xFF
+
+// TPI Control Masks
+// =================
+
+#define CS_HDMI_RGB         0x00
+#define CS_DVI_RGB          0x03
+/// //#define OUTPT_MODE_DVI        0x00
+#define OUTPT_MODE_HDMI     0x01
+
+#define ENABLE_AND_REPEAT	0xC0
+#define EN_AND_RPT_MPEG		0xC3
+
+// Pixel Repetition Masks
+//=======================
+#define BIT_BUS_24          0x20
+#define BIT_EDGE_RISE       0x10
+
+//Audio Maps
+//==========
+#define BIT_AUDIO_MUTE      0x10
+
+// Input/Output Format Masks
+//==========================
+#define BITS_IN_RGB         0x00
+#define BITS_IN_YCBCR444    0x01
+#define BITS_IN_YCBCR422    0x02
+
+#define BITS_IN_AUTO_RANGE  0x00
+#define BITS_IN_FULL_RANGE  0x04
+#define BITS_IN_LTD_RANGE   0x08
+
+#define BIT_EN_DITHER_10_8  0x40
+#define BIT_EXTENDED_MODE   0x80
+
+#define BITS_OUT_RGB        0x00
+#define BITS_OUT_YCBCR444   0x01
+#define BITS_OUT_YCBCR422   0x02
+
+#define BITS_OUT_AUTO_RANGE 0x00
+#define BITS_OUT_FULL_RANGE 0x04
+#define BITS_OUT_LTD_RANGE  0x08
+
+#define BIT_BT_709          0x10
+
+
+// DE Generator Masks
+//===================
+#define BIT_EN_DE_GEN       0x40
+
+// Embedded Sync Masks
+//====================
+#define BIT_EN_SYNC_EXTRACT 0x40
+
+// Audio Modes
+//============
+#define AUD_PASS_BASIC      0x00
+#define AUD_PASS_ALL        0x01
+#define AUD_DOWN_SAMPLE     0x02
+#define AUD_DO_NOT_CHECK    0x03
+
+#define REFER_TO_STREAM_HDR     0x00
+#define TWO_CHANNELS            0x00
+#define EIGHT_CHANNELS          0x01
+#define AUD_IF_SPDIF            0x40
+#define AUD_IF_I2S              0x80
+#define AUD_IF_DSD				0xC0
+#define AUD_IF_HBR				0x04
+
+#define TWO_CHANNEL_LAYOUT      0x00
+#define EIGHT_CHANNEL_LAYOUT    0x20
+
+
+// Configuration File Constants
+//=============================
+#define CONFIG_DATA_LEN     0x10
+#define IDX_VIDEO_MODE      0x00
+
+// I2C Slave Addresses
+//====================
+//#define TPI_BASE_ADDR       0x72
+#define TPI_BASE_ADDR       0x39
+//#define TX_SLAVE_ADDR       0x72
+#define TX_SLAVE_ADDR       0x39
+//#define CBUS_SLAVE_ADDR     0xC8
+#define CBUS_SLAVE_ADDR     0x64
+//#define HDCP_SLAVE_ADDR     0x74
+#define HDCP_SLAVE_ADDR     0x3a
+//#define EDID_ROM_ADDR       0xA0
+#define EDID_ROM_ADDR       0x50
+//#define EDID_SEG_ADDR	    0x60
+#define EDID_SEG_ADDR	    0x30
+
+// DDC Bus Addresses
+//==================
+#define DDC_BSTATUS_ADDR_L  0x41
+#define DDC_BSTATUS_ADDR_H  0x42
+#define DDC_KSV_FIFO_ADDR   0x43
+#define KSV_ARRAY_SIZE      128
+
+// DDC Bus Bit Masks
+//==================
+#define BIT_DDC_HDMI        0x80
+#define BIT_DDC_REPEATER    0x40
+#define BIT_DDC_FIFO_RDY    0x20
+#define DEVICE_COUNT_MASK   0x7F
+
+// KSV Buffer Size
+//================
+#define DEVICE_COUNT         128    // May be tweaked as needed
+
+// InfoFrames
+//===========
+#define SIZE_AVI_INFOFRAME      0x0E     // including checksum byte
+#define BITS_OUT_FORMAT         0x60    // Y1Y0 field
+
+#define _4_To_3                 0x10    // Aspect ratio - 4:3  in InfoFrame DByte 1
+#define _16_To_9                0x20    // Aspect ratio - 16:9 in InfoFrame DByte 1
+#define SAME_AS_AR              0x08    // R3R2R1R0 - in AVI InfoFrame DByte 2
+
+#define BT_601                  0x40
+#define BT_709                  0x80
+
+#define SIZE_AUDIO_INFOFRAME    0x0F
+
+#define EN_AUDIO_INFOFRAMES         0xC2
+#define TYPE_AUDIO_INFOFRAMES       0x84
+#define AUDIO_INFOFRAMES_VERSION    0x01
+#define AUDIO_INFOFRAMES_LENGTH     0x0A
+
+#define MPEG_INFOFRAME_CODE			0x03
+
+#define TYPE_GBD_INFOFRAME       	0x0A
+
+#define NEXT_FIELD					0x80
+#define GBD_PROFILE					0x00
+#define AFFECTED_GAMUT_SEQ_NUM		0x01
+
+#define ONLY_PACKET					0x30
+#define CURRENT_GAMUT_SEQ_NUM		0x01
+
+
+// FPLL Multipliers:
+//==================
+
+#define X1                      0x01
+
+// 3D Constants
+//=============
+
+#define _3D_STRUC_PRESENT				0x02
+
+// 3D_Stucture Constants
+//=======================
+#define FRAME_PACKING					0x00
+#define FIELD_ALTERNATIVE				0x01
+#define LINE_ALTERNATIVE				0x02
+#define SIDE_BY_SIDE_FULL				0x03
+#define L_PLUS_DEPTH					0x04
+#define L_PLUS_DEPTH_PLUS_GRAPHICS		0x05
+#define SIDE_BY_SIDE_HALF				0x08
+
+// 3D_Ext_Data Constants
+//======================
+#define HORIZ_ODD_LEFT_ODD_RIGHT		0x00
+#define HORIZ_ODD_LEFT_EVEN_RIGHT		0x01
+#define HORIZ_EVEN_LEFT_ODD_RIGHT  		0x02
+#define HORIZ_EVEN_LEFT_EVEN_RIGHT		0x03
+
+#define QUINCUNX_ODD_LEFT_EVEN_RIGHT	0x04
+#define QUINCUNX_ODD_LEFT_ODD_RIGHT		0x05
+#define QUINCUNX_EVEN_LEFT_ODD_RIGHT	0x06
+#define QUINCUNX_EVEN_LEFT_EVEN_RIGHT	0x07
+
+#define NO_3D_SUPPORT					0x0F
diff --git a/drivers/video/hdmi/si9022/SIIEDID.c b/drivers/video/hdmi/si9022/SIIEDID.c
new file mode 100755
index 0000000..21b6498
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIEDID.c
@@ -0,0 +1,963 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#include "SIIdefs.h"
+#include "SIITypeDefs.h"
+#include "SIIConstants.h"
+#include "SIITPI_Regs.h"
+#include "SIITPI_Access.h"
+#include "SIIedid.h"
+
+#ifdef DEV_SUPPORT_EDID
+
+#ifdef CBUS_EDID
+#include "CyclopsCbus.h"
+#endif
+
+// Constants
+//==========
+
+#define EDID_BLOCK_0_OFFSET 0x00
+#define EDID_BLOCK_1_OFFSET 0x80
+#define EDID_BLOCK_SIZE      128
+#define EDID_HDR_NO_OF_FF   0x06
+#define NUM_OF_EXTEN_ADDR   0x7E
+
+#define EDID_TAG_ADDR       0x00
+#define EDID_REV_ADDR       0x01
+#define EDID_TAG_IDX        0x02
+#define LONG_DESCR_PTR_IDX  0x02
+#define MISC_SUPPORT_IDX    0x03
+
+#define ESTABLISHED_TIMING_INDEX        35      // Offset of Established Timing in EDID block
+#define NUM_OF_STANDARD_TIMINGS          8
+#define STANDARD_TIMING_OFFSET          38
+#define LONG_DESCR_LEN                  18
+#define NUM_OF_DETAILED_DESCRIPTORS      4
+
+#define DETAILED_TIMING_OFFSET        0x36
+
+// Offsets within a Long Descriptors Block
+//========================================
+#define PIX_CLK_OFFSET                   0
+#define H_ACTIVE_OFFSET                  2
+#define H_BLANKING_OFFSET                3
+#define V_ACTIVE_OFFSET                  5
+#define V_BLANKING_OFFSET                6
+#define H_SYNC_OFFSET                    8
+#define H_SYNC_PW_OFFSET                 9
+#define V_SYNC_OFFSET                   10
+#define V_SYNC_PW_OFFSET                10
+#define H_IMAGE_SIZE_OFFSET             12
+#define V_IMAGE_SIZE_OFFSET             13
+#define H_BORDER_OFFSET                 15
+#define V_BORDER_OFFSET                 16
+#define FLAGS_OFFSET                    17
+
+#define AR16_10                          0
+#define AR4_3                            1
+#define AR5_4                            2
+#define AR16_9                           3
+
+// Data Block Tag Codes
+//=====================
+#define AUDIO_D_BLOCK       0x01
+#define VIDEO_D_BLOCK       0x02
+#define VENDOR_SPEC_D_BLOCK 0x03
+#define SPKR_ALLOC_D_BLOCK  0x04
+#define USE_EXTENDED_TAG    0x07
+
+// Extended Data Block Tag Codes
+//==============================
+#define COLORIMETRY_D_BLOCK 0x05
+
+#define HDMI_SIGNATURE_LEN  0x03
+
+#define CEC_PHYS_ADDR_LEN   0x02
+#define EDID_EXTENSION_TAG  0x02
+#define EDID_REV_THREE      0x03
+#define EDID_DATA_START     0x04
+
+#define EDID_BLOCK_0        0x00
+#define EDID_BLOCK_2_3      0x01
+
+#define VIDEO_CAPABILITY_D_BLOCK 0x00
+
+
+//#define ReadBlockEDID(a,b,c)            I2C_ReadBlock(EDID_ROM_ADDR, a, c, b)
+#define ReadBlockEDID(a,b,c)            if(!I2C_ReadBlock(EDID_ROM_ADDR, a, c, b)) {return EDID_DDC_NO_RESPONSE;}
+#define ReadSegmentBlockEDID(a,b,c,d)   I2C_ReadSegmentBlock(EDID_ROM_ADDR, a, b, d, c)
+
+Type_EDID_Descriptors EDID_Data;        // holds parsed EDID data needed by the FW
+unsigned char EDID_TempData[EDID_BLOCK_SIZE + 3];
+
+bool edidDataValid;
+
+static unsigned char ParseEDID (void);
+
+static bool DoEDID_Checksum(unsigned char *);
+static bool CheckEDID_Header(unsigned char *);
+static void ParseBlock_0_TimingDescripors(unsigned char *);
+static unsigned char Parse861Extensions(unsigned char);
+static unsigned char Parse861ShortDescriptors(unsigned char *);
+static unsigned char Parse861LongDescriptors(unsigned char *);
+
+static void ParseEstablishedTiming(unsigned char *);
+static void ParseStandardTiming(unsigned char *);
+static bool ParseDetailedTiming(unsigned char *, unsigned char, unsigned char);
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   unsigned char ParseEDID()
+//
+// PURPOSE      :   Extract sink properties from its EDID file and save them in
+//                  global structure EDID_Data.
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   EDID_Data
+//
+// RETURNS      :   A unsigned char error code to indicates success or error type.
+//
+// NOTE         :   Fields that are not supported by the 9022/4 (such as deep
+//                  color) were not parsed.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+unsigned char ParseEDID()
+{
+    unsigned char i,j,k;
+    unsigned char NumOfExtensions;
+
+        #ifdef CBUS_EDID
+        CyclopsReadEdid01(EDID_BLOCK_0_OFFSET, EDID_BLOCK_SIZE);
+        #else
+        ReadBlockEDID(EDID_BLOCK_0_OFFSET, EDID_BLOCK_SIZE, EDID_TempData);    // read first 128 unsigned chars of EDID ROM
+        #endif
+
+        TPI_EDID_PRINT(("\n"));
+        TPI_EDID_PRINT(("EDID DATA (Segment = 0 Block = 0 Offset = %d):\n", (int) EDID_BLOCK_0_OFFSET));
+        for (j=0, i=0; j<128; j++)
+        {
+                k = EDID_TempData[j];
+        TPI_EDID_PRINT(("%2.2X ", (int) k));
+        i++;
+
+        if (i == 0x10)
+        {
+                TPI_EDID_PRINT(("\n"));
+                i = 0;
+        }
+        }
+        TPI_EDID_PRINT(("\n"));
+
+        if (!DoEDID_Checksum(EDID_TempData))
+        {
+        TPI_DEBUG_PRINT(("EDID -> Checksum Error\n"));
+        return EDID_CHECKSUM_ERROR;                                                                     // non-zero EDID checksum
+        }
+
+        if (!CheckEDID_Header(EDID_TempData))                                                                   // first 8 unsigned chars of EDID must be {0, FF, FF, FF, FF, FF, FF, 0}
+        {
+        TPI_DEBUG_PRINT(("EDID -> Incorrect Header\n"));
+        return EDID_INCORRECT_HEADER;
+        }
+
+        ParseBlock_0_TimingDescripors(EDID_TempData);                                                   // Parse EDID Block #0 Desctiptors
+
+        NumOfExtensions = EDID_TempData[NUM_OF_EXTEN_ADDR];                                     // read # of extensions from offset 0x7E of block 0
+        TPI_EDID_PRINT(("EDID -> No 861 Extensions = %d\n", (int) NumOfExtensions));
+
+        if (!NumOfExtensions)
+        {
+        return EDID_NO_861_EXTENSIONS;
+        }
+
+        return Parse861Extensions(NumOfExtensions);                                             // Parse 861 Extensions (short and long descriptors);
+}
+
+
+unsigned char DoEdidRead (void) {
+
+	unsigned char SysCtrlReg;
+	unsigned char Result;
+
+	if (edidDataValid == FALSE)
+	{
+		if (GetDDC_Access(&SysCtrlReg))
+		{
+			Result = ParseEDID();
+			if (Result != EDID_OK)
+			{
+				if (Result == EDID_NO_861_EXTENSIONS)
+				{
+					EDID_Data.HDMI_Sink = FALSE;
+					TPI_DEBUG_PRINT (("EDID -> No 861 Extensions. Handle as DVI Sink\n"));
+				}
+				else
+				{
+					TPI_DEBUG_PRINT (("EDID -> Parse FAILED\n"));
+					EDID_Data.HDMI_Sink = TRUE;	
+					EDID_Data.YCbCr_4_2_2 = FALSE;
+					EDID_Data.YCbCr_4_4_4 = FALSE;
+					edidDataValid = TRUE;
+				}
+			}
+			else
+			{
+				TPI_DEBUG_PRINT (("EDID -> Parse OK\n"));
+			}
+
+			if (!ReleaseDDC(SysCtrlReg))              // Host must release DDC bus once it is done reading EDID
+			{
+				TPI_DEBUG_PRINT (("EDID -> DDC bus release failed\n"));
+				return EDID_DDC_BUS_RELEASE_FAILURE;
+			}
+		}
+		else
+		{
+			TPI_DEBUG_PRINT (("EDID -> DDC bus request failed\n"));
+			EDID_Data.HDMI_Sink = TRUE;	
+			EDID_Data.YCbCr_4_2_2 = FALSE;
+			EDID_Data.YCbCr_4_4_4 = FALSE;
+			edidDataValid = TRUE;
+			return EDID_DDC_BUS_REQ_FAILURE;
+		}
+
+		edidDataValid = TRUE;
+	}
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   ParseBlock_0_TimingDescripors()
+//
+// PURPOSE      :   Parse EDID Block 0 timing descriptors per EEDID 1.3
+//                  standard. printf() values to screen.
+//
+// INPUT PARAMS :   Pointer to the 128 unsigned char array where the data read from EDID
+//                  Block0 is stored.
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   Void
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static void ParseBlock_0_TimingDescripors(unsigned char *Data)
+{
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+    unsigned char i;
+    unsigned char Offset;
+
+    ParseEstablishedTiming(Data);
+    ParseStandardTiming(Data);
+
+
+    for (i = 0; i < NUM_OF_DETAILED_DESCRIPTORS; i++)
+    {
+        Offset = DETAILED_TIMING_OFFSET + (LONG_DESCR_LEN * i);
+        ParseDetailedTiming(Data, Offset, EDID_BLOCK_0);
+    }
+#else
+        Data = Data;    // Dummy usage to suppress warning
+#endif
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   unsigned char Parse861Extensions()
+//
+// PURPOSE      :   Parse CEA-861 extensions from EDID ROM (EDID blocks beyond
+//                  block #0). Save short descriptors in global structure
+//                  EDID_Data. printf() long descriptors to the screen.
+//
+// INPUT PARAMS :   The number of extensions in the EDID being parsed
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   EDID_PARSED_OK if EDID parsed correctly. Error code if failed.
+//
+// NOTE         :   Fields that are not supported by the 9022/4 (such as deep
+//                  color) were not parsed.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static unsigned char Parse861Extensions(unsigned char NumOfExtensions)
+{
+    unsigned char i,j,k;
+
+    unsigned char ErrCode;
+
+    unsigned char V_DescriptorIndex = 0;
+    unsigned char A_DescriptorIndex = 0;
+
+    unsigned char Segment = 0;
+        unsigned char Block = 0;
+    unsigned char Offset = 0;
+
+        EDID_Data.HDMI_Sink = FALSE;
+
+        do
+    {
+                Block++;
+
+        Offset = 0;
+        if ((Block % 2) > 0)
+        {
+            Offset = EDID_BLOCK_SIZE;
+        }
+
+        Segment = (unsigned char) (Block / 2);
+
+                if (Block == 1)
+                {
+                        #ifdef CBUS_EDID
+                        CyclopsReadEdid01(EDID_BLOCK_1_OFFSET, EDID_BLOCK_SIZE);
+                        #else
+                        ReadBlockEDID(EDID_BLOCK_1_OFFSET, EDID_BLOCK_SIZE, EDID_TempData);    // read first 128 unsigned chars of EDID ROM
+                        #endif
+                }
+                else
+                {
+                        #ifdef CBUS_EDID
+                        CyclopsReadEdid23(Offset, EDID_BLOCK_SIZE);
+                        #else
+                        ReadSegmentBlockEDID(Segment, Offset, EDID_BLOCK_SIZE, EDID_TempData);     // read next 128 unsigned chars of EDID ROM
+                        #endif
+                }
+
+                TPI_EDID_PRINT(("\n"));
+        TPI_EDID_PRINT(("EDID DATA (Segment = %d Block = %d Offset = %d):\n", (int) Segment, (int) Block, (int) Offset));
+        for (j=0, i=0; j<128; j++)
+        {
+            k = EDID_TempData[j];
+            TPI_EDID_PRINT(("%2.2X ", (int) k));
+            i++;
+
+            if (i == 0x10)
+            {
+                TPI_EDID_PRINT(("\n"));
+                i = 0;
+            }
+        }
+                TPI_EDID_PRINT(("\n"));
+
+                if ((NumOfExtensions > 1) && (Block == 1))
+                {
+                        continue;
+                }
+
+        ErrCode = Parse861ShortDescriptors(EDID_TempData);
+            if (ErrCode != EDID_SHORT_DESCRIPTORS_OK)
+            {
+                return ErrCode;
+            }
+
+        ErrCode = Parse861LongDescriptors(EDID_TempData);
+        if (ErrCode != EDID_LONG_DESCRIPTORS_OK)
+        {
+            return ErrCode;
+        }
+        } while (Block < NumOfExtensions);
+
+    return EDID_OK;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   unsigned char Parse861ShortDescriptors()
+//
+// PURPOSE      :   Parse CEA-861 extension short descriptors of the EDID block
+//                  passed as a parameter and save them in global structure
+//                  EDID_Data.
+//
+// INPUT PARAMS :   A pointer to the EDID 861 Extension block being parsed.
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   EDID_Data
+//
+// RETURNS      :   EDID_PARSED_OK if EDID parsed correctly. Error code if failed.
+//
+// NOTE         :   Fields that are not supported by the 9022/4 (such as deep
+//                  color) are not parsed.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static unsigned char Parse861ShortDescriptors(unsigned char *Data)
+{
+    unsigned char LongDescriptorOffset;
+    unsigned char DataBlockLength;
+    unsigned char DataIndex;
+    unsigned char ExtendedTagCode;
+	unsigned char VSDB_BaseOffset = 0;
+
+    unsigned char V_DescriptorIndex = 0;  // static to support more than one extension
+    unsigned char A_DescriptorIndex = 0;  // static to support more than one extension
+
+    unsigned char TagCode;
+
+    unsigned char i;
+    unsigned char j;
+
+    if (Data[EDID_TAG_ADDR] != EDID_EXTENSION_TAG)
+    {
+        TPI_EDID_PRINT(("EDID -> Extension Tag Error\n"));
+        return EDID_EXT_TAG_ERROR;
+    }
+
+    if (Data[EDID_REV_ADDR] != EDID_REV_THREE)
+    {
+        TPI_EDID_PRINT(("EDID -> Revision Error\n"));
+        return EDID_REV_ADDR_ERROR;
+    }
+
+    LongDescriptorOffset = Data[LONG_DESCR_PTR_IDX];    // block offset where long descriptors start
+
+    EDID_Data.UnderScan = ((Data[MISC_SUPPORT_IDX]) >> 7) & LSBIT;  // unsigned char #3 of CEA extension version 3
+    EDID_Data.BasicAudio = ((Data[MISC_SUPPORT_IDX]) >> 6) & LSBIT;
+    EDID_Data.YCbCr_4_4_4 = ((Data[MISC_SUPPORT_IDX]) >> 5) & LSBIT;
+    EDID_Data.YCbCr_4_2_2 = ((Data[MISC_SUPPORT_IDX]) >> 4) & LSBIT;
+
+    DataIndex = EDID_DATA_START;            // 4
+
+    while (DataIndex < LongDescriptorOffset)
+    {
+        TagCode = (Data[DataIndex] >> 5) & THREE_LSBITS;
+        DataBlockLength = Data[DataIndex++] & FIVE_LSBITS;
+        if ((DataIndex + DataBlockLength) > LongDescriptorOffset)
+        {
+            TPI_EDID_PRINT(("EDID -> V Descriptor Overflow\n"));
+            return EDID_V_DESCR_OVERFLOW;
+        }
+
+        i = 0;                                  // num of short video descriptors in current data block
+
+        switch (TagCode)
+        {
+            case VIDEO_D_BLOCK:
+                while ((i < DataBlockLength) && (i < MAX_V_DESCRIPTORS))        // each SVD is 1 unsigned char long
+                {
+                    EDID_Data.VideoDescriptor[V_DescriptorIndex++] = Data[DataIndex++];
+                    i++;
+                }
+                DataIndex += DataBlockLength - i;   // if there are more STDs than MAX_V_DESCRIPTORS, skip the last ones. Update DataIndex
+
+                TPI_EDID_PRINT(("EDID -> Short Descriptor Video Block\n"));
+                break;
+
+            case AUDIO_D_BLOCK:
+                while (i < DataBlockLength/3)       // each SAD is 3 unsigned chars long
+                {
+                    j = 0;
+                    while (j < AUDIO_DESCR_SIZE)    // 3
+                    {
+                        EDID_Data.AudioDescriptor[A_DescriptorIndex][j++] = Data[DataIndex++];
+                    }
+                    A_DescriptorIndex++;
+                    i++;
+                }
+                TPI_EDID_PRINT(("EDID -> Short Descriptor Audio Block\n"));
+                break;
+
+            case  SPKR_ALLOC_D_BLOCK:
+                EDID_Data.SpkrAlloc[i++] = Data[DataIndex++];       // although 3 unsigned chars are assigned to Speaker Allocation, only
+                DataIndex += 2;                                     // the first one carries information, so the next two are ignored by this code.
+                TPI_EDID_PRINT(("EDID -> Short Descriptor Speaker Allocation Block\n"));
+                break;
+
+            case USE_EXTENDED_TAG:
+                ExtendedTagCode = Data[DataIndex++];
+
+                switch (ExtendedTagCode)
+                {
+                    case VIDEO_CAPABILITY_D_BLOCK:
+
+                                TPI_EDID_PRINT(("EDID -> Short Descriptor Video Capability Block\n"));
+
+                                                // TO BE ADDED HERE: Save "video capability" parameters in EDID_Data data structure
+                                                // Need to modify that structure definition
+                                                // In the meantime: just increment DataIndex by 1
+
+                                                DataIndex += 1;    // replace with reading and saving the proper data per CEA-861 sec. 7.5.6 while incrementing DataIndex
+
+                                                break;
+
+
+                    case COLORIMETRY_D_BLOCK:
+                        EDID_Data.ColorimetrySupportFlags = Data[DataIndex++] & BITS_1_0;
+                        EDID_Data.MetadataProfile = Data[DataIndex++] & BITS_2_1_0;
+
+                                TPI_EDID_PRINT(("EDID -> Short Descriptor Colorimetry Block\n"));
+
+                                                break;
+                }
+                                break;
+
+            case VENDOR_SPEC_D_BLOCK:
+                VSDB_BaseOffset = DataIndex - 1;
+
+                if ((Data[DataIndex++] == 0x03) &&    // check if sink is HDMI compatible
+                    (Data[DataIndex++] == 0x0C) &&
+                    (Data[DataIndex++] == 0x00))
+
+                    EDID_Data.HDMI_Sink = TRUE;
+                else
+                    EDID_Data.HDMI_Sink = FALSE;
+
+                EDID_Data.CEC_A_B = Data[DataIndex++];  // CEC Physical address
+                EDID_Data.CEC_C_D = Data[DataIndex++];
+
+                if ((DataIndex + 7) > VSDB_BaseOffset + DataBlockLength)        // Offset of 3D_Present bit in VSDB
+                        EDID_Data._3D_Supported = FALSE;
+                else if (Data[DataIndex + 7] >> 7)
+                        EDID_Data._3D_Supported = TRUE;
+                else
+                        EDID_Data._3D_Supported = FALSE;
+
+                DataIndex += DataBlockLength - HDMI_SIGNATURE_LEN - CEC_PHYS_ADDR_LEN; // Point to start of next block
+                TPI_EDID_PRINT(("EDID -> Short Descriptor Vendor Block\n"));
+                TPI_EDID_PRINT(("\n"));
+                break;
+
+            default:
+                TPI_EDID_PRINT(("EDID -> Unknown Tag Code\n"));
+                return EDID_UNKNOWN_TAG_CODE;
+
+        }                   // End, Switch statement
+    }                       // End, while (DataIndex < LongDescriptorOffset) statement
+
+    return EDID_SHORT_DESCRIPTORS_OK;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   unsigned char Parse861LongDescriptors()
+//
+// PURPOSE      :   Parse CEA-861 extension long descriptors of the EDID block
+//                  passed as a parameter and printf() them to the screen.
+//                  EDID_Data.
+//
+// INPUT PARAMS :   A pointer to the EDID block being parsed
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   An error code if no long descriptors found; EDID_PARSED_OK
+//                  if descriptors found.
+//
+//////////////////////////////////////////////////////////////////////////////
+static unsigned char Parse861LongDescriptors(unsigned char *Data)
+{
+    unsigned char LongDescriptorsOffset;
+    unsigned char DescriptorNum = 1;
+
+    LongDescriptorsOffset = Data[LONG_DESCR_PTR_IDX];   // EDID block offset 2 holds the offset
+
+    if (!LongDescriptorsOffset)                         // per CEA-861-D, table 27
+    {
+        TPI_DEBUG_PRINT(("EDID -> No Detailed Descriptors\n"));
+        return EDID_NO_DETAILED_DESCRIPTORS;
+    }
+
+    // of the 1st 18-unsigned char descriptor
+    while (LongDescriptorsOffset + LONG_DESCR_LEN < EDID_BLOCK_SIZE)
+    {
+//        TPI_EDID_PRINT(("Parse Results - CEA-861 Extension Block #%d, Long Descriptor #%d:\n", (int) BlockNum, (int) DescriptorNum));
+        TPI_EDID_PRINT(("===============================================================\n"));
+
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+        if (!ParseDetailedTiming(Data, LongDescriptorsOffset, EDID_BLOCK_2_3))
+                        break;
+#endif
+        LongDescriptorsOffset +=  LONG_DESCR_LEN;
+        DescriptorNum++;
+    }
+
+    return EDID_LONG_DESCRIPTORS_OK;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   bool DoEDID_Checksum()
+//
+// PURPOSE      :   Calculte checksum of the 128 unsigned char block pointed to by the
+//                  pointer passed as parameter
+//
+// INPUT PARAMS :   Pointer to a 128 unsigned char block whose checksum needs to be
+//                  calculated
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE if chcksum is 0. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+bool DoEDID_Checksum(unsigned char *Block)
+{
+    unsigned char i;
+    unsigned char CheckSum = 0;
+
+    for (i = 0; i < EDID_BLOCK_SIZE; i++)
+        CheckSum += Block[i];
+
+    if (CheckSum)
+        return FALSE;
+
+    return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   bool CheckEDID_Header()
+//
+// PURPOSE      :   Checks if EDID header is correct per VESA E-EDID standard
+//
+// INPUT PARAMS :   Pointer to 1st EDID block
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE if Header is correct. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static bool CheckEDID_Header(unsigned char *Block)
+{
+    unsigned char i = 0;
+
+    if (Block[i])               // unsigned char 0 must be 0
+        return FALSE;
+
+    for (i = 1; i < 1 + EDID_HDR_NO_OF_FF; i++)
+    {
+        if(Block[i] != 0xFF)    // unsigned chars [1..6] must be 0xFF
+            return FALSE;
+    }
+
+    if (Block[i])               // unsigned char 7 must be 0
+        return FALSE;
+
+    return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   ParseEstablishedTiming()
+//
+// PURPOSE      :   Parse the established timing section of EDID Block 0 and
+//                  print their decoded meaning to the screen.
+//
+// INPUT PARAMS :   Pointer to the array where the data read from EDID
+//                  Block0 is stored.
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   Void
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+static void ParseEstablishedTiming(unsigned char *Data)
+{
+    TPI_EDID_PRINT(("Parsing Established Timing:\n"));
+    TPI_EDID_PRINT(("===========================\n"));
+
+
+    // Parse Established Timing Byte #0
+
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_7)
+        TPI_EDID_PRINT(("720 x 400 @ 70Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_6)
+        TPI_EDID_PRINT(("720 x 400 @ 88Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_5)
+        TPI_EDID_PRINT(("640 x 480 @ 60Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_4)
+        TPI_EDID_PRINT(("640 x 480 @ 67Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_3)
+        TPI_EDID_PRINT(("640 x 480 @ 72Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_2)
+        TPI_EDID_PRINT(("640 x 480 @ 75Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_1)
+        TPI_EDID_PRINT(("800 x 600 @ 56Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX] & BIT_0)
+        TPI_EDID_PRINT(("800 x 400 @ 60Hz\n"));
+
+    // Parse Established Timing Byte #1:
+
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_7)
+        TPI_EDID_PRINT(("800 x 600 @ 72Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_6)
+        TPI_EDID_PRINT(("800 x 600 @ 75Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_5)
+        TPI_EDID_PRINT(("832 x 624 @ 75Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_4)
+        TPI_EDID_PRINT(("1024 x 768 @ 87Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_3)
+        TPI_EDID_PRINT(("1024 x 768 @ 60Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_2)
+        TPI_EDID_PRINT(("1024 x 768 @ 70Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_1)
+        TPI_EDID_PRINT(("1024 x 768 @ 75Hz\n"));
+    if(Data[ESTABLISHED_TIMING_INDEX + 1]  & BIT_0)
+        TPI_EDID_PRINT(("1280 x 1024 @ 75Hz\n"));
+
+    // Parse Established Timing Byte #2:
+
+    if(Data[ESTABLISHED_TIMING_INDEX + 2] & 0x80)
+        TPI_EDID_PRINT(("1152 x 870 @ 75Hz\n"));
+
+    if((!Data[0])&&(!Data[ESTABLISHED_TIMING_INDEX + 1]  )&&(!Data[2]))
+        TPI_EDID_PRINT(("No established video modes\n"));
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   ParseStandardTiming()
+//
+// PURPOSE      :   Parse the standard timing section of EDID Block 0 and
+//                  print their decoded meaning to the screen.
+//
+// INPUT PARAMS :   Pointer to the array where the data read from EDID
+//                  Block0 is stored.
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   Void
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static void ParseStandardTiming(unsigned char *Data)
+{
+    unsigned char i;
+    unsigned char AR_Code;
+
+    TPI_EDID_PRINT(("Parsing Standard Timing:\n"));
+    TPI_EDID_PRINT(("========================\n"));
+
+    for (i = 0; i < NUM_OF_STANDARD_TIMINGS; i += 2)
+    {
+        if ((Data[STANDARD_TIMING_OFFSET + i] == 0x01) && ((Data[STANDARD_TIMING_OFFSET + i +1]) == 1))
+        {
+            TPI_EDID_PRINT(("Standard Timing Undefined\n")); // per VESA EDID standard, Release A, Revision 1, February 9, 2000, Sec. 3.9
+                }
+        else
+        {
+            TPI_EDID_PRINT(("Horizontal Active pixels: %i\n", (int)((Data[STANDARD_TIMING_OFFSET + i] + 31)*8)));    // per VESA EDID standard, Release A, Revision 1, February 9, 2000, Table 3.15
+
+            AR_Code = (Data[STANDARD_TIMING_OFFSET + i +1] & TWO_MSBITS) >> 6;
+            TPI_EDID_PRINT(("Aspect Ratio: "));
+
+            switch(AR_Code)
+            {
+                case AR16_10:
+                    TPI_EDID_PRINT(("16:10\n"));
+                    break;
+
+                case AR4_3:
+                    TPI_EDID_PRINT(("4:3\n"));
+                    break;
+
+                case AR5_4:
+                    TPI_EDID_PRINT(("5:4\n"));
+                    break;
+
+                case AR16_9:
+                    TPI_EDID_PRINT(("16:9\n"));
+                    break;
+            }
+        }
+    }
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   ParseDetailedTiming()
+//
+// PURPOSE      :   Parse the detailed timing section of EDID Block 0 and
+//                  print their decoded meaning to the screen.
+//
+// INPUT PARAMS :   Pointer to the array where the data read from EDID
+//                  Block0 is stored.
+//
+//                  Offset to the beginning of the Detailed Timing Descriptor
+//                  data.
+//
+//                                      Block indicator to distinguish between block #0 and blocks
+//                                      #2, #3
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   Void
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static bool ParseDetailedTiming(unsigned char *Data, unsigned char DetailedTimingOffset, unsigned char Block)
+{
+        unsigned char TmpByte;
+        unsigned char i;
+        unsigned int TmpWord;
+
+        TmpWord = Data[DetailedTimingOffset + PIX_CLK_OFFSET] +
+                    256 * Data[DetailedTimingOffset + PIX_CLK_OFFSET + 1];
+
+        if (TmpWord == 0x00)            // 18 unsigned char partition is used as either for Monitor Name or for Monitor Range Limits or it is unused
+        {
+                if (Block == EDID_BLOCK_0)      // if called from Block #0 and first 2 unsigned chars are 0 => either Monitor Name or for Monitor Range Limits
+            {
+                if (Data[DetailedTimingOffset + 3] == 0xFC) // these 13 unsigned chars are ASCII coded monitor name
+                {
+                                        TPI_EDID_PRINT(("Monitor Name: "));
+
+                        for (i = 0; i < 13; i++)
+                                        {
+                        TPI_EDID_PRINT(("%c", Data[DetailedTimingOffset + 5 + i])); // Display monitor name on SiIMon
+                                        }
+                                        TPI_EDID_PRINT(("\n"));
+                }
+
+                        else if (Data[DetailedTimingOffset + 3] == 0xFD) // these 13 unsigned chars contain Monitor Range limits, binary coded
+                        {
+                                TPI_EDID_PRINT(("Monitor Range Limits:\n\n"));
+
+                                i = 0;
+                                TPI_EDID_PRINT(("Min Vertical Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+                        TPI_EDID_PRINT(("Max Vertical Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+                                TPI_EDID_PRINT(("Min Horizontal Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+                                TPI_EDID_PRINT(("Max Horizontal Rate in Hz: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+                                TPI_EDID_PRINT(("Max Supported pixel clock rate in MHz/10: %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+                        TPI_EDID_PRINT(("Tag for secondary timing formula (00h=not used): %d\n", (int) Data[DetailedTimingOffset + 5 + i++])); //
+                                TPI_EDID_PRINT(("Min Vertical Rate in Hz %d\n", (int) Data[DetailedTimingOffset + 5 + i])); //
+                                        TPI_EDID_PRINT(("\n"));
+                        }
+                        }
+
+                else if (Block == EDID_BLOCK_2_3)                          // if called from block #2 or #3 and first 2 unsigned chars are 0x00 (padding) then this
+                {                                                                                          // descriptor partition is not used and parsing should be stopped
+                                TPI_EDID_PRINT(("No More Detailed descriptors in this block\n"));
+                                TPI_EDID_PRINT(("\n"));
+                                return FALSE;
+                        }
+                }
+
+                else                                            // first 2 unsigned chars are not 0 => this is a detailed timing descriptor from either block
+                {
+                        if((Block == EDID_BLOCK_0) && (DetailedTimingOffset == 0x36))
+                        {
+                        TPI_EDID_PRINT(("\n\n\nParse Results, EDID Block #0, Detailed Descriptor Number 1:\n"));
+                                TPI_EDID_PRINT(("===========================================================\n\n"));
+                        }
+                        else if((Block == EDID_BLOCK_0) && (DetailedTimingOffset == 0x48))
+                {
+                        TPI_EDID_PRINT(("\n\n\nParse Results, EDID Block #0, Detailed Descriptor Number 2:\n"));
+                                TPI_EDID_PRINT(("===========================================================\n\n"));
+                        }
+
+            TPI_EDID_PRINT(("Pixel Clock (MHz * 100): %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + H_ACTIVE_OFFSET] +
+                    256 * ((Data[DetailedTimingOffset + H_ACTIVE_OFFSET + 2] >> 4) & FOUR_LSBITS);
+            TPI_EDID_PRINT(("Horizontal Active Pixels: %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + H_BLANKING_OFFSET] +
+                    256 * (Data[DetailedTimingOffset + H_BLANKING_OFFSET + 1] & FOUR_LSBITS);
+            TPI_EDID_PRINT(("Horizontal Blanking (Pixels): %d\n", (int)TmpWord));
+
+            TmpWord = (Data[DetailedTimingOffset + V_ACTIVE_OFFSET] )+
+                    256 * ((Data[DetailedTimingOffset + (V_ACTIVE_OFFSET) + 2] >> 4) & FOUR_LSBITS);
+            TPI_EDID_PRINT(("Vertical Active (Lines): %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + V_BLANKING_OFFSET] +
+                    256 * (Data[DetailedTimingOffset + V_BLANKING_OFFSET + 1] & LOW_NIBBLE);
+            TPI_EDID_PRINT(("Vertical Blanking (Lines): %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + H_SYNC_OFFSET] +
+                    256 * ((Data[DetailedTimingOffset + (H_SYNC_OFFSET + 3)] >> 6) & TWO_LSBITS);
+            TPI_EDID_PRINT(("Horizontal Sync Offset (Pixels): %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + H_SYNC_PW_OFFSET] +
+                    256 * ((Data[DetailedTimingOffset + (H_SYNC_PW_OFFSET + 2)] >> 4) & TWO_LSBITS);
+            TPI_EDID_PRINT(("Horizontal Sync Pulse Width (Pixels): %d\n", (int)TmpWord));
+
+            TmpWord = (Data[DetailedTimingOffset + V_SYNC_OFFSET] >> 4) & FOUR_LSBITS +
+                    256 * ((Data[DetailedTimingOffset + (V_SYNC_OFFSET + 1)] >> 2) & TWO_LSBITS);
+            TPI_EDID_PRINT(("Vertical Sync Offset (Lines): %d\n", (int)TmpWord));
+
+            TmpWord = (Data[DetailedTimingOffset + V_SYNC_PW_OFFSET]) & FOUR_LSBITS +
+                    256 * (Data[DetailedTimingOffset + (V_SYNC_PW_OFFSET + 1)] & TWO_LSBITS);
+            TPI_EDID_PRINT(("Vertical Sync Pulse Width (Lines): %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + H_IMAGE_SIZE_OFFSET] +
+                    256 * (((Data[DetailedTimingOffset + (H_IMAGE_SIZE_OFFSET + 2)]) >> 4) & FOUR_LSBITS);
+            TPI_EDID_PRINT(("Horizontal Image Size (mm): %d\n", (int)TmpWord));
+
+            TmpWord = Data[DetailedTimingOffset + V_IMAGE_SIZE_OFFSET] +
+                    256 * (Data[DetailedTimingOffset + (V_IMAGE_SIZE_OFFSET + 1)] & FOUR_LSBITS);
+            TPI_EDID_PRINT(("Vertical Image Size (mm): %d\n", (int)TmpWord));
+
+            TmpByte = Data[DetailedTimingOffset + H_BORDER_OFFSET];
+            TPI_EDID_PRINT(("Horizontal Border (Pixels): %d\n", (int)TmpByte));
+
+            TmpByte = Data[DetailedTimingOffset + V_BORDER_OFFSET];
+            TPI_EDID_PRINT(("Vertical Border (Lines): %d\n", (int)TmpByte));
+
+            TmpByte = Data[DetailedTimingOffset + FLAGS_OFFSET];
+            if (TmpByte & BIT_7)
+                TPI_EDID_PRINT(("Interlaced\n"));
+            else
+                TPI_EDID_PRINT(("Non-Interlaced\n"));
+
+            if (!(TmpByte & BIT_5) && !(TmpByte & BIT_6))
+                TPI_EDID_PRINT(("Normal Display, No Stereo\n"));
+            else
+                TPI_EDID_PRINT(("Refer to VESA E-EDID Release A, Revision 1, table 3.17\n"));
+
+            if (!(TmpByte & BIT_3) && !(TmpByte & BIT_4))
+                TPI_EDID_PRINT(("Analog Composite\n"));
+            if ((TmpByte & BIT_3) && !(TmpByte & BIT_4))
+                TPI_EDID_PRINT(("Bipolar Analog Composite\n"));
+            else if (!(TmpByte & BIT_3) && (TmpByte & BIT_4))
+                TPI_EDID_PRINT(("Digital Composite\n"));
+
+            else if ((TmpByte & BIT_3) && (TmpByte & BIT_4))
+                TPI_EDID_PRINT(("Digital Separate\n"));
+
+                        TPI_EDID_PRINT(("\n"));
+        }
+        return TRUE;
+}
+#endif
+
+#endif
+
diff --git a/drivers/video/hdmi/si9022/SIIHDCP.c b/drivers/video/hdmi/si9022/SIIHDCP.c
new file mode 100755
index 0000000..0304a08
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIHDCP.c
@@ -0,0 +1,464 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#include "SIIdefs.h"
+#include "SIITypeDefs.h"
+//#include "AMF_Lib.h"
+#include "SIITPI_Regs.h"
+#include "SIIConstants.h"
+#include "Externals.h"
+#include "SIIMacros.h"
+#include "SIITPI_Access.h"
+#include "SIITPI.h"
+#include "SIIHDCP.h"
+#include "SIIAV_Config.h"
+
+#ifdef DEV_SUPPORT_HDCP
+
+#define AKSV_SIZE              5
+#define NUM_OF_ONES_IN_KSV    20
+
+bool HDCP_TxSupports;
+bool HDCP_Started;
+unsigned char HDCP_LinkProtectionLevel;
+
+static bool AreAKSV_OK(void);
+
+#ifdef CHECKREVOCATIONLIST
+static bool CheckRevocationList(void);
+#endif
+
+#ifdef READKSV
+static bool GetKSV(void);
+static bool IsRepeater(void);
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   HDCP_Init()
+//
+// PURPOSE      :   Tests Tx and Rx support of HDCP. If found, checks if
+//                  and attempts to set the security level accordingly.
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :	HDCP_TxSupports - initialized to FALSE, set to TRUE if supported by this device
+//					HDCP_Started - initialized to FALSE;
+//					HDCP_LinkProtectionLevel - initialized to (EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE);
+//
+// RETURNS      :   None
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void HDCP_Init (void) {
+
+	TPI_TRACE_PRINT((">>HDCP_Init()\n"));
+
+	HDCP_TxSupports = FALSE;
+	HDCP_Started = FALSE;
+	HDCP_LinkProtectionLevel = EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE;
+
+	// This is TX-related... need only be done once.
+    if (!IsHDCP_Supported())
+    {
+		TPI_DEBUG_PRINT(("HDCP -> TX does not support HDCP\n"));
+		return;
+	}
+
+	// This is TX-related... need only be done once.
+    if (!AreAKSV_OK())
+    {
+        TPI_DEBUG_PRINT(("HDCP -> Illegal AKSV\n"));
+        return;
+    }
+
+	// Both conditions above must pass or authentication will never be attempted. 
+	TPI_DEBUG_PRINT(("HDCP -> Supported by TX\n"));
+	HDCP_TxSupports = TRUE;
+}
+
+
+void HDCP_CheckStatus (unsigned char InterruptStatusImage) {
+
+	unsigned char QueryData;
+	unsigned char LinkStatus;
+	unsigned char RegImage;
+	unsigned char NewLinkProtectionLevel;
+#ifdef READKSV
+	unsigned char RiCnt;
+#endif
+
+	if (HDCP_TxSupports == TRUE)
+	{
+		if ((HDCP_LinkProtectionLevel == (EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE)) && (HDCP_Started == FALSE))
+		{
+			QueryData = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+
+			if (QueryData & PROTECTION_TYPE_MASK)   // Is HDCP avaialable
+			{
+				HDCP_On();
+			}
+		}
+
+		// Check if Link Status has changed:
+		if (InterruptStatusImage & SECURITY_CHANGE_EVENT)
+		{
+			TPI_DEBUG_PRINT (("HDCP -> "));
+
+			LinkStatus = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+			LinkStatus &= LINK_STATUS_MASK;
+
+			ClearInterrupt(SECURITY_CHANGE_EVENT);
+
+			switch (LinkStatus)
+			{
+				case LINK_STATUS_NORMAL:
+					TPI_DEBUG_PRINT (("Link = Normal\n"));
+					break;
+
+				case LINK_STATUS_LINK_LOST:
+					TPI_DEBUG_PRINT (("Link = Lost\n"));
+					RestartHDCP();
+					break;
+
+				case LINK_STATUS_RENEGOTIATION_REQ:
+					TPI_DEBUG_PRINT (("Link = Renegotiation Required\n"));
+					HDCP_Off();
+					HDCP_On();
+					break;
+
+				case LINK_STATUS_LINK_SUSPENDED:
+					TPI_DEBUG_PRINT (("Link = Suspended\n"));
+					HDCP_On();
+					break;
+			}
+		}
+
+		// Check if HDCP state has changed:
+		if (InterruptStatusImage & HDCP_CHANGE_EVENT)
+		{
+			RegImage = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+
+			NewLinkProtectionLevel = RegImage & (EXTENDED_LINK_PROTECTION_MASK | LOCAL_LINK_PROTECTION_MASK);
+			if (NewLinkProtectionLevel != HDCP_LinkProtectionLevel)
+			{
+				TPI_DEBUG_PRINT (("HDCP -> "));
+
+				HDCP_LinkProtectionLevel = NewLinkProtectionLevel;
+
+				switch (HDCP_LinkProtectionLevel)
+				{
+					case (EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE):
+						TPI_DEBUG_PRINT (("Protection = None\n"));
+						RestartHDCP();
+						break;
+
+					case LOCAL_LINK_PROTECTION_SECURE:
+
+
+						ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, AV_MUTE_MASK, AV_MUTE_NORMAL);
+						TPI_DEBUG_PRINT (("Protection = Local, Video Unmuted\n"));
+						break;
+
+					case (EXTENDED_LINK_PROTECTION_SECURE | LOCAL_LINK_PROTECTION_SECURE):
+						TPI_DEBUG_PRINT (("Protection = Extended\n"));
+#ifdef READKSV
+ 						if (IsRepeater())
+						{
+							RiCnt = ReadIndexedRegister(INDEXED_PAGE_0, 0x25);
+							while (RiCnt > 0x70)  // Frame 112
+							{
+								RiCnt = ReadIndexedRegister(INDEXED_PAGE_0, 0x25);
+							}
+							ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, 0x06, 0x06);
+							GetKSV();
+							RiCnt = ReadByteTPI(TPI_SYSTEM_CONTROL_DATA_REG);
+							ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, 0x08, 0x00);
+						}
+#endif
+						break;
+
+					default:
+						TPI_DEBUG_PRINT (("Protection = Extended but not Local?\n"));
+						RestartHDCP();
+						break;
+				}
+			}
+
+			ClearInterrupt(HDCP_CHANGE_EVENT);
+		}
+	}
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   IsHDCP_Supported()
+//
+// PURPOSE      :   Check Tx revision number to find if this Tx supports HDCP
+//                  by reading the HDCP revision number from TPI register 0x30.
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE if Tx supports HDCP. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+bool IsHDCP_Supported(void)
+{
+    unsigned char HDCP_Rev;
+	bool HDCP_Supported;
+
+	TPI_TRACE_PRINT((">>IsHDCP_Supported()\n"));
+
+	HDCP_Supported = TRUE;
+
+	// Check Device ID
+    HDCP_Rev = ReadByteTPI(TPI_HDCP_REVISION_DATA_REG);
+
+    if (HDCP_Rev != (HDCP_MAJOR_REVISION_VALUE | HDCP_MINOR_REVISION_VALUE))
+	{
+    	HDCP_Supported = FALSE;
+	}
+
+#ifdef SiI_9022AYBT_DEVICEID_CHECK
+	// Even if HDCP is supported check for incorrect Device ID
+	HDCP_Rev = ReadByteTPI(TPI_AKSV_1_REG);
+	if (HDCP_Rev == 0x90)
+	{
+		HDCP_Rev = ReadByteTPI(TPI_AKSV_2_REG);
+		if (HDCP_Rev == 0x22)
+		{
+			HDCP_Rev = ReadByteTPI(TPI_AKSV_3_REG);
+			if (HDCP_Rev == 0xA0)
+			{
+				HDCP_Rev = ReadByteTPI(TPI_AKSV_4_REG);
+				if (HDCP_Rev == 0x00)
+				{
+					HDCP_Rev = ReadByteTPI(TPI_AKSV_5_REG);
+					if (HDCP_Rev == 0x00)
+					{
+						HDCP_Supported = FALSE;
+					}
+				}
+			}
+		}
+	}
+#endif
+	return HDCP_Supported;
+}
+
+#ifdef READKSV
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   IsRepeater()
+//
+// PURPOSE      :   Test if sink is a repeater
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE if sink is a repeater. FALSE if not.
+//
+//////////////////////////////////////////////////////////////////////////////
+bool IsRepeater(void)
+{
+    unsigned char RegImage;
+
+	TPI_TRACE_PRINT((">>IsRepeater()\n"));
+
+    RegImage = ReadByteTPI(TPI_HDCP_QUERY_DATA_REG);
+
+    if (RegImage & HDCP_REPEATER_MASK)
+        return TRUE;
+
+    return FALSE;           // not a repeater
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   HDCP_On()
+//
+// PURPOSE      :   Switch hdcp on.
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   HDCP_Started set to TRUE
+//
+// RETURNS      :   None
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void HDCP_On(void)
+{
+	TPI_TRACE_PRINT((">>HDCP_On()\n"));
+	TPI_DEBUG_PRINT(("HDCP Started\n"));
+
+	WriteByteTPI(TPI_HDCP_CONTROL_DATA_REG, PROTECTION_LEVEL_MAX);
+
+	HDCP_Started = TRUE;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   HDCP_Off()
+//
+// PURPOSE      :   Switch hdcp off.
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   HDCP_Started set to FALSE
+//
+// RETURNS      :   None
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void HDCP_Off(void)
+{
+	TPI_TRACE_PRINT((">>HDCP_Off()\n"));
+	TPI_DEBUG_PRINT(("HDCP Stopped\n"));
+
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, AV_MUTE_MASK, AV_MUTE_MUTED);
+	WriteByteTPI(TPI_HDCP_CONTROL_DATA_REG, PROTECTION_LEVEL_MIN);
+
+	HDCP_Started = FALSE;
+	HDCP_LinkProtectionLevel = EXTENDED_LINK_PROTECTION_NONE | LOCAL_LINK_PROTECTION_NONE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   GetKSV()
+//
+// PURPOSE      :   Collect all downstrean KSV for verification
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   KSV_Array[]
+//
+// RETURNS      :   TRUE if KSVs collected successfully. False if not.
+//
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// The buffer is limited to KSV_ARRAY_SIZE due to the 8051 implementation.
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef READKSV
+static bool GetKSV(void)
+{
+	unsigned char i;
+    unsigned int KeyCount;
+    unsigned char KSV_Array[KSV_ARRAY_SIZE];
+
+	TPI_TRACE_PRINT((">>GetKSV()\n"));
+    ReadBlockHDCP(DDC_BSTATUS_ADDR_L, 1, &i);
+    KeyCount = (i & DEVICE_COUNT_MASK) * 5;
+	if (KeyCount != 0)
+	{
+		ReadBlockHDCP(DDC_KSV_FIFO_ADDR, KeyCount, KSV_Array);
+	}
+
+	/*
+	TPI_TRACE_PRINT(("KeyCount = %d\n", (int) KeyCount));
+	for (i=0; i<KeyCount; i++)
+	{
+		TPI_TRACE_PRINT(("KSV[%2d] = %2.2X\n", (int) i, (int) KSV_Array[i]));
+	}
+	*/
+
+	 return TRUE;
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  AreAKSV_OK()
+//
+// PURPOSE       :  Check if AKSVs contain 20 '0' and 20 '1'
+//
+// INPUT PARAMS  :  None
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  TBD
+//
+// RETURNS       :  TRUE if 20 zeros and 20 ones found in AKSV. FALSE OTHERWISE
+//
+//////////////////////////////////////////////////////////////////////////////
+static bool AreAKSV_OK(void)
+{
+    unsigned char B_Data[AKSV_SIZE];
+    unsigned char NumOfOnes = 0;
+
+    unsigned char i;
+    unsigned char j;
+
+	TPI_TRACE_PRINT((">>AreAKSV_OK()\n"));
+
+    ReadBlockTPI(TPI_AKSV_1_REG, AKSV_SIZE, B_Data);
+
+    for (i=0; i < AKSV_SIZE; i++)
+    {
+        for (j=0; j < BYTE_SIZE; j++)
+        {
+            if (B_Data[i] & 0x01)
+            {
+                NumOfOnes++;
+            }
+            B_Data[i] >>= 1;
+        }
+     }
+     if (NumOfOnes != NUM_OF_ONES_IN_KSV)
+        return FALSE;
+
+    return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  CheckRevocationList()
+//
+// PURPOSE       :  Compare KSVs to those included in a revocation list
+//
+// INPUT PARAMS  :  None
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  TBD
+//
+// RETURNS       :  TRUE if no illegal KSV found in BKSV list
+//
+// NOTE			 :	Currently this function is implemented as a place holder only
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef CHECKREVOCATIONLIST
+static bool CheckRevocationList(void)
+{
+	TPI_TRACE_PRINT((">>CheckRevocationList()\n"));
+    return TRUE;
+}
+#endif
+
+#endif
diff --git a/drivers/video/hdmi/si9022/SIIHDCP.h b/drivers/video/hdmi/si9022/SIIHDCP.h
new file mode 100755
index 0000000..6fbd525
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIHDCP.h
@@ -0,0 +1,30 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#ifdef DEV_SUPPORT_HDCP
+
+extern bool HDCP_TxSupports;			// True if the TX supports HDCP and has legal AKSVs... False otherwise.
+extern bool HDCP_Started;				// True if the HDCP enable bit has been set... False otherwise.
+
+extern unsigned char HDCP_LinkProtectionLevel;	// The most recently set link protection level from 0x29[7:6]
+
+void HDCP_Init (void);
+
+void HDCP_CheckStatus (unsigned char InterruptStatusImage);
+
+
+bool IsHDCP_Supported(void);
+
+void HDCP_On(void);
+void HDCP_Off(void);
+
+#else
+
+#define HDCP_TxSupports FALSE
+
+#endif
diff --git a/drivers/video/hdmi/si9022/SIIMacros.h b/drivers/video/hdmi/si9022/SIIMacros.h
new file mode 100755
index 0000000..29b0281
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIMacros.h
@@ -0,0 +1,9 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#define ClearInterrupt(x)                   WriteByteTPI(TPI_INTERRUPT_STATUS_REG, x)                   // write "1" to clear interrupt bit
\ No newline at end of file
diff --git a/drivers/video/hdmi/si9022/SIISiI9022A72.c b/drivers/video/hdmi/si9022/SIISiI9022A72.c
new file mode 100755
index 0000000..4dd51f4
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIISiI9022A72.c
@@ -0,0 +1,23 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#include "SIITPI_Access.h"
+void TXHAL_InitMicroGpios (void) {
+	}
+
+
+void TXHAL_InitPreReset (void) {
+	}
+
+
+void TXHAL_InitPostReset (void) {
+//	I2C_WriteByte(0x72, 0x82, 0x25);					// Terminations
+	I2C_WriteByte(0x39, 0x82, 0x25);					// Terminations
+//	I2C_WriteByte(0x72, 0x08, 0x36);
+	I2C_WriteByte(0x39, 0x08, 0x36);
+	}
diff --git a/drivers/video/hdmi/si9022/SIITPI.c b/drivers/video/hdmi/si9022/SIITPI.c
new file mode 100755
index 0000000..b0669ce
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIITPI.c
@@ -0,0 +1,739 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+// Standard C Library
+
+// Needs to be rearranged and minimized
+#include <linux/time.h>
+#include <linux/gpio.h>
+#include <asm/io.h>
+#include <plat/imapx.h>
+#include <linux/delay.h>
+#include "SIIdefs.h"
+#include "SIITypeDefs.h"
+//#include "AMF_Lib.h"
+#include "SIIConstants.h"
+#include "SIIMacros.h"
+#include "SIITPI_Regs.h"
+#include "SIITPI_Access.h"
+#include "SIITPI.h"
+#include "SIIAV_Config.h"
+#include "Externals.h"
+
+
+// May be empty depending on project definitions
+#include "SIIedid.h"
+#include "SIIHDCP.h"
+
+
+static void TxHW_Reset(void);
+static bool StartTPI(void);
+
+static void ForceUsbIdSwitchOpen (void);
+static void ReleaseUsbIdSwitchOpen (void);
+
+static bool DisableInterrupts(unsigned char);
+
+static bool TestHPD_Connected(void);
+
+static bool SetPreliminaryInfoFrames(void);
+
+
+
+//static void OnHdmiCableConnected(void);
+//static void OnHdmiCableDisconnected(void);
+
+static void OnDownstreamRxPoweredDown(void);
+static void OnDownstreamRxPoweredUp(void);
+
+void TxPowerState(unsigned char powerState);
+
+#define T_EN_TPI       	10
+#define T_HPD_DELAY    	10
+
+
+
+bool tmdsPoweredUp;
+static bool hdmiCableConnected;
+static bool dsRxPoweredUp;
+static const char TPI_FW_VERSION[] = {'0', '.', '2', '8'};
+
+//zhy + Begin
+void VideoModeSetbymain(void);
+void AudioModeSetbymain(void);
+//zhy + End
+
+//////////////////////////////////////////////////////////////////////////////
+////
+//// FUNCTION      :  DelayMS(unsigned int M_Sec)
+////
+//// PURPOSE       :  Introduce a busy-wait delay equal, in milliseconds, to the
+////                  input parameter.
+////
+//// INPUT PARAMS  :  Length of required delay in milliseconds (max. 65535 ms)
+////
+//// OUTPUT PARAMS :  None
+////
+//// GLOBALS USED  :  None
+////
+//// RETURNS       :  void
+////
+////////////////////////////////////////////////////////////////////////////////
+//
+void DelayMS(int M_Sec)
+{
+	unsigned int i;
+	for(i=0;i<M_Sec;i++)
+		udelay(1000);
+		//msleep(M_Sec);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : TPI_Init()
+//
+// PURPOSE       : TPI initialization: HW Reset, Interrupt enable.
+//
+// INPUT PARAMS  : None
+//
+// OUTPUT PARAMS : void
+//
+// GLOBALS USED  : None
+//
+// RETURNS      :   TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool TPI_Init(void)
+{
+	int i = 0;
+	TPI_TRACE_PRINT((">>TPI_Init()\n"));
+
+	printk("TPI Firmware Version ");
+	for (i=0; i < (int)sizeof(TPI_FW_VERSION); i++) {
+		printk("%c", TPI_FW_VERSION[i]);
+	}
+	printk("\n");
+
+	tmdsPoweredUp = FALSE;
+	hdmiCableConnected = FALSE;
+	dsRxPoweredUp = FALSE;
+
+#ifdef DEV_SUPPORT_EDID
+	edidDataValid = FALSE;							// Move this into EDID_Init();
+#endif
+
+	TxHW_Reset();									// Toggle TX reset pin
+
+	if (StartTPI())									// Enable HW TPI mode, check device ID
+	{
+#ifdef DEV_SUPPORT_HDCP
+		HDCP_Init();
+#endif
+
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   HotPlugService()
+//
+// PURPOSE      :   Implement Hot Plug Service Loop activities
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   void
+//
+// GLOBALS USED :   LinkProtectionLevel
+//
+// RETURNS      :   An error code that indicates success or cause of failure
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void HotPlugService (void)
+{
+	TPI_TRACE_PRINT((">>HotPlugService()\n"));
+
+	DisableInterrupts(0xFF);
+
+	if(IsHDMI_Sink())	//Set InfoFrames only if HDMI output mode
+	{
+		dvi_mode = FALSE;
+	}
+	else
+	{
+		dvi_mode = TRUE;
+	}
+
+#ifndef RX_ONBOARD
+	vid_mode = EDID_Data.VideoDescriptor[0];					// use 1st mode supported by sink
+#endif
+
+	//zhy Modify for hotplug Begin
+	VideoModeSetbymain();	
+
+	if (IsHDMI_Sink())											// Set audio only if sink is HDMI compatible
+	{
+		AudioModeSetbymain();
+	}
+	else
+	{
+		SetAudioMute(AUDIO_MUTE_MUTED);
+	}
+
+#if 0
+	InitVideo(vid_mode, X1, AFTER_INIT, NO_3D_SUPPORT);			// Set PLL Multiplier to x1 upon power up
+
+	TxPowerState(TX_POWER_STATE_D0);
+
+	if (IsHDMI_Sink())											// Set InfoFrames only if HDMI output mode
+	{
+		SetPreliminaryInfoFrames();
+		SetBasicAudio();										// set audio interface to basic audio (an external command is needed to set to any other mode
+		dvi_mode = FALSE;
+	}
+	else
+	{
+		SetAudioMute(AUDIO_MUTE_MUTED);
+		dvi_mode = TRUE;
+	}
+
+#ifdef DEV_SUPPORT_EHDMI
+	//	EHDMI_ARC_Common_Enable();
+	EHDMI_ARC_Common_With_HEC_Enable();
+#endif
+
+	EnableInterrupts(HOT_PLUG_EVENT | RX_SENSE_EVENT | AUDIO_ERROR_EVENT | SECURITY_CHANGE_EVENT | V_READY_EVENT | HDCP_CHANGE_EVENT);
+
+	// This check needs to be changed to if HDCP is required by the content... once support has been added by RX-side library.
+	if (HDCP_TxSupports == TRUE)
+	{
+#ifdef USE_BLACK_MODE
+		SetInputColorSpace (INPUT_COLOR_SPACE_BLACK_MODE);
+		TPI_DEBUG_PRINT (("TMDS -> Enabled\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, LINK_INTEGRITY_MODE_MASK | TMDS_OUTPUT_CONTROL_MASK, LINK_INTEGRITY_DYNAMIC | TMDS_OUTPUT_CONTROL_ACTIVE);
+#else	// AV MUTE
+		TPI_DEBUG_PRINT (("TMDS -> Enabled (Video Muted)\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, LINK_INTEGRITY_MODE_MASK | TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK, LINK_INTEGRITY_DYNAMIC | TMDS_OUTPUT_CONTROL_ACTIVE | AV_MUTE_MUTED);
+#endif
+		tmdsPoweredUp = TRUE;
+	}
+	else
+	{
+		EnableTMDS();
+	}
+#endif
+	EnableInterrupts(HOT_PLUG_EVENT | RX_SENSE_EVENT | AUDIO_ERROR_EVENT | SECURITY_CHANGE_EVENT | V_READY_EVENT | HDCP_CHANGE_EVENT);
+	//zhy Modify for hotplug End
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : HW_Reset()
+//
+// PURPOSE       : Send a
+//
+// INPUT PARAMS  : None
+//
+// OUTPUT PARAMS : void
+//
+// GLOBALS USED  : None
+//
+// RETURNS       : Void
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static void TxHW_Reset(void)
+{
+	unsigned int reg_temp;
+
+	reg_temp = __imapx_name_to_gpio(CONFIG_HDMI_SI9022_RESET);
+
+	if(reg_temp == IMAPX_GPIO_ERROR)
+	{
+		printk(KERN_ERR "SI9022 get reset pin failed.\n");
+		return -ENOTTY;
+	}
+
+	imapx_gpio_setcfg(reg_temp, IG_OUTPUT, IG_NORMAL);
+
+	TPI_TRACE_PRINT((">>TxHW_Reset()\n"));
+
+//	CYC_MICRO_RESET = LOW;
+	imapx_gpio_setpin(reg_temp, 0, IG_NORMAL);
+
+	DelayMS(TX_HW_RESET_PERIOD);
+//	CYC_MICRO_RESET = HIGH;
+	imapx_gpio_setpin(reg_temp, 1, IG_NORMAL);
+
+
+	TXHAL_InitPostReset();	//backdoor register access, enable source termination
+
+	// Does this need to be done for every chip? Should it be moved into TXHAL_InitPostReset() for each applicable device?
+	// HW Debouce of what?
+//	I2C_WriteByte(0x72, 0x7C, 0x14);				// HW debounce to 64ms (0x14)
+	I2C_WriteByte(0x39, 0x7C, 0x14);				// HW debounce to 64ms (0x14)
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : StartTPI()
+//
+// PURPOSE       : Start HW TPI mode by writing 0x00 to TPI address 0xC7. This
+//                 will take the Tx out of power down mode.
+//
+// INPUT PARAMS  : None
+//
+// OUTPUT PARAMS : void
+//
+// GLOBALS USED  : None
+//
+// RETURNS       : TRUE if HW TPI started successfully. FALSE if failed to.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+static bool StartTPI(void)
+{
+	unsigned char devID = 0x00;
+	unsigned int wID = 0x0000;
+
+	TPI_TRACE_PRINT((">>StartTPI()\n"));
+
+	WriteByteTPI(TPI_ENABLE, 0x00);            // Write "0" to 72:C7 to start HW TPI mode
+	DelayMS(100);
+
+	devID = ReadIndexedRegister(INDEXED_PAGE_0, 0x03);
+	wID = devID;
+	wID <<= 8;
+	devID = ReadIndexedRegister(INDEXED_PAGE_0, 0x02);
+	wID |= devID;
+
+	devID = ReadByteTPI(TPI_DEVICE_ID);
+
+	printk ("0x%04X\n", (int) wID);
+
+	if (devID == SiI_DEVICE_ID) {
+		//printk (SiI_DEVICE_STRING);
+		return TRUE;
+	}
+
+	printk ("Unsupported TX\n");
+	return FALSE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  EnableInterrupts()
+//
+// PURPOSE       :  Enable the interrupts specified in the input parameter
+//
+// INPUT PARAMS  :  A bit pattern with "1" for each interrupt that needs to be
+//                  set in the Interrupt Enable Register (TPI offset 0x3C)
+//
+// OUTPUT PARAMS :  void
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+bool EnableInterrupts(unsigned char Interrupt_Pattern)
+{
+	TPI_TRACE_PRINT((">>EnableInterrupts()\n"));
+	ReadSetWriteTPI(TPI_INTERRUPT_ENABLE_REG, Interrupt_Pattern);
+
+	return TRUE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  DisableInterrupts()
+//
+// PURPOSE       :  Enable the interrupts specified in the input parameter
+//
+// INPUT PARAMS  :  A bit pattern with "1" for each interrupt that needs to be
+//                  cleared in the Interrupt Enable Register (TPI offset 0x3C)
+//
+// OUTPUT PARAMS :  void
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+static bool DisableInterrupts(unsigned char Interrupt_Pattern)
+{
+	TPI_TRACE_PRINT((">>DisableInterrupts()\n"));
+	ReadClearWriteTPI(TPI_INTERRUPT_ENABLE_REG, Interrupt_Pattern);
+
+	return TRUE;
+}
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : SetPreliminaryInfoFrames()
+//
+// PURPOSE       : Set InfoFrames for default (initial) setup only
+//
+// INPUT PARAMS  : VIC, output mode,
+//
+// OUTPUT PARAMS : void
+//
+// GLOBALS USED  : None
+//
+// RETURNS       : TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+static bool SetPreliminaryInfoFrames()
+{
+	unsigned char i;
+	API_Cmd Command;        // to allow using function SetAVI_InfoFrames()
+
+	TPI_TRACE_PRINT((">>SetPreliminaryInfoFrames()\n"));
+
+	for (i = 0; i < MAX_COMMAND_ARGUMENTS; i++)
+		Command.Arg[i] = 0;
+
+	Command.CommandLength = 0;      // fixes SetAVI_InfoFrames() from going into an infinite loop
+
+	Command.Arg[0] = vid_mode;
+
+#ifdef DEV_SUPPORT_EDID
+	if (EDID_Data.YCbCr_4_4_4)
+	{
+		Command.Arg[3] = 0x01;
+	}
+	else
+	{
+		if (EDID_Data.YCbCr_4_2_2)
+		{
+			Command.Arg[3] = 0x02;
+		}
+	}
+#else
+	Command.Arg[3] = 0x00;
+#endif
+
+	SetAVI_InfoFrames(Command);
+	return TRUE;
+}
+
+
+void TxPowerState(unsigned char powerState) {
+
+	TPI_DEBUG_PRINT(("TX Power State D%d\n", (int)powerState));
+	/* Eric add infoTM*/
+	unsigned char InterruptStatusImage;
+	/* Eric add infoTM*/
+
+	/* Eric add infoTM*/
+	if(powerState == TX_POWER_STATE_D3)		//defaust to D3 Cold mode
+	{
+		InterruptStatusImage = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);    // Read Interrupt status register
+		if((InterruptStatusImage & HOT_PLUG_STATE)  == 0x00)			//HPD low
+		{
+			ReadSetWriteTPI(TPI_INTERRUPT_STATUS_REG, 0xF9); //Clear all pending interrupts
+			TxHW_Reset();
+			StartTPI();
+			ReadSetWriteTPI(TPI_INTERRUPT_ENABLE_REG, HOT_PLUG_EVENT); //enable hotplug interrupt
+			ReadSetWriteTPI(TPI_INTERRUPT_STATUS_REG, 0xF9); //Clear all pending interrupts again
+			if((InterruptStatusImage & HOT_PLUG_STATE)  == 0x00)			//HPD low
+			{
+				ReadModifyWriteTPI(TPI_DEVICE_POWER_STATE_CTRL_REG, 0x04, 0x04);	//set Cold bit
+//				ReadModifyWriteTPI(TPI_DEVICE_POWER_STATE_CTRL_REG, TX_POWER_STATE_MASK, powerState);	//set to D3 mode
+				TPI_DEBUG_PRINT(("Entered D3 cold mode\n"));
+
+			}
+			else{
+				TPI_DEBUG_PRINT(("HPD high, should not enter D3 cold mode ,D3 hot only\n"));
+				powerState = TX_POWER_STATE_D2;
+//				return;
+			}
+		}
+		else
+		{
+			TPI_DEBUG_PRINT(("HPD high, should not enter D3 cold mode,D3 hot only\n"));
+			powerState = TX_POWER_STATE_D2;
+//			return;
+		}
+
+	}
+
+	/* end Eric add infoTM*/
+	ReadModifyWriteTPI(TPI_DEVICE_POWER_STATE_CTRL_REG, TX_POWER_STATE_MASK, powerState);
+}
+
+
+void EnableTMDS (void) {
+
+	TPI_DEBUG_PRINT(("TMDS -> Enabled\n"));
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, TMDS_OUTPUT_CONTROL_MASK, TMDS_OUTPUT_CONTROL_ACTIVE);
+	tmdsPoweredUp = TRUE;
+}
+
+
+void DisableTMDS (void) {
+
+	TPI_DEBUG_PRINT(("TMDS -> Disabled\n"));
+	//ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, TMDS_OUTPUT_CONTROL_MASK, TMDS_OUTPUT_CONTROL_POWER_DOWN);
+	ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, TMDS_OUTPUT_CONTROL_MASK | AV_MUTE_MASK, TMDS_OUTPUT_CONTROL_POWER_DOWN | AV_MUTE_MUTED);
+	tmdsPoweredUp = FALSE;
+}
+
+#ifdef DEV_SUPPORT_HDCP
+void RestartHDCP (void)
+{
+	TPI_DEBUG_PRINT (("HDCP -> Restart\n"));
+
+	DisableTMDS();
+	HDCP_Off();
+	EnableTMDS();
+}
+#endif
+
+void SetAudioMute (unsigned char audioMute)
+{
+	ReadModifyWriteTPI(TPI_AUDIO_INTERFACE_REG, AUDIO_MUTE_MASK, audioMute);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   TPI_Poll ()
+//
+// PURPOSE      :   Poll Interrupt Status register for new interrupts
+//
+// INPUT PARAMS :   None
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   LinkProtectionLevel
+//
+// RETURNS      :   None
+//
+//////////////////////////////////////////////////////////////////////////////
+
+void TPI_Poll (void)
+{
+	unsigned char InterruptStatusImage;
+	unsigned int timing = 0;
+
+	InterruptStatusImage = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);
+
+	if (InterruptStatusImage & HOT_PLUG_EVENT)
+	{
+		TPI_DEBUG_PRINT (("HPD  -> "));
+
+		ReadSetWriteTPI(TPI_INTERRUPT_ENABLE_REG, HOT_PLUG_EVENT);  // Enable HPD interrupt bit
+
+		// Repeat this loop while cable is bouncing:
+		do
+		{
+			WriteByteTPI(TPI_INTERRUPT_STATUS_REG, HOT_PLUG_EVENT);
+			DelayMS(T_HPD_DELAY); // Delay for metastability protection and to help filter out connection bouncing
+			InterruptStatusImage = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);    // Read Interrupt status register
+		} while (InterruptStatusImage & HOT_PLUG_EVENT);              // loop as long as HP interrupts recur
+
+		if (((InterruptStatusImage & HOT_PLUG_STATE) >> 2) != hdmiCableConnected)
+		{
+			if (hdmiCableConnected == TRUE)
+			{
+				OnHdmiCableDisconnected();
+			}
+
+			else
+			{
+				OnHdmiCableConnected(timing);
+				ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);
+			}
+
+			if (hdmiCableConnected == FALSE)
+			{
+				return;
+			}
+		}
+	}
+
+
+
+
+
+#if !defined SiI9232_OR_SiI9236
+	// Check rx power
+	if (((InterruptStatusImage & RX_SENSE_STATE) >> 3) != dsRxPoweredUp)
+	{
+		if (hdmiCableConnected == TRUE)
+		{
+			if (dsRxPoweredUp == TRUE)
+			{
+				OnDownstreamRxPoweredDown();
+			}
+
+			else
+			{
+				OnDownstreamRxPoweredUp();
+			}
+		}
+
+		ClearInterrupt(RX_SENSE_EVENT);
+	}
+#endif
+
+	// Check if Audio Error event has occurred:
+	if (InterruptStatusImage & AUDIO_ERROR_EVENT)
+	{
+		//TPI_DEBUG_PRINT (("TP -> Audio Error Event\n"));
+		//  The hardware handles the event without need for host intervention (PR, p. 31)
+		ClearInterrupt(AUDIO_ERROR_EVENT);
+	}
+
+#ifdef DEV_SUPPORT_HDCP
+	if ((hdmiCableConnected == TRUE) && (dsRxPoweredUp == TRUE))
+	{
+		HDCP_CheckStatus(InterruptStatusImage);
+	}
+#endif
+
+#ifdef RX_ONBOARD
+	if ((tmdsPoweredUp == TRUE) && (pvid_mode != vid_mode))
+	{
+		TPI_TRACE_PRINT(("TP -> vid_mode...\n"));
+		DisableTMDS();
+		HotPlugService();
+		pvid_mode = vid_mode;
+	}
+#endif
+
+
+
+}
+
+
+
+
+void OnHdmiCableConnected(LCD_TIMING timing)
+{
+	TPI_DEBUG_PRINT (("HDMI Connected ("));
+
+	switch(timing)
+	{
+		case HDMI_1080P:
+			VideoMode[0] = 16;
+			break;
+		case HDMI_720P:
+			VideoMode[0] = 4;
+			break;
+		case HDMI_480P_16_9:
+			VideoMode[0] = 3;
+			break;
+		case HDMI_480P_4_3:
+			VideoMode[0] = 2;
+			break;
+		case HDMI_576P_16_9:
+			VideoMode[0] = 18;
+			break;
+		case HDMI_576P_4_3:
+			VideoMode[0] = 17;
+			break;
+		case HDMI_640_480:
+			VideoMode[0] = 1;
+			break;
+		case HDMI_800_600:
+			VideoMode[0] = 65;
+			break;
+		case HDMI_1024_768:
+			VideoMode[0] = 69;
+			break;
+		default:
+			break;
+
+	}
+
+	hdmiCableConnected = TRUE;
+
+#ifdef DEV_SUPPORT_HDCP
+	WriteIndexedRegister(INDEXED_PAGE_0, 0xCE, 0x00); // Clear BStatus
+	WriteIndexedRegister(INDEXED_PAGE_0, 0xCF, 0x00);
+#endif
+
+#ifdef DEV_SUPPORT_EDID
+	DoEdidRead();
+#endif
+
+#ifdef READKSV
+	ReadModifyWriteTPI(0xBB, 0x08, 0x08);
+#endif
+
+	if (IsHDMI_Sink())              // select output mode (HDMI/DVI) according to sink capabilty
+	{
+		TPI_DEBUG_PRINT (("HDMI Sink)\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_HDMI);
+	}
+	else
+	{
+		TPI_DEBUG_PRINT (("DVI Sink)\n"));
+		ReadModifyWriteTPI(TPI_SYSTEM_CONTROL_DATA_REG, OUTPUT_MODE_MASK, OUTPUT_MODE_DVI);
+	}
+
+	//zhy - for when TV power down, 9024 power up, then power up TV ,there is no video #if defined SiI9232_OR_SiI9236
+	OnDownstreamRxPoweredUp();		// RX power not determinable? Force to on for now.
+	//zhy - #endif
+}
+
+void OnHdmiCableDisconnected(void) {
+
+	TPI_DEBUG_PRINT (("HDMI Disconnected\n"));
+
+	hdmiCableConnected = FALSE;
+
+#ifdef DEV_SUPPORT_EDID
+	edidDataValid = FALSE;
+#endif
+
+	OnDownstreamRxPoweredDown();
+	TxPowerState(TX_POWER_STATE_D3);
+}
+
+
+static void OnDownstreamRxPoweredDown(void) {
+
+	TPI_DEBUG_PRINT (("DSRX -> Powered Down\n"));
+	dsRxPoweredUp = FALSE;
+
+#ifdef DEV_SUPPORT_HDCP
+	HDCP_Off();
+#endif
+
+	DisableTMDS();
+}
+
+
+static void OnDownstreamRxPoweredUp(void) {
+
+	TPI_DEBUG_PRINT (("DSRX -> Powered Up\n"));
+	dsRxPoweredUp = TRUE;
+
+	HotPlugService();
+
+	pvid_mode = vid_mode;
+}
+
diff --git a/drivers/video/hdmi/si9022/SIITPI.h b/drivers/video/hdmi/si9022/SIITPI.h
new file mode 100755
index 0000000..7d33afb
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIITPI.h
@@ -0,0 +1,38 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+#include "imap_HDMI.h"
+
+void DelayMS(int M_Sec);
+void OnHdmiCableDisconnected(void);
+void OnHdmiCableConnected(LCD_TIMING timing);
+
+bool TPI_Init (void);			// Document purpose, usage
+void TPI_Poll (void);			// Document purpose, usage, rename
+
+void EnableTMDS (void);			// Document purpose, usage
+void DisableTMDS (void);		// Document purpose, usage
+
+void RestartHDCP (void);		// Document purpose, usage
+
+void SetInputColorSpace (char inputColorSpace);
+
+//void SetAudioMute (char audioMute);
+void SetAudioMute (unsigned char audioMute);
+void TxPowerState(unsigned char powerState);
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
+
+void HotPlugService (void);		// Why is this being called form outside TPI.c?? Re-architect
+//bool EnableInterrupts (char);	// Why is this being called form outside TPI.c?? Re-architect
+bool EnableInterrupts(unsigned char Interrupt_Pattern);
+extern unsigned char VideoMode[9];
+
+// TPI Firmware Version
+//=====================
+//static const char TPI_FW_VERSION[] = {'0', '.', '2', '8'};
+
diff --git a/drivers/video/hdmi/si9022/SIITPI_Access.c b/drivers/video/hdmi/si9022/SIITPI_Access.c
new file mode 100755
index 0000000..c831dce
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIITPI_Access.c
@@ -0,0 +1,754 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+#include "SIIdefs.h"
+#include <linux/delay.h>
+#include <linux/time.h>
+#include "SIITypeDefs.h"
+//#include "AMF_Lib.h"
+#include "SIIConstants.h"
+#include "SIITPI_Regs.h"
+#include "Externals.h"
+#include "SIIMacros.h"
+#include "SIITPI_Access.h"
+#include "SIITPI.h"
+
+#define T_DDC_ACCESS    50
+
+unsigned char I2C_ReadByte(unsigned char IICAddr, unsigned char ByteAddr);
+void I2C_WriteByte(unsigned char IICAddr, unsigned char ByteAddr, unsigned char Data);
+
+
+unsigned char I2C_ReadSegmentBlock(unsigned char deviceID, unsigned char segment, unsigned char offset, unsigned char *buffer, unsigned int length)
+{
+//	I2C_WriteByte(deviceID , 0x01, segment);
+	I2C_ReadBlock(deviceID, offset, buffer, length);
+	
+	return 0;
+}
+
+int I2C_ReadBlock(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, int Size)
+{
+	struct i2c_adapter *adapter;
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = 1,
+			.buf            = &ByteAddr,
+		},
+		{
+			.addr   = IICAddr,
+			.flags  = I2C_M_RD,
+			.len            = Size,
+			.buf            = Data,
+		}
+	};
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_SI9022_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[DDC_Read]: can't get i2c adapter\n");
+
+		return -1; 
+	}
+
+	if(i2c_transfer(adapter, msgs, 2) != 2)
+	{
+		printk("[funciton:%s-line%d] i2c_transfer error\n",__func__,__LINE__);
+		return 0;
+	}
+
+	return 1;
+}
+
+void I2C_WriteBlock(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, int Size)
+{
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(Size + 1, GFP_KERNEL);
+	unsigned int i;
+
+	buf[0] = ByteAddr;
+	for(i=0;i<Size;i++)
+		buf[i + 1] = Data[i];
+
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = Size + 1,
+			.buf            = buf,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[IIC_Write]: unable to allocate memory for EDID.\n");
+	}
+
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_SI9022_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[IIC_Write]: can't get i2c adapter\n");
+	}
+
+	i2c_transfer(adapter, msgs, 1);
+
+	kfree(buf);
+}
+
+
+unsigned char I2C_ReadByte(unsigned char IICAddr, unsigned char ByteAddr)
+{
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(sizeof(unsigned char), GFP_KERNEL);
+	struct timeval time;
+
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = 1,
+			.buf            = &ByteAddr,
+		},{
+			.addr   = IICAddr,
+			.flags  = I2C_M_RD,
+			.len            = sizeof(unsigned char),
+			.buf            = buf,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[IIC_Read]: unable to allocate memory for Read.\n");
+		return -1; 
+	}
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_SI9022_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[IIC_Read]: can't get i2c adapter\n");
+
+		return -1; 
+	}
+
+	if (i2c_transfer(adapter, msgs, 2) != 2)
+	{
+		return *buf;
+	}
+
+	return *buf;
+}
+
+void I2C_WriteByte_NoAck(unsigned char IICAddr, unsigned char ByteAddr, unsigned char Data)
+{
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(2 * sizeof(unsigned char), GFP_KERNEL);
+
+	buf[0] = ByteAddr;
+	buf[1] = Data;
+
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = I2C_M_IGNORE_NAK,
+			.len            = 2 * sizeof(unsigned char),
+			.buf            = buf,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[IIC_Write]: unable to allocate memory for EDID.\n");
+	}
+
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_SI9022_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[IIC_Write]: can't get i2c adapter\n");
+
+	}
+
+	i2c_transfer(adapter, msgs, 1);
+
+	kfree(buf);
+}
+
+
+void I2C_WriteByte(unsigned char IICAddr, unsigned char ByteAddr, unsigned char Data)
+{
+	struct i2c_adapter *adapter;
+	unsigned char *buf = kmalloc(2 * sizeof(unsigned char), GFP_KERNEL);
+	struct timeval time;
+
+	buf[0] = ByteAddr;
+	buf[1] = Data;
+
+	struct i2c_msg msgs[] = { 
+		{
+			.addr   = IICAddr,
+			.flags  = 0,
+			.len            = 2 * sizeof(unsigned char),
+			.buf            = buf,
+		}
+	};
+
+	if (!buf)
+	{
+		printk(KERN_ERR "[IIC_Write]: unable to allocate memory for EDID.\n");
+	}
+
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_SI9022_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "[IIC_Write]: can't get i2c adapter\n");
+
+	}
+
+	i2c_transfer(adapter, msgs, 1);
+
+	kfree(buf);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   ReadByteTPI ()
+//
+// PURPOSE      :   Read one unsigned char from a given offset of the TPI interface.
+//
+// INPUT PARAMS :   Offset of TPI register to be read; A pointer to the variable
+//                  where the data read will be stored
+//
+// OUTPUT PARAMS:   Data - Contains the value read from the register value
+//                  specified as the first input parameter
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE
+//
+// NOTE         :   ReadByteTPI() is ported from the PC based FW to the uC
+//                  version while retaining the same function interface. This
+//                  will save the need to modify higher level I/O functions
+//                  such as ReadSetWriteTPI(), ReadClearWriteTPI() etc.
+//                  A dummy returned value (always TRUE) is provided for
+//                  the same reason
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char ReadByteTPI(unsigned char RegOffset)
+{
+    return I2C_ReadByte(TX_SLAVE_ADDR, RegOffset);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  WriteByteTPI ()
+//
+// PURPOSE       :  Write one unsigned char to a given offset of the TPI interface.
+//
+// INPUT PARAMS  :  Offset of TPI register to write to; value to be written to
+//                  that TPI retister
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  VOID
+//
+//////////////////////////////////////////////////////////////////////////////
+void WriteByteTPI(unsigned char RegOffset, unsigned char Data)
+{
+    I2C_WriteByte(TPI_BASE_ADDR, RegOffset, Data);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ReadSetWriteTPI(unsigned char Offset, unsigned char Pattern)
+//
+// PURPOSE       :  Write "1" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Pattern"; Leave all other bits in "Offset"
+//                  unchanged.
+//
+// INPUT PARAMS  :  Offset  :   TPI register offset
+//                  Pattern :   GPIO bits that need to be set
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+void ReadSetWriteTPI(unsigned char Offset, unsigned char Pattern)
+{
+    unsigned char Tmp;
+
+    Tmp = ReadByteTPI(Offset);
+
+    Tmp |= Pattern;
+    WriteByteTPI(Offset, Tmp);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ReadClearWriteTPI(unsigned char Offset, unsigned char Pattern)
+//
+// PURPOSE       :  Write "0" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Pattern"; Leave all other bits in "Offset"
+//                  unchanged.
+//
+// INPUT PARAMS  :  Offset  :   TPI register offset
+//                  Pattern :   "1" for each TPI register bit that needs to be
+//                              cleared
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE
+//
+//////////////////////////////////////////////////////////////////////////////
+void ReadClearWriteTPI(unsigned char Offset, unsigned char Pattern)
+{
+    unsigned char Tmp;
+
+    Tmp = ReadByteTPI(Offset);
+
+    Tmp &= ~Pattern;
+    WriteByteTPI(Offset, Tmp);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ReadModifyWriteTPI(unsigned char Offset, unsigned char Mask, unsigned char Value)
+//
+// PURPOSE       :  Write "Value" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Mask"; Leave all other bits in "Offset"
+//                  unchanged.
+//
+// INPUT PARAMS  :  Offset  :   TPI register offset
+//                  Mask    :   "1" for each TPI register bit that needs to be
+//                              modified
+//					Value   :   The desired value for the register bits in their
+//								proper positions
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  void
+//
+//////////////////////////////////////////////////////////////////////////////
+void ReadModifyWriteTPI(unsigned char Offset, unsigned char Mask, unsigned char Value)
+{
+    unsigned char Tmp;
+
+    Tmp = ReadByteTPI(Offset);
+    Tmp &= ~Mask;
+	Tmp |= (Value & Mask);
+    WriteByteTPI(Offset, Tmp);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION         :   ReadBlockTPI ()
+//
+// PURPOSE          :   Read NBytes from offset Addr of the TPI slave address
+//                      into a unsigned char Buffer pointed to by Data
+//
+// INPUT PARAMETERS :   TPI register offset, number of unsigned chars to read and a
+//                      pointer to the data buffer where the data read will be
+//                      saved
+//
+// OUTPUT PARAMETERS:   pData - pointer to the buffer that will store the TPI
+//                      block to be read
+//
+// RETURNED VALUE   :   VOID
+//
+// GLOBALS USED     :   None
+//
+////////////////////////////////////////////////////////////////////////////////
+void ReadBlockTPI(unsigned char TPI_Offset, unsigned int NBytes, unsigned char * pData)
+{
+    I2C_ReadBlock(TPI_BASE_ADDR, TPI_Offset, pData, NBytes);
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION         :   WriteBlockTPI ()
+//
+// PURPOSE          :   Write NBytes from a unsigned char Buffer pointed to by Data to
+//                      the TPI I2C slave starting at offset Addr
+//
+// INPUT PARAMETERS :   TPI register offset to start writing at, number of unsigned chars
+//                      to write and a pointer to the data buffer that contains
+//                      the data to write
+//
+// OUTPUT PARAMETERS:   None.
+//
+// RETURNED VALUES  :   void
+//
+// GLOBALS USED     :   None
+//
+////////////////////////////////////////////////////////////////////////////////
+void WriteBlockTPI(unsigned char TPI_Offset, unsigned int NBytes, unsigned char * pData)
+{
+    I2C_WriteBlock(TPI_BASE_ADDR, TPI_Offset, pData, NBytes);
+}
+
+
+#if defined HAS_CTRL_BUS
+unsigned char ReadByteCBUS (unsigned char Offset) {
+	return I2C_ReadByte(CBUS_SLAVE_ADDR, Offset);
+	}
+
+void WriteByteCBUS(unsigned char Offset, unsigned char Data) {
+	I2C_WriteByte(CBUS_SLAVE_ADDR, Offset, Data);
+	}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  GetDDC_Access(void)
+//
+// PURPOSE       :  Request access to DDC bus from the receiver
+//
+// INPUT PARAMS  :  None
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE if bus obtained successfully. FALSE if failed.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+bool GetDDC_Access (unsigned char* SysCtrlRegVal)
+{
+	unsigned char sysCtrl;
+	unsigned char DDCReqTimeout = T_DDC_ACCESS;
+	unsigned char TPI_ControlImage;
+
+	TPI_TRACE_PRINT((">>GetDDC_Access()\n"));
+
+	sysCtrl = ReadByteTPI (TPI_SYSTEM_CONTROL_DATA_REG);			// Read and store original value. Will be passed into ReleaseDDC()
+	*SysCtrlRegVal = sysCtrl;
+
+	sysCtrl |= DDC_BUS_REQUEST_REQUESTED;
+	WriteByteTPI (TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);
+
+	while (DDCReqTimeout--)											// Loop till 0x1A[1] reads "1"
+	{
+		TPI_ControlImage = ReadByteTPI(TPI_SYSTEM_CONTROL_DATA_REG);
+
+		if (TPI_ControlImage & DDC_BUS_GRANT_MASK)					// When 0x1A[1] reads "1"
+		{
+			sysCtrl |= DDC_BUS_GRANT_GRANTED;
+			WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);		// lock host DDC bus access (0x1A[2:1] = 11)
+			return TRUE;
+		}
+		WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);			// 0x1A[2] = "1" - Requst the DDC bus
+		DelayMS(200);
+	}
+
+	WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, sysCtrl);				// Failure... restore original value.
+	return FALSE;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ReleaseDDC(void)
+//
+// PURPOSE       :  Release DDC bus
+//
+// INPUT PARAMS  :  None
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  TRUE if bus released successfully. FALSE if failed.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+bool ReleaseDDC(unsigned char SysCtrlRegVal)
+{
+	unsigned char DDCReqTimeout = T_DDC_ACCESS;
+	unsigned char TPI_ControlImage;
+
+	TPI_TRACE_PRINT((">>ReleaseDDC()\n"));
+
+	SysCtrlRegVal &= ~BITS_2_1;					// Just to be sure bits [2:1] are 0 before it is written
+
+	while (DDCReqTimeout--)						// Loop till 0x1A[1] reads "0"
+	{
+		// Cannot use ReadClearWriteTPI() here. A read of TPI_SYSTEM_CONTROL is invalid while DDC is granted.
+		// Doing so will return 0xFF, and cause an invalid value to be written back.
+		//ReadClearWriteTPI(TPI_SYSTEM_CONTROL,BITS_2_1); // 0x1A[2:1] = "0" - release the DDC bus
+
+//		WriteByteTPI(TPI_SYSTEM_CONTROL_DATA_REG, SysCtrlRegVal);
+		I2C_WriteByte_NoAck(TPI_BASE_ADDR,TPI_SYSTEM_CONTROL_DATA_REG, SysCtrlRegVal);
+		TPI_ControlImage = ReadByteTPI(TPI_SYSTEM_CONTROL_DATA_REG);
+
+		if (!(TPI_ControlImage & BITS_2_1))		// When 0x1A[2:1] read "0"
+			return TRUE;
+	}
+
+	return FALSE;								// Failed to release DDC bus control
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION         :   ReadBlockHDCP ()
+//
+// PURPOSE          :   Read NBytes from offset Addr of the HDCP slave address
+//                      into a unsigned char Buffer pointed to by Data
+//
+// INPUT PARAMETERS :   HDCP port offset, number of unsigned chars to read and a
+//                      pointer to the data buffer where the data read will be
+//                      saved
+//
+// OUTPUT PARAMETERS:   Data, a buffer that contains the block read from the CPI
+//
+// RETURNED VALUE   :   void
+//
+// GLOBALS USED     :   None
+//
+////////////////////////////////////////////////////////////////////////////////
+#ifdef READKSV
+void ReadBlockHDCP(unsigned char TPI_Offset, unsigned int NBytes, unsigned char * pData)
+{
+	TPI_TRACE_PRINT((">>ReadBlockHDCP()\n"));
+    I2C_ReadBlock(HDCP_SLAVE_ADDR, TPI_Offset, pData, NBytes);
+}
+#endif
+
+
+#define TPI_INTERNAL_PAGE_REG	0xBC
+#define TPI_INDEXED_OFFSET_REG	0xBD
+#define TPI_INDEXED_VALUE_REG	0xBE
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   ReadIndexedRegister()
+//
+// PURPOSE      :   Read an indexed register value
+//
+//                  Write:
+//                      1. 0xBC => Internal page num
+//                      2. 0xBD => Indexed register offset
+//
+//                  Read:
+//                      3. 0xBE => Returns the indexed register value
+//
+// INPUT PARAMS :   Internal page number, indexed register offset, pointer to
+//                  buffer to store read value
+//
+// OUTPUT PARAMS:   Buffer that stores the read value
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE 
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef DEV_INDEXED_READ
+unsigned char ReadIndexedRegister(unsigned char PageNum, unsigned char RegOffset) {
+    WriteByteTPI(TPI_INTERNAL_PAGE_REG, PageNum);		// Internal page
+    WriteByteTPI(TPI_INDEXED_OFFSET_REG, RegOffset);	// Indexed register
+    return ReadByteTPI(TPI_INDEXED_VALUE_REG); 		// Return read value
+}
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   WriteIndexedRegister()
+//
+// PURPOSE      :   Write a value to an indexed register
+//
+//                  Write:
+//                      1. 0xBC => Internal page num
+//                      2. 0xBD => Indexed register offset
+//                      3. 0xBE => Set the indexed register value
+//
+// INPUT PARAMS :   Internal page number, indexed register offset, value
+//                  to write to indexed register
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE 
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef DEV_INDEXED_WRITE
+void WriteIndexedRegister(unsigned char PageNum, unsigned char RegOffset, unsigned char RegValue) {
+    WriteByteTPI(TPI_INTERNAL_PAGE_REG, PageNum);  // Internal page
+    WriteByteTPI(TPI_INDEXED_OFFSET_REG, RegOffset);  // Indexed register
+    WriteByteTPI(TPI_INDEXED_VALUE_REG, RegValue);    // Read value into buffer
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      :  ReadModifyWriteIndexedRegister(unsigned char PageNum, unsigned char Offset, unsigned char Mask, unsigned char Value)
+//
+// PURPOSE       :  Write "Value" to all bits in TPI offset "Offset" that are set
+//                  to "1" in "Mask"; Leave all other bits in "Offset"
+//                  unchanged.
+//
+// INPUT PARAMS  :  Offset  :   TPI register offset
+//                  Mask    :   "1" for each TPI register bit that needs to be
+//                              modified
+//					Value   :   The desired value for the register bits in their
+//								proper positions
+//
+// OUTPUT PARAMS :  None
+//
+// GLOBALS USED  :  None
+//
+// RETURNS       :  void
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef DEV_INDEXED_RMW
+void ReadModifyWriteIndexedRegister(unsigned char PageNum, unsigned char RegOffset, unsigned char Mask, unsigned char Value)
+{
+    unsigned char Tmp;
+
+    WriteByteTPI(TPI_INTERNAL_PAGE_REG, PageNum);
+    WriteByteTPI(TPI_INDEXED_OFFSET_REG, RegOffset);
+    Tmp = ReadByteTPI(TPI_INDEXED_VALUE_REG);
+
+    Tmp &= ~Mask;
+	Tmp |= (Value & Mask);
+
+    WriteByteTPI(TPI_INDEXED_VALUE_REG, Tmp);
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetPLL()
+//
+// PURPOSE      :   Set the 9024/9024/9222 chip PLL to multiply the input pixel
+//                  clock by the value passed to this function as a parameter
+//                  registers:
+//
+// INPUT PARAMS :   PLL Multiplication factor (represents 0.5, 1, 2 or 4)
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE 
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef DEV_INDEXED_PLL
+bool SetPLL(unsigned char TClkSel)
+{
+    unsigned char RegValue;
+    unsigned char Pattern;
+
+    // Set up register 0x82[6:5] (same for all input pixel frequencies for a specific multiplier value):
+
+    ReadIndexedRegister(0x01, TMDS_CONT_REG, &RegValue);
+
+    Pattern = TClkSel << 5;
+    RegValue &= ~BITS_6_5;
+    RegValue |= Pattern;
+
+    WriteByteTPI(TPI_REGISTER_VALUE_REG, RegValue);
+
+    return TRUE;
+}
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetChannelLayout()
+//
+// PURPOSE      :   Set up the Channel layout field of internal register 0x2F
+//                  (0x2F[1])
+//
+// INPUT PARAMS :   Number of audio channels: "0 for 2-Channels ."1" for 8.
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE 
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef SetChannelLayout
+bool SetChannelLayout(unsigned char Count)
+{
+    // Indexed register 0x7A:0x2F[1]:
+    WriteByteTPI(TPI_INTERNAL_PAGE_REG, 0x02); // Internal page 2
+    WriteByteTPI(TPI_REGISTER_OFFSET_REG, 0x2F);
+
+    Count &= THREE_LSBITS;
+
+    if (Count == TWO_CHANNEL_LAYOUT)
+    {
+        // Clear 0x2F:
+        ReadClearWriteTPI(TPI_REGISTER_VALUE_REG, BIT_1);
+    }
+
+    else if (Count == EIGHT_CHANNEL_LAYOUT)
+    {
+        // Set 0x2F[0]:
+        ReadSetWriteTPI(TPI_REGISTER_VALUE_REG, BIT_1);
+    }
+
+    return TRUE;
+}
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION     :   SetInputWordLength()
+//
+// PURPOSE      :   Tell the Tx what the I2S input unsigned int is
+//
+// INPUT PARAMS :   Input unsigned int length code per SiI-PR-1032-0.02, table 20
+//
+// OUTPUT PARAMS:   None
+//
+// GLOBALS USED :   None
+//
+// RETURNS      :   TRUE
+//
+// NOTE         :   Used by 9022/4 only. 9022A/24A and 9334 set that value
+//                  automatically when 0x25[5:3] is set
+//
+//////////////////////////////////////////////////////////////////////////////
+#ifdef SETINPUTWORDLENGTH
+bool SetInputWordLength(unsigned char Length)
+{
+    unsigned char RegValue;
+
+    RegValue = ReadIndexedRegister(0x02, AUDIO_INPUT_LENGTH);
+
+    RegValue &= ~LOW_NIBBLE;
+    RegValue |= Length;
+
+    WriteByteTPI(TPI_REGISTER_VALUE_REG, RegValue);
+
+    return TRUE;
+}
+#endif
diff --git a/drivers/video/hdmi/si9022/SIITPI_Access.h b/drivers/video/hdmi/si9022/SIITPI_Access.h
new file mode 100755
index 0000000..4f59bef
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIITPI_Access.h
@@ -0,0 +1,78 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#include <asm/io.h>
+#include <linux/i2c.h>
+#include <plat/imapx.h>
+
+unsigned char I2C_ReadByte(unsigned char IICAddr, unsigned char ByteAddr);
+void I2C_WriteByte(unsigned char IICAddr, unsigned char ByteAddr, unsigned char Data);
+unsigned char I2C_ReadSegmentBlock(unsigned char deviceID, unsigned char segment, unsigned char offset, unsigned char *buffer, unsigned int length);
+int I2C_ReadBlock(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, int Size);
+void I2C_WriteBlock(unsigned char IICAddr, unsigned char ByteAddr, unsigned char *Data, int Size);
+unsigned char ReadByteTPI(unsigned char);
+void WriteByteTPI(unsigned char, unsigned char);
+
+#if defined HAS_CTRL_BUS
+unsigned char ReadByteCBUS (unsigned char Offset);
+void WriteByteCBUS(unsigned char Offset, unsigned char Data);
+#endif
+
+void ReadSetWriteTPI(unsigned char, unsigned char);
+void ReadClearWriteTPI(unsigned char, unsigned char);
+void ReadModifyWriteTPI(unsigned char Offset, unsigned char Mask, unsigned char Value);
+
+//void ReadBlockTPI(unsigned char, int, unsigned char *);
+void ReadBlockTPI(unsigned char TPI_Offset, unsigned int NBytes, unsigned char * pData);
+//void WriteBlockTPI(unsigned char, int, unsigned char *);
+void WriteBlockTPI(unsigned char TPI_Offset, unsigned int NBytes, unsigned char * pData);
+
+bool GetDDC_Access(unsigned char* SysCtrlRegVal);
+bool ReleaseDDC(unsigned char SysCtrlRegVal);
+
+#ifdef READKSV
+void ReadBlockHDCP(unsigned char, int, unsigned char *);
+#endif
+
+unsigned char ReadIndexedRegister(unsigned char, unsigned char);
+void WriteIndexedRegister(unsigned char, unsigned char, unsigned char);
+void ReadModifyWriteIndexedRegister(unsigned char, unsigned char, unsigned char, unsigned char);
+
+/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+
+// Indexed Register Offsets, Constants
+//====================================
+#define INDEXED_PAGE_0			0x01
+#define INDEXED_PAGE_1			0x02
+#define INDEXED_PAGE_2			0x03
+
+#define DEVICE_ID_LOW_BYTE      0x02
+#define DEVICE_ID_HI_BYTE       0x03
+#define AUDIO_INPUT_LENGTH		0x24
+
+#define TMDS_CONT_REG           0x82
+
+#define SW_RESET                0x05
+#define POWER_DOWN              0x6F
+
+
+#define DIV_BY_2                0x00
+#define MULT_BY_1               0x01
+#define MULT_BY_2               0x02
+#define MULT_BY_4               0x03
+
+#ifdef DEV_INDEXED_PLL
+bool SetPLL(unsigned char);
+#endif
+
+// Prototype Declarations
+//=======================
+
+bool SetInputWordLength(unsigned char);
+
+bool SetChannelLayout(unsigned char);
diff --git a/drivers/video/hdmi/si9022/SIITPI_Regs.h b/drivers/video/hdmi/si9022/SIITPI_Regs.h
new file mode 100755
index 0000000..413b742
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIITPI_Regs.h
@@ -0,0 +1,393 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+// TPI Video Mode Data
+//====================
+
+#define TPI_PIX_CLK_LSB						(0x00)
+#define TPI_PIX_CLK_MSB						(0x01)
+
+#define TPI_VERT_FREQ_LSB					(0x02)
+#define TPI_VERT_FREQ_MSB					(0x03)
+
+#define TPI_TOTAL_PIX_LSB					(0x04)
+#define TPI_TOTAL_PIX_MSB					(0x05)
+
+#define TPI_TOTAL_LINES_LSB					(0x06)
+#define TPI_TOTAL_LINES_MSB					(0x07)
+
+// Pixel Repetition Data
+//======================
+
+#define TPI_PIX_REPETITION					(0x08)
+
+// TPI AVI Input and Output Format Data
+//=====================================
+
+/// AVI Input Format Data ================================================= ///
+
+#define TPI_INPUT_FORMAT_REG				(0x09)
+
+//Finish this...
+
+#define INPUT_COLOR_SPACE_MASK				(BIT_1 | BIT_0)
+#define INPUT_COLOR_SPACE_RGB				(0x00)
+#define INPUT_COLOR_SPACE_YCBCR444			(0x01)
+#define INPUT_COLOR_SPACE_YCBCR422			(0x02)
+#define INPUT_COLOR_SPACE_BLACK_MODE		(0x03)
+
+/// AVI Output Format Data ================================================ ///
+
+#define TPI_OUTPUT_FORMAT_REG				(0x0A)
+
+#define TPI_YC_Input_Mode					(0x0B)
+
+// TPI AVI InfoFrame Data
+//======================= 
+
+#define TPI_AVI_BYTE_0						(0x0C)
+#define TPI_AVI_BYTE_1						(0x0D)
+#define TPI_AVI_BYTE_2						(0x0E)
+#define TPI_AVI_BYTE_3						(0x0F)
+#define TPI_AVI_BYTE_4						(0x10)
+#define TPI_AVI_BYTE_5						(0x11)
+
+#define TPI_AUDIO_BYTE_0					(0xBF)
+
+#define TPI_INFO_FRM_DBYTE5					0xC8
+#define TPI_INFO_FRM_DBYTE6					0xC9
+
+#define TPI_END_TOP_BAR_LSB					(0x12)
+#define TPI_END_TOP_BAR_MSB					(0x13)
+
+#define TPI_START_BTM_BAR_LSB				(0x14)
+#define TPI_START_BTM_BAR_MSB				(0x15)
+
+#define TPI_END_LEFT_BAR_LSB				(0x16)
+#define TPI_END_LEFT_BAR_MSB				(0x17)
+
+#define TPI_END_RIGHT_BAR_LSB				(0x18)
+#define TPI_END_RIGHT_BAR_MSB				(0x19)
+
+// Colorimetry
+//============
+#define SET_EX_COLORIMETRY	0x0C	// Set TPI_AVI_BYTE_2 to extended colorimetry and use 
+									//TPI_AVI_BYTE_3
+
+// ===================================================== //
+
+#define TPI_SYSTEM_CONTROL_DATA_REG			(0x1A)
+
+#define LINK_INTEGRITY_MODE_MASK			(BIT_6)
+#define LINK_INTEGRITY_STATIC				(0x00)
+#define LINK_INTEGRITY_DYNAMIC				(0x40)
+
+#define TMDS_OUTPUT_CONTROL_MASK			(BIT_4)
+#define TMDS_OUTPUT_CONTROL_ACTIVE			(0x00)
+#define TMDS_OUTPUT_CONTROL_POWER_DOWN		(0x10)
+
+#define AV_MUTE_MASK						(BIT_3)
+#define AV_MUTE_NORMAL						(0x00)
+#define AV_MUTE_MUTED						(0x08)
+
+#define DDC_BUS_REQUEST_MASK				(BIT_2)
+#define DDC_BUS_REQUEST_NOT_USING			(0x00)
+#define DDC_BUS_REQUEST_REQUESTED			(0x04)
+
+#define DDC_BUS_GRANT_MASK					(BIT_1)
+#define DDC_BUS_GRANT_NOT_AVAILABLE			(0x00)
+#define DDC_BUS_GRANT_GRANTED				(0x02)
+
+#define OUTPUT_MODE_MASK					(BIT_0)
+#define OUTPUT_MODE_DVI						(0x00)
+#define OUTPUT_MODE_HDMI					(0x01)
+
+
+// TPI Identification Registers
+//=============================
+
+#define TPI_DEVICE_ID						(0x1B)
+#define TPI_DEVICE_REV_ID					(0x1C)
+
+#define TPI_RESERVED2						(0x1D)
+
+// ===================================================== //
+
+#define TPI_DEVICE_POWER_STATE_CTRL_REG		(0x1E)
+
+#define CTRL_PIN_CONTROL_MASK				(BIT_4)
+#define CTRL_PIN_TRISTATE					(0x00)
+#define CTRL_PIN_DRIVEN_TX_BRIDGE			(0x10)
+
+#define TX_POWER_STATE_MASK					(BIT_1 | BIT_0)
+#define TX_POWER_STATE_D0					(0x00)
+#define TX_POWER_STATE_D1					(0x01)
+#define TX_POWER_STATE_D2					(0x02)
+#define TX_POWER_STATE_D3					(0x03)
+
+// Configuration of I2S Interface
+//===============================
+
+#define TPI_I2S_EN							(0x1F)
+#define TPI_I2S_IN_CFG						(0x20)
+
+// Available only when TPI 0x26[7:6]=10 to select I2S input
+//=========================================================
+#define TPI_I2S_CHST_0						(0x21)
+#define TPI_I2S_CHST_1						(0x22)
+#define TPI_I2S_CHST_2						(0x23)
+#define TPI_I2S_CHST_3						(0x24)
+#define TPI_I2S_CHST_4						(0x25)
+
+
+// Available only when 0x26[7:6]=01
+//=================================
+#define TPI_SPDIF_HEADER					(0x24)
+#define TPI_AUDIO_HANDLING					(0x25)
+
+
+// Audio Configuration Regiaters
+//==============================
+#define TPI_AUDIO_INTERFACE_REG				(0x26)
+
+// Finish this...
+
+#define AUDIO_MUTE_MASK						(BIT_4)
+#define AUDIO_MUTE_NORMAL					(0x00)
+#define AUDIO_MUTE_MUTED					(0x10)
+
+
+
+
+
+
+#define TPI_AUDIO_SAMPLE_CTRL				(0x27)
+
+#define TPI_SPEAKER_CFG						(0xC7)
+#define TPI_CODING_TYPE_CHANNEL_COUNT					(0xC4)
+
+/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///
+
+/*\
+| | HDCP Implementation
+| |
+| | HDCP link security logic is implemented in certain transmitters; unique
+| |   keys are embedded in each chip as part of the solution. The security 
+| |   scheme is fully automatic and handled completely by the hardware.
+\*/
+
+/// HDCP Query Data Register ============================================== ///
+
+#define TPI_HDCP_QUERY_DATA_REG				(0x29)
+
+#define EXTENDED_LINK_PROTECTION_MASK		(BIT_7)
+#define EXTENDED_LINK_PROTECTION_NONE		(0x00)
+#define EXTENDED_LINK_PROTECTION_SECURE		(0x80)
+
+#define LOCAL_LINK_PROTECTION_MASK			(BIT_6)
+#define LOCAL_LINK_PROTECTION_NONE			(0x00)
+#define LOCAL_LINK_PROTECTION_SECURE		(0x40)
+
+#define LINK_STATUS_MASK					(BIT_5 | BIT_4)
+#define LINK_STATUS_NORMAL					(0x00)
+#define LINK_STATUS_LINK_LOST				(0x10)
+#define LINK_STATUS_RENEGOTIATION_REQ		(0x20)
+#define LINK_STATUS_LINK_SUSPENDED			(0x30)
+
+#define HDCP_REPEATER_MASK					(BIT_3)
+#define HDCP_REPEATER_NO					(0x00)
+#define HDCP_REPEATER_YES					(0x08)
+
+#define CONNECTOR_TYPE_MASK					(BIT_2 | BIT_0)
+#define CONNECTOR_TYPE_DVI					(0x00)
+#define CONNECTOR_TYPE_RSVD					(0x01)
+#define CONNECTOR_TYPE_HDMI					(0x04)
+#define CONNECTOR_TYPE_FUTURE				(0x05)
+
+#define PROTECTION_TYPE_MASK				(BIT_1)
+#define PROTECTION_TYPE_NONE				(0x00)
+#define PROTECTION_TYPE_HDCP				(0x02)
+
+/// HDCP Control Data Register ============================================ ///
+
+#define TPI_HDCP_CONTROL_DATA_REG			(0x2A)
+
+#define PROTECTION_LEVEL_MASK				(BIT_0)
+#define PROTECTION_LEVEL_MIN				(0x00)
+#define PROTECTION_LEVEL_MAX				(0x01)
+
+/// HDCP BKSV Registers =================================================== ///
+
+#define TPI_BKSV_1_REG						(0x2B)
+#define TPI_BKSV_2_REG						(0x2C)
+#define TPI_BKSV_3_REG						(0x2D)
+#define TPI_BKSV_4_REG						(0x2E)
+#define TPI_BKSV_5_REG						(0x2F)
+
+/// HDCP Revision Data Register =========================================== ///
+
+#define TPI_HDCP_REVISION_DATA_REG			(0x30)
+
+#define HDCP_MAJOR_REVISION_MASK			(BIT_7 | BIT_6 | BIT_5 | BIT_4)
+#define HDCP_MAJOR_REVISION_VALUE			(0x10)
+
+#define HDCP_MINOR_REVISION_MASK			(BIT_3 | BIT_2 | BIT_1 | BIT_0)
+#define HDCP_MINOR_REVISION_VALUE			(0x02)
+
+/// HDCP KSV and V' Value Data Register =================================== ///
+
+#define TPI_V_PRIME_SELECTOR_REG			(0x31)
+
+/// V' Value Readback Registers =========================================== ///
+
+#define TPI_V_PRIME_7_0_REG					(0x32)
+#define TPI_V_PRIME_15_9_REG				(0x33)
+#define TPI_V_PRIME_23_16_REG				(0x34)
+#define TPI_V_PRIME_31_24_REG				(0x35)
+
+/// HDCP AKSV Registers =================================================== ///
+
+#define TPI_AKSV_1_REG						(0x36)
+#define TPI_AKSV_2_REG						(0x37)
+#define TPI_AKSV_3_REG						(0x38)
+#define TPI_AKSV_4_REG						(0x39)
+#define TPI_AKSV_5_REG						(0x3A)
+
+/*\
+| | Interrupt Service
+| |
+| | TPI can be configured to generate an interrupt to the host to notify it of
+| |   various events. The host can either poll for activity or use an interrupt
+| |   handler routine. TPI generates on a single interrupt (INT) to the host.
+\*/
+
+/// Interrupt Enable Register ============================================= ///
+
+#define TPI_INTERRUPT_ENABLE_REG			(0x3C)
+
+#define HDCP_AUTH_STATUS_CHANGE_EN_MASK		(BIT_7)
+#define HDCP_AUTH_STATUS_CHANGE_DISABLE		(0x00)
+#define HDCP_AUTH_STATUS_CHANGE_ENABLE		(0x80)
+
+#define HDCP_VPRIME_VALUE_READY_EN_MASK		(BIT_6)
+#define HDCP_VPRIME_VALUE_READY_DISABLE		(0x00)
+#define HDCP_VPRIME_VALUE_READY_ENABLE		(0x40)
+
+#define HDCP_SECURITY_CHANGE_EN_MASK		(BIT_5)
+#define HDCP_SECURITY_CHANGE_DISABLE		(0x00)
+#define HDCP_SECURITY_CHANGE_ENABLE			(0x20)
+
+#define AUDIO_ERROR_EVENT_EN_MASK			(BIT_4)
+#define AUDIO_ERROR_EVENT_DISABLE			(0x00)
+#define AUDIO_ERROR_EVENT_ENABLE			(0x10)
+
+#define CPI_EVENT_NO_RX_SENSE_MASK			(BIT_3)
+#define CPI_EVENT_NO_RX_SENSE_DISABLE		(0x00)
+#define CPI_EVENT_NO_RX_SENSE_ENABLE		(0x08)
+
+#define RECEIVER_SENSE_EVENT_EN_MASK		(BIT_1)
+#define RECEIVER_SENSE_EVENT_DISABLE		(0x00)
+#define RECEIVER_SENSE_EVENT_ENABLE			(0x02)
+
+#define HOT_PLUG_EVENT_EN_MASK				(BIT_0)
+#define HOT_PLUG_EVENT_DISABLE				(0x00)
+#define HOT_PLUG_EVENT_ENABLE				(0x01)
+
+/// Interrupt Status Register ============================================= ///
+
+#define TPI_INTERRUPT_STATUS_REG			(0x3D)
+
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_MASK	(BIT_7)
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_NO	(0x00)
+#define HDCP_AUTH_STATUS_CHANGE_EVENT_YES	(0x80)
+
+#define HDCP_VPRIME_VALUE_READY_EVENT_MASK	(BIT_6)
+#define HDCP_VPRIME_VALUE_READY_EVENT_NO	(0x00)
+#define HDCP_VPRIME_VALUE_READY_EVENT_YES	(0x40)
+
+#define HDCP_SECURITY_CHANGE_EVENT_MASK		(BIT_5)
+#define HDCP_SECURITY_CHANGE_EVENT_NO		(0x00)
+#define HDCP_SECURITY_CHANGE_EVENT_YES		(0x20)
+
+#define AUDIO_ERROR_EVENT_MASK				(BIT_4)
+#define AUDIO_ERROR_EVENT_NO				(0x00)
+#define AUDIO_ERROR_EVENT_YES				(0x10)
+
+#define CPI_EVENT_MASK						(BIT_3)
+#define CPI_EVENT_NO						(0x00)
+#define CPI_EVENT_YES						(0x08)
+#define RX_SENSE_MASK						(BIT_3)		// This bit is dual purpose depending on the value of 0x3C[3]
+#define RX_SENSE_NOT_ATTACHED				(0x00)
+#define RX_SENSE_ATTACHED					(0x08)
+
+#define HOT_PLUG_PIN_STATE_MASK				(BIT_2)
+#define HOT_PLUG_PIN_STATE_LOW				(0x00)
+#define HOT_PLUG_PIN_STATE_HIGH				(0x04)
+
+#define RECEIVER_SENSE_EVENT_MASK			(BIT_1)
+#define RECEIVER_SENSE_EVENT_NO				(0x00)
+#define RECEIVER_SENSE_EVENT_YES			(0x02)
+
+#define HOT_PLUG_EVENT_MASK					(BIT_0)
+#define HOT_PLUG_EVENT_NO					(0x00)
+#define HOT_PLUG_EVENT_YES					(0x01)
+
+/// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///
+
+// Sync Register Configuration and Sync Monitoring Registers
+//==========================================================
+
+#define TPI_SYNC_GEN_CTRL					(0x60)
+#define TPI_SYNC_POLAR_DETECT				(0x61)
+
+// Explicit Sync DE Generator Registers (TPI 0x60[7]=0)
+//=====================================================
+
+#define TPI_DE_DLY							(0x62)
+#define TPI_DE_CTRL							(0x63)
+#define TPI_DE_TOP							(0x64)
+
+#define TPI_RESERVED4						(0x65)
+
+#define TPI_DE_CNT_7_0						(0x66)
+#define TPI_DE_CNT_11_8						(0x67)
+
+#define TPI_DE_LIN_7_0						(0x68)
+#define TPI_DE_LIN_10_8						(0x69)
+
+#define TPI_DE_H_RES_7_0					(0x6A)
+#define TPI_DE_H_RES_10_8					(0x6B)
+
+#define TPI_DE_V_RES_7_0					(0x6C)
+#define TPI_DE_V_RES_10_8					(0x6D)
+
+// Embedded Sync Register Set (TPI 0x60[7]=1)
+//===========================================
+
+#define TPI_HBIT_TO_HSYNC_7_0				(0x62)
+#define TPI_HBIT_TO_HSYNC_9_8				(0x63)
+#define TPI_FIELD_2_OFFSET_7_0				(0x64)
+#define TPI_FIELD_2_OFFSET_11_8				(0x65)
+#define TPI_HWIDTH_7_0						(0x66)
+#define TPI_HWIDTH_8_9						(0x67)
+#define TPI_VBIT_TO_VSYNC					(0x68)
+#define TPI_VWIDTH							(0x69)
+
+// TPI Enable Register
+//====================
+
+#define TPI_ENABLE							(0xC7)
+
+// Misc InfoFrames
+//================
+#define MISC_INFO_FRAMES_CTRL				(0xBF)
+#define MISC_INFO_FRAMES_TYPE				(0xC0)
+#define MISC_INFO_FRAMES_VER				(0xC1)
+#define MISC_INFO_FRAMES_LEN				(0xC2)
+#define MISC_INFO_FRAMES_CHKSUM				(0xC3)
+
diff --git a/drivers/video/hdmi/si9022/SIITypeDefs.h b/drivers/video/hdmi/si9022/SIITypeDefs.h
new file mode 100755
index 0000000..540ac4d
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIITypeDefs.h
@@ -0,0 +1,31 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+//typedef unsigned char		bool;
+//typedef unsigned char		byte;
+//typedef unsigned short		word;
+//typedef unsigned long		dword;
+
+#define MAX_COMMAND_ARGUMENTS		24
+
+// API Interface Data Structures
+//==============================
+typedef struct {
+	unsigned char OpCode;
+	unsigned char CommandLength;
+	unsigned char Arg[MAX_COMMAND_ARGUMENTS];
+	unsigned char CheckSum;
+} API_Cmd;
+
+
+typedef enum {
+	SS_FATAL_ERROR,
+	SS_RX_NOT_READY,
+	SS_RX_NEW_VIDEO_MODE,
+	SS_TX_READY
+} SYSTEM_STATE;
diff --git a/drivers/video/hdmi/si9022/SIIVideoModeTable.c b/drivers/video/hdmi/si9022/SIIVideoModeTable.c
new file mode 100755
index 0000000..8e8318b
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIVideoModeTable.c
@@ -0,0 +1,293 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+#include "SIIdefs.h"
+#include "SIITypeDefs.h"
+#include "SIIConstants.h"
+#include "SIIVideoModeTable.h"     
+
+#define _720p_60Hz						4
+#define _1080i_60Hz						5
+#define _720P_50Hz						19
+#define _1080i_50Hz						20
+#define _1080p_24Hz						32
+
+const VModeInfoType VModesTable[] = {
+        // M.Id SubM-   PixClk  RefTVPolHPol            RefrRt {HTot, VTot} {HStrt,VStrt}{HRes,VRes}  -AR- 656 - PixRep
+/*0*/     {{ 1,  0, NSM},  2517, {ProgrVNegHNeg,           6000, { 800,  525}}, {144, 35}, { 640, 480}, _4,               {0,  96, 2, 33,  48,  16, 10,    0}, 0, 15}, // 1. 640 x 480p @ 60 VGA
+/*1*/     {{ 2,  3, NSM},  2700, {ProgrVNegHNeg,           6000, { 858,  525}}, {122, 36}, { 720, 480}, _4or16,   {0,  62, 6, 30,  60,  19,  9,    0}, 0, 15}, // 2,3 720 x 480p
+/*2*/     {{ 4,  0, NSM},  7425, {ProgrVPosHPos,           6000, {1650,  750}}, {260, 25}, {1280, 720}, _16,              {0,  40, 5, 20, 220, 110,  5,    0}, 0, 15}, // 4   1280 x 720p
+/*3*/     {{ 5,  0, NSM},  7425, {InterlaceVPosHPos,       6000, {2200,  562}}, {192, 20}, {1920,1080}, _16,              {0,  44, 5, 15, 148,  88,  2, 1100}, 0, 15}, // 5 1920 x 1080i
+/*4*/     {{ 6,  7, NSM},  2700, {InterlaceVNegHNeg,       6000, {1716,  264}}, {119, 18}, { 720, 480}, _4or16,   {3,  62, 3, 15, 114,  17,  5,  429}, 1, 15}, // 6,7 1440 x 480i,pix repl
+/*5*/     {{ 8,  9,   1},  2700, {ProgrVNegHNeg,           6000, {1716,  262}}, {119, 18}, {1440, 240}, _4or16,   {0, 124, 3, 15, 114,  38,  4,    0}, 1, 15}, // 8,9(1) 1440 x 240p
+/*6*/  	{{ 8,  9,   2},  2700, {ProgrVNegHNeg,           6000, {1716,  263}}, {119, 18}, {1440, 240}, _4or16,   {0, 124, 3, 15, 114,  38,  4,    0}, 1, 15}, // 8,9(2) 1440 x 240p
+/*7*/  	{{10, 11, NSM},  5400, {InterlaceVNegHNeg,       6000, {3432,  525}}, {238, 18}, {2880, 480}, _4or16,   {0, 248, 3, 15, 228,  76,  4, 1716}, 0, 15}, // 10,11 2880 x 480i
+/*8*/  	{{12, 13,   1},  5400, {ProgrVNegHNeg,           6000, {3432,  262}}, {238, 18}, {2880, 240}, _4or16,   {0, 248, 3, 15, 228,  76,  4,    0}, 1, 15}, // 12,13(1) 2880 x 240p
+/*9*/  	{{12, 13,   2},  5400, {ProgrVNegHNeg,           6000, {3432,  263}}, {238, 18}, {2880, 240}, _4or16,   {0, 248, 3, 15, 228,  76,  4,    0}, 1, 15}, // 12,13(2) 2880 x 240p
+/*10*/    {{14, 15, NSM},  5400, {ProgrVNegHNeg,           6000, {1716,  525}}, {244, 36}, {1440, 480}, _4or16,   {0, 124, 6, 30, 120,  32,  9,    0}, 0, 15}, // 14,15 1440 x 480p
+/*11*/    {{16,  0, NSM}, 14835, {ProgrVPosHPos,           6000, {2200, 1125}}, {192, 41}, {1920,1080}, _16,              {0,  44, 5, 36, 148,  88,  4,    0}, 0, 15}, // 16 1920 x 1080p
+/*12*/    {{17, 18, NSM},  2700, {ProgrVNegHNeg,           5000, { 864,  625}}, {132, 44}, { 720, 576}, _4or16,   {0,  64, 5, 39,  68,  12,  5,    0}, 0, 15}, // 17,18 720 x 576p
+/*13*/    {{19,  0, NSM},  7425, {ProgrVPosHPos,           5000, {1980,  750}}, {260, 25}, {1280, 720}, _16,              {0,  40, 5, 20, 220, 440,  5,    0}, 0, 15}, // 19 1280 x 720p
+/*14*/    {{20,  0, NSM},  7425, {InterlaceVPosHPos,       5000, {2640, 1125}}, {192, 20}, {1920,1080}, _16,              {0,  44, 5, 15, 148, 528,  2, 1320}, 0, 15}, // 20 1920 x 1080i
+/*15*/    {{21, 22, NSM},  2700, {InterlaceVNegHNeg,       5000, {1728,  625}}, {132, 22}, { 720, 576}, _4,               {3,  63, 3, 19, 138,  24,  2,  432}, 1, 15}, // 21,22 1440 x 576i
+/*16*/   	{{23, 24,   1},  2700, {ProgrVNegHNeg,           5000, {1728,  312}}, {132, 22}, {1440, 288}, _4or16,   {0, 126, 3, 19, 138,  24,  2,    0}, 1, 15}, // 23,24(1) 1440 x 288p
+/*17*/  	{{23, 24,   2},  2700, {ProgrVNegHNeg,           5000, {1728,  313}}, {132, 22}, {1440, 288}, _4or16,   {0, 126, 3, 19, 138,  24,  2,    0}, 1, 15}, // 23,24(2) 1440 x 288p
+/*18*/  	{{23, 24,   3},  2700, {ProgrVNegHNeg,           5000, {1728,  314}}, {132, 22}, {1440, 288}, _4or16,   {0, 126, 3, 19, 138,  24,  2,    0}, 1, 15}, // 23,24(3) 1440 x 288p
+/*19*/  	{{25, 26, NSM},  5400, {InterlaceVNegHNeg,       5000, {3456,  625}}, {264, 22}, {2880, 576}, _4or16,   {0, 252, 3, 19, 276,  48,  2, 1728}, 1, 15}, // 25,26 2880 x 576i
+/*20*/  	{{27, 28,   1},  5400, {ProgrVNegHNeg,           5000, {3456,  312}}, {264, 22}, {2880, 288}, _4or16,   {0, 252, 3, 19, 276,  48,  2,    0}, 1, 15}, // 27,28(1) 2880 x 288p
+/*21*/    {{27, 28,   2},  5400, {ProgrVNegHNeg,           5000, {3456,  313}}, {264, 22}, {2880, 288}, _4or16,   {0, 252, 3, 19, 276,  48,  3,    0}, 1, 15}, // 27,28(2) 2880 x 288p
+/*22*/    {{27, 28,   3},  5400, {ProgrVNegHNeg,           5000, {3456,  314}}, {264, 22}, {2880, 288}, _4or16,   {0, 252, 3, 19, 276,  48,  4,    0}, 1, 15}, // 27,28(3) 2880 x 288p
+/*23*/    {{29, 30, NSM},  5400, {ProgrVPosHNeg,           5000, {1728,  625}}, {264, 44}, {1440, 576}, _4or16,   {0, 128, 5, 39, 136,  24,  5,    0}, 0, 15}, // 29,30 1440 x 576p
+/*24*/    {{31,  0, NSM}, 14850, {ProgrVPosHPos,           5000, {2640, 1125}}, {192, 41}, {1920,1080}, _16,              {0,  44, 5, 36, 148, 528,  4,    0}, 0, 15}, // 31(1) 1920 x 1080p
+/*25*/    {{32, 0,NSM},           7417,   {ProgrVPosHPos,     2400,   {2750,1125}},   {192,41},   {1920,1080},    _16,    { 0,44,5, 36,148,638, 4, 0},    0, 15}, // 32(2) 1920 x 1080p
+/*26*/  	{{33,  0, NSM},  7425, {ProgrVPosHPos,           2500, {2640, 1125}}, {192, 41}, {1920,1080}, _16,              {0,  44, 5, 36, 148, 528,  4,    0}, 0, 15}, // 33(3) 1920 x 1080p
+/*27*/  	{{34,  0, NSM},  7417, {ProgrVPosHPos,           3000, {2200, 1125}}, {192, 41}, {1920,1080}, _16,              {0,  44, 5, 36, 148, 528,  4,    0}, 0, 15}, // 34(4) 1920 x 1080p
+/*28*/  	{{35, 36, NSM}, 10800, {ProgrVNegHNeg,           5994, {3432,  525}}, {488, 36}, {2880, 480}, _4or16,   {0, 248, 6, 30, 240,  64, 10,    0}, 0, 15}, // 35, 36 2880 x 480p@59.94/60Hz
+/*29*/  	{{37, 38, NSM}, 10800, {ProgrVNegHNeg,           5000, {3456,  625}}, {272, 39}, {2880, 576}, _4or16,   {0, 256, 5, 40, 272,  48,  5,    0}, 0, 15}, // 37, 38 2880 x 576p@50Hz
+/*30*/    {{39,  0, NSM},  7200, {InterlaceVNegHNeg,       5000, {2304, 1250}}, {352, 62}, {1920,1080}, _16,              {0, 168, 5, 87, 184,  32, 24,    0}, 0, 15}, // 39 1920 x 1080i@50Hz
+/*31*/    {{40,  0, NSM}, 14850, {InterlaceVPosHPos,      10000, {2640, 1125}}, {192, 20}, {1920,1080}, _16,              {0,  44, 5, 15, 148, 528,  2, 1320}, 0, 15}, // 40 1920 x 1080i@100Hz
+/*32*/    {{41,  0, NSM}, 14850, {InterlaceVPosHPos,      10000, {1980,  750}}, {260, 25}, {1280, 720}, _16,              {0,  40, 5, 20, 220, 400,  5,    0}, 0, 15}, // 41 1280 x 720p@100Hz
+/*33*/    {{42, 43, NSM},  5400, {ProgrVNegHNeg,          10000, { 864,  144}}, {132, 44}, { 720, 576}, _4or16,   {0,  64, 5, 39,  68,  12,  5,    0}, 0, 15}, // 42, 43, 720p x 576p@100Hz
+/*34*/    {{44, 45, NSM},  5400, {InterlaceVNegHNeg,      10000, { 864,  625}}, {132, 22}, { 720, 576}, _4or16,   {0,  63, 3, 19,  69,  12,  2,  432}, 1, 15}, // 44, 45, 720p x 576i@100Hz, pix repl
+/*35*/    {{46,  0, NSM}, 14835, {InterlaceVPosHPos,      11988, {2200, 1125}}, {192, 20}, {1920,1080}, _16,              {0,  44, 5, 15, 149,  88,  2, 1100}, 0, 15}, // 46, 1920 x 1080i@119.88/120Hz
+/*36*/  	{{47,  0, NSM}, 14835, {ProgrVPosHPos,          11988, {1650,  750}}, {260, 25}, {1280, 720}, _16,              {0,  40, 5, 20, 220, 110,  5, 1100}, 0, 15}, // 47, 1280 x 720p@119.88/120Hz
+/*37*/  	{{48, 49, NSM},  5400, {ProgrVNegHNeg,          11988, { 858,  525}}, {122, 36}, { 720, 480}, _4or16,   {0,  62, 6, 30,  60,  16, 10,    0}, 0, 15}, // 48, 49 720 x 480p@119.88/120Hz
+/*38*/  	{{50, 51, NSM},  5400, {InterlaceVNegHNeg,      11988, { 858,  525}}, {119, 18}, { 720, 480}, _4or16,   {0,  62, 3, 15,  57,  19,  4,  429}, 1, 15}, // 50, 51 720 x 480i@119.88/120Hz
+/*39*/  	{{52, 53, NSM}, 10800, {ProgrVNegHNeg,          20000, { 864,  625}}, {132, 44}, { 720, 576}, _4or16,   {0,  64, 5, 39,  68,  12,  5,    0}, 0, 15}, // 52, 53, 720 x 576p@200Hz
+/*40*/ 	{{54, 55, NSM}, 10800, {InterlaceVNegHNeg,      20000, { 864,  625}}, {132, 22}, { 720, 576}, _4or16,   {0,  63, 3, 19,  69,  12,  2,  432}, 1, 15}, // 54, 55, 1440 x 576i @200Hz, pix repl
+/*41*/ 	{{56, 57, NSM}, 10800, {ProgrVNegHNeg,          24000, { 858,  525}}, {122, 42}, { 720, 480}, _4or16,   {0,  62, 6, 30,  60,  16,  9,    0}, 0, 15}, // 56, 57, 720 x 480p @239.76/240Hz
+/*42*/ 	{{58, 59, NSM}, 10800, {InterlaceVNegHNeg,      24000, { 858,  525}}, {119, 18}, { 720, 480}, _4or16,   {0,  62, 3, 15,  57,  19,  4,  429}, 1, 15}, // 58, 59, 1440 x 480i @239.76/240Hz, pix repl
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// 3D Modes:
+
+/*43*/     {{ 4, 0,NSM},           14835,   {ProgrVPosHPos,     6000,   {1650,750}},    {260, 25},  {1280,720},     _16,    {0,40,5,20,220,110,5,0},        0,  0},// 3D, 4, 1280 x 720p/60Hz, Frame Packing
+/*44*/     {{ 4, 0,NSM},           14835,   {ProgrVPosHPos,     6000,   {1650,750}},    {260, 25},  {1280,720},     _16,    {0,40,5,20,220,110,5,0},        0,  3},// 3D, 4, 1280 x 720p/60Hz, Side-by-Side (Full)
+/*45*/     {{ 4, 0,NSM},           14835,   {ProgrVPosHPos,     6000,   {1650,750}},    {260, 25},  {1280,720},     _16,    {0,40,5,20,220,110,5,0},        0,  4},// 3D, 4, 1280 x 720p/60Hz, L+Depth
+/*46*/     {{ 5, 0,NSM},           14835,   {InterlaceVPosHPos, 6000,   {2200,562}},    {192,20},   {1920,1080},    _16,    {0,44,5,15,148,88,2,1100},      0, 0}, // 3D, 5, 1920 x 1080i/60Hz, Frame Packing
+/*47*/     {{ 5, 0,NSM},           7417,   {InterlaceVPosHPos, 6000,   {2200,562}},    {192,20},   {1920,1080},    _16,    {0,44,5,15,148,88,2,1100},       0, 8}, // 3D, 5, 1920 x 1080i/60Hz, Side-by-Side (Half)
+/*48*/     {{19, 0,NSM},           14850,   {ProgrVPosHPos,     5000,   {1980,750}},    {260,25},   {1280,720},     _16,    {0,40,5, 20,220,440, 5, 0},     0,  0}, // 3D, 19, 1280 x 720p/50Hz, Frame Packing
+/*49*/     {{19, 0,NSM},           14850,   {ProgrVPosHPos,     5000,   {1980,750}},    {260,25},   {1280,720},     _16,    {0,40,5, 20,220,440, 5, 0},     0,  3}, // 3D, 19, 1280 x 720p/50Hz, Side-by-Side (Full)
+/*50*/     {{19, 0,NSM},           14850,   {ProgrVPosHPos,     5000,   {1980,750}},    {260,25},   {1280,720},     _16,    {0,40,5, 20,220,440, 5, 0},     0,  4}, // 3D, 19, 1280 x 720p/50Hz, L+Depth
+/*51*/     {{20, 0,NSM},           14850,   {InterlaceVPosHPos, 5000,   {2640, 1125}},  {192,20},   {1920,1080},    _16,    {0,44,5,15,148,528, 2,1320},    0,  0}, // 3D, 20, 1920 x 1080i/50Hz, Frame Packing
+/*52*/     {{20, 0,NSM},           7425,   {InterlaceVPosHPos, 5000,   {2640, 1125}},  {192,20},   {1920,1080},    _16,    {0,44,5,15,148,528, 2,1320},     0,  8}, // 3D, 20, 1920 x 1080i/50Hz, Side-by-Side (Half)
+/*53*/     {{32, 0,NSM},           14835,   {ProgrVPosHPos,     2400,   {2750,1125}},   {192,41},   {1920,1080},    _16,    { 0,44,5, 36,148,638, 4, 0},    0, 0}, // 3D, 32(2), 1920 x 1080p/24Hz, Frame Packing
+/*54*/     {{32, 0,NSM},           14835,   {ProgrVPosHPos,     2400,   {2750,1125}},   {192,41},   {1920,1080},    _16,    { 0,44,5, 36,148,638, 4, 0},    0, 3}, // 3D, 32(2), 1920 x 1080p/24Hz, Side-by-Side (Full)
+/*55*/     {{32, 0,NSM},           14835,   {ProgrVPosHPos,     2400,   {2750,1125}},   {192,41},   {1920,1080},    _16,    { 0,44,5, 36,148,638, 4, 0},    0, 3}, // 3D, 32(2), 1920 x 1080p/24Hz, L+Depth
+
+
+
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+// NOTE: DO NOT ATTEMPT INPUT RESOLUTIONS THAT REQUIRE PIXEL CLOCK FREQUENCIES HIGHER THAN THOSE SUPPOTED BY THE TRANSMITTER CHIP
+
+//                          1         2                 3       4    5         6 7          8   9      10    11, 13, 15
+/*56*/          {{PC_BASE, 0,NSM},      3150,   {ProgrVNegHPos,     8508,   {832, 445}},    {160,63},   {640,350},   _16,  {0,64,3,60,96,32,32, 0}, 0, 15}, // 640x350@85.08
+/*57*/          {{PC_BASE+1, 0,NSM},    3150,   {ProgrVPosHNeg,     8508,   {832, 445}},    {160,44},   {640,400},   _16,  {0,64,3,41,96,32,1, 0},  0, 15}, // 640x400@85.08
+/*58*/          {{PC_BASE+2, 0,NSM},    2700,   {ProgrVPosHNeg,     7008,   {900, 449}},    {0,0},      {720,400},   _16,  {0,0,0,0,0,0,0, 0},      0, 15}, // 720x400@70.08
+/*59*/          {{PC_BASE+3, 0,NSM},    3500,   {ProgrVPosHNeg,     8504,   {936, 446}},    {20,45},    {720,400},   _16,  {0,72,3,42,108,36,1, 0}, 0, 15}, // 720x400@85.04
+/*60*/        {{PC_BASE+4, 0,NSM},    2517,   {ProgrVNegHNeg,     5994,   {800, 525}},    {144,35},   {640,480},   _4,  {0,96,2,33,48,16,10,0},  0, 15}, // 640x480@59.94
+/*61*/        {{PC_BASE+5, 0,NSM},    3150,   {ProgrVNegHNeg,     7281,   {832, 520}},    {144,31},   {640,480},   _4,  {0,40,3,28,128,128,9,0}, 0, 15}, // 640x480@72.80
+/*62*/        {{PC_BASE+6, 0,NSM},    3150,   {ProgrVNegHNeg,     7500,   {840, 500}},    {21,19},    {640,480},   _4,  {0,64,3,28,128,24,9, 0}, 0, 15}, // 640x480@75.00
+/*63*/        {{PC_BASE+7,0,NSM},     3600,   {ProgrVNegHNeg,     8500,   {832, 509}},    {168,28},   {640,480},   _4,  {0,56,3,25,128,24,9, 0}, 0, 15}, // 640x480@85.00
+/*64*/        {{PC_BASE+8,0,NSM},     3600,   {ProgrVPosHPos,     5625,   {1024, 625}},   {200,24},   {800,600},   _4,  {0,72,2,22,128,24,1, 0}, 0, 15}, // 800x600@56.25
+/*65*/        {{PC_BASE+9,0,NSM},     4000,   {ProgrVPosHPos,     6032,   {1056, 628}},   {216,27},   {800,600},   _4,  {0,128,4,23,88,40,1, 0}, 0, 15}, // 800x600@60.317
+/*66*/        {{PC_BASE+10,0,NSM},    5000,   {ProgrVPosHPos,     7219,   {1040, 666}},   {184,29},   {800,600},   _4,  {0,120,6,23,64,56,37,0}, 0, 15}, // 800x600@72.19
+/*67*/        {{PC_BASE+11,0,NSM},    4950,   {ProgrVPosHPos,     7500,   {1056, 625}},   {240,24},   {800,600},   _4,  {0,80,3,21,160,16,1,0},  0, 15}, // 800x600@75
+/*68*/        {{PC_BASE+12,0,NSM},    5625,   {ProgrVPosHPos,     8506,   {1048, 631}},   {216,30},   {800,600},   _4,  {0,64,3,27,152,32,1,0},  0, 15}, // 800x600@85.06
+/*69*/        {{PC_BASE+13,0,NSM},    6500,   {ProgrVNegHNeg,     6000,   {1344, 806}},   {296,35},   {1024,768},  _4,  {0,136,6,29,160,24,3,0}, 0, 15}, // 1024x768@60
+/*70*/        {{PC_BASE+14,0,NSM},    7500,   {ProgrVNegHNeg,     7007,   {1328, 806}},   {280,35},   {1024,768},  _4,  {0,136,6,19,144,24,3,0}, 0, 15}, // 1024x768@70.07
+/*71*/        {{PC_BASE+15,0,NSM},    7875,   {ProgrVPosHPos,     7503,   {1312, 800}},   {272,31},   {1024,768},  _4,  {0,96,3,28,176,16,1,0},  0, 15}, // 1024x768@75.03
+/*72*/        {{PC_BASE+16,0,NSM},    9450,   {ProgrVPosHPos,     8500,   {1376, 808}},   {304,39},   {1024,768},  _4,  {0,96,3,36,208,48,1,0},  0, 15}, // 1024x768@85
+/*73*/        {{PC_BASE+17,0,NSM},   10800,   {ProgrVPosHPos,     7500,   {1600, 900}},   {384,35},   {1152,864},  _4,  {0,128,3,32,256,64,1,0}, 0, 15}, // 1152x864@75
+/*74*/        {{PC_BASE+18,0,NSM},   16200,   {ProgrVPosHPos,     6000,   {2160, 1250}},  {496,49},   {1600,1200}, _4,  {0,304,3,46,304,64,1,0}, 0, 15}, // 1600x1200@60
+/*75*/        {{PC_BASE+19,0,NSM},    6825,   {ProgrVNegHPos,     6000,   {1440, 790}},   {112,19},   {1280,768},  _16,  {0,32,7,12,80,48,3,0},   0, 15}, // 1280x768@59.95
+/*76*/        {{PC_BASE+20,0,NSM},    7950,   {ProgrVPosHNeg,     5987,   {1664, 798}},   {320,27},   {1280,768},  _16,  {0,128,7,20,192,64,3,0}, 0, 15}, // 1280x768@59.87
+/*77*/        {{PC_BASE+21,0,NSM},   10220,   {ProgrVPosHNeg,     6029,   {1696, 805}},   {320,27},   {1280,768},  _16,  {0,128,7,27,208,80,3,0}, 0, 15}, // 1280x768@74.89
+/*78*/        {{PC_BASE+22,0,NSM},   11750,   {ProgrVPosHNeg,     8484,   {1712, 809}},   {352,38},   {1280,768},  _16,  {0,136,7,31,216,80,3,0}, 0, 15}, // 1280x768@85
+/*79*/        {{PC_BASE+23,0,NSM},   10800,   {ProgrVPosHPos,     6000,   {1800, 1000}},  {424,39},   {1280,960},  _4,  {0,112,3,36,312,96,1,0}, 0, 15}, // 1280x960@60
+/*80*/        {{PC_BASE+24,0,NSM},   14850,   {ProgrVPosHPos,     8500,   {1728, 1011}},  {384,50},   {1280,960},  _4,  {0,160,3,47,224,64,1,0}, 0, 15}, // 1280x960@85
+/*81*/        {{PC_BASE+25,0,NSM},   10800,   {ProgrVPosHPos,     6002,   {1688, 1066}},  {360,41},   {1280,1024}, _4,  {0,112,3,38,248,48,1,0}, 0, 15}, // 1280x1024@60
+/*82*/        {{PC_BASE+26,0,NSM},   13500,   {ProgrVPosHPos,     7502,   {1688, 1066}},  {392,41},   {1280,1024}, _4,  {0,144,3,38,248,16,1, 0},0, 15}, // 1280x1024@75
+/*83*/        {{PC_BASE+27,0,NSM},   15750,   {ProgrVPosHPos,     8502,   {1728, 1072}},  {384,47},   {1280,1024}, _4,  {0,160,3,4,224,64,1, 0}, 0, 15}, // 1280x1024@85
+/*84*/        {{PC_BASE+28,0,NSM},    8550,   {ProgrVPosHPos,     6002,   {1792, 795}},   {368,24},   {1360,768},  _16,  {0,112,6,18,256,64,3,0}, 0, 15}, // 1360x768@60
+/*85*/        {{PC_BASE+29,0,NSM},   10100,   {ProgrVNegHPos,     5995,   {1560, 1080}},  {112,27},   {1400,1050}, _4,  {0,32,4,23,80,48,3,0},   0, 15}, // 1400x105@59.95
+/*86*/        {{PC_BASE+30,0,NSM},   12175,   {ProgrVPosHNeg,     5998,   {1864, 1089}},  {376,36},   {1400,1050}, _4,  {0,144,4,32,232,88,3,0}, 0, 15}, // 1400x105@59.98
+/*87*/        {{PC_BASE+31,0,NSM},   15600,   {ProgrVPosHNeg,     7487,   {1896, 1099}},  {392,46},   {1400,1050}, _4,  {0,144,4,22,248,104,3,0},0, 15}, // 1400x105@74.87
+/*88*/        {{PC_BASE+32,0,NSM},   17950,   {ProgrVPosHNeg,     8496,   {1912, 1105}},  {408,52},   {1400,1050}, _4,  {0,152,4,48,256,104,3,0},0, 15}, // 1400x105@84.96
+/*89*/        {{PC_BASE+33,0,NSM},   17550,   {ProgrVPosHPos,     6500,   {2160, 1250}},  {496,49},   {1600,1200}, _4,  {0,192,3,46,304,64,1,0}, 0, 15}, // 1600x1200@65
+/*90*/        {{PC_BASE+34,0,NSM},   18900,   {ProgrVPosHPos,     7000,   {2160, 1250}},  {496,49},   {1600,1200}, _4,  {0,192,3,46,304,64,1,0}, 0, 15}, // 1600x1200@70
+/*91*/        {{PC_BASE+35,0,NSM},   20250,   {ProgrVPosHPos,     7500,   {2160, 1250}},  {496,49},   {1600,1200}, _4,  {0,192,3,46,304,64,1,0}, 0, 15}, // 1600x1200@75
+/*92*/        {{PC_BASE+36,0,NSM},   22950,   {ProgrVPosHPos,     8500,   {2160, 1250}},  {496,49},   {1600,1200}, _4,  {0,192,3,46,304,64,1,0}, 0, 15}, // 1600x1200@85
+/*93*/        {{PC_BASE+37,0,NSM},   20475,   {ProgrVPosHNeg,     6000,   {2448, 1394}},  {528,49},   {1792,1344}, _4,  {0,200,3,46,328,128,1,0},0, 15}, // 1792x1344@60
+/*94*/        {{PC_BASE+38,0,NSM},   26100,   {ProgrVPosHNeg,     7500,   {2456, 1417}},  {568,72},   {1792,1344}, _4,  {0,216,3,69,352,96,1,0}, 0, 15}, // 1792x1344@74.997
+/*95*/        {{PC_BASE+39,0,NSM},   21825,   {ProgrVPosHNeg,     6000,   {2528, 1439}},  {576,46},   {1856,1392}, _4,  {0,224,3,43,352,96,1,0}, 0, 15}, // 1856x1392@60
+/*96*/        {{PC_BASE+40,0,NSM},   28800,   {ProgrVPosHNeg,     7500,   {2560, 1500}},  {576,107},  {1856,1392}, _4,  {0,224,3,104,352,128,1,0},0, 15}, // 1856x1392@75
+/*97*/        {{PC_BASE+41,0,NSM},   15400,   {ProgrVNegHPos,     5995,   {2080, 1235}},  {112,32},   {1920,1200}, _16,  {0,32,6,26,80,48,3,0},    0, 15}, // 1920x1200@59.95
+/*98*/        {{PC_BASE+42,0,NSM},   19325,   {ProgrVPosHNeg,     5988,   {2592, 1245}},  {536,42},   {1920,1200}, _16,  {0,200,6,36,336,136,3,0}, 0, 15}, // 1920x1200@59.88
+/*99*/        {{PC_BASE+43,0,NSM},   24525,   {ProgrVPosHNeg,     7493,   {2608, 1255}},  {552,52},   {1920,1200}, _16,  {0,208,6,46,344,136,3,0}, 0, 15}, // 1920x1200@74.93
+/*100*/        {{PC_BASE+44,0,NSM},   28125,   {ProgrVPosHNeg,     8493,   {2624, 1262}},  {560,59},   {1920,1200}, _16,  {0,208,6,53,352,144,3,0}, 0, 15}, // 1920x1200@84.93
+/*101*/        {{PC_BASE+45,0,NSM},   23400,   {ProgrVPosHNeg,     6000,   {2600, 1500}},  {552,59},   {1920,1440}, _4,  {0,208,3,56,344,128,1,0}, 0, 15}, // 1920x1440@60
+/*102*/        {{PC_BASE+46,0,NSM},   29700,   {ProgrVPosHNeg,     7500,   {2640, 1500}},  {576,59},   {1920,1440}, _4,  {0,224,3,56,352,144,1,0}, 0, 15}, // 1920x1440@75
+/*103*/        {{PC_BASE+47,0,NSM},   29700,   {ProgrVPosHNeg,     7500,   {2640, 1500}},  {576,59},   {1920,1440}, _4,  {0,224,3,56,352,144,1,0}, 0, 15}, // 1920x1440@75
+      };
+
+
+/////////////////////////////////////////////////////////////////////////////////////
+//
+// Aspect Ratio table defines the aspect ratio as function of VIC. This table
+// should be used in conjunction with the 861-D part of VModeInfoType VModesTable[]
+// (formats 0 - 59) because some formats that differ only in their AR are grouped
+// together (e.g., formats 2 and 3).
+
+/////////////////////////////////////////////////////////////////////////////////////
+const unsigned char AspectRatioTable[] = {
+	 _4,  _4, _16, _16, _16,  _4, _16,  _4, _16,  _4,
+	_16,  _4, _16,  _4, _16, _16,  _4, _16, _16, _16,
+	 _4, _16,  _4, _16,  _4, _16,  _4, _16,  _4, _16,
+	_16, _16, _16, _16,  _4, _16,  _4, _16, _16, _16,
+	_16,  _4, _16,  _4, _16, _16, _16,  _4, _16,  _4,
+	_16,  _4, _16,  _4, _16,  _4, _16,  _4, _16
+	};
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// FUNCTION      : ConvertVIC_To_VM_Index()
+//
+// PURPOSE       :  Convert Video Identification Code to the corresponding
+//                  index of VModesTable[]. Conversion also depends on the 
+//					value of the 3D_Structure parameter in the case of 
+//                  3D video format.
+//
+// INPUT PARAMS  : VIC to be converted; 3D_Structure value 
+//
+// OUTPUT PARAMS : None
+//
+// GLOBALS USED  : VModesTable[]
+//
+// RETURNS       : Index into VModesTable[] corrsponding to VIC
+//
+// Note         : Conversion is needed for 861-D formats only.
+//
+//////////////////////////////////////////////////////////////////////////////
+unsigned char ConvertVIC_To_VM_Index(unsigned char VIC, unsigned char _3D_Struct)
+{
+    unsigned char ConvertedVIC;
+    const unsigned char VIC2Index[] = {
+                                0,  0,  1,  1,  2,  3,  4,  4,  5,  5,
+                                7,  7,  8,  8, 10, 10, 11, 12, 12, 13,
+                               14, 15, 15, 16, 16, 19, 19, 20, 20, 23,
+                               23, 24, 25, 26, 27, 28, 28, 29, 29, 30,
+                               31, 32, 33, 33, 34, 34, 35, 36, 37, 37,
+                               38, 38, 39, 39, 40, 40, 41, 41, 42, 42
+                            };
+
+    VIC &= SEVEN_LSBITS;                // MSBit indicates if "native" (CEA-861-D, Table 33)
+
+    if (VIC < PC_BASE)                  // 861-D mode - return VModesTable[] index
+	{
+        ConvertedVIC = VIC2Index[VIC];
+
+		if (_3D_Struct != NO_3D_SUPPORT)		// 3D VIDEO Formats use different [] indices
+		{
+			switch (VIC)
+			{
+				case _720p_60Hz:
+					switch(_3D_Struct)
+					{
+						case FRAME_PACKING:
+							ConvertedVIC = 43;			// 720p/60Hz, Frame Packing => VModeTables line 43
+							break;
+
+						case SIDE_BY_SIDE_FULL:
+							ConvertedVIC = 44;			// 720p/60Hz, Side-by-Side (Full) => VModeTables line 44
+							break;
+						
+						case L_PLUS_DEPTH:
+							ConvertedVIC = 45;			// 720p/60Hz, L + Depth => VModeTables line 45
+							break;
+					}
+
+					break;
+
+				case _1080i_60Hz:
+					switch(_3D_Struct)
+					{
+						case FRAME_PACKING:
+							ConvertedVIC = 46;			// 1080i/60Hz, Frame Packing => VModeTables line 46
+							break;
+
+						case SIDE_BY_SIDE_HALF:
+							ConvertedVIC = 47;			// 1080i/60Hz, Side-by-Side (Full) => VModeTables line 47
+							break;
+					}
+
+					break;
+
+				case _720P_50Hz:
+					switch(_3D_Struct)
+					{
+						case FRAME_PACKING:
+							ConvertedVIC = 48;			// 720P/50Hz, Frame Packing => VModeTables line 48
+							break;
+
+						case SIDE_BY_SIDE_FULL:
+							ConvertedVIC = 49;			// 720p/50Hz, Side-by-Side (Full) => VModeTables line 49
+							break;
+						
+						case L_PLUS_DEPTH:
+							ConvertedVIC = 50;			// 720p/50Hz, L + Depth => VModeTables line 50
+							break;
+					}
+
+					break;
+
+				case _1080i_50Hz:
+					switch(_3D_Struct)
+					{
+						case FRAME_PACKING:
+							ConvertedVIC = 51;			// 1080i/60Hz, Frame Packing => VModeTables line 46
+							break;
+
+						case SIDE_BY_SIDE_HALF:
+							ConvertedVIC = 52;			// 1080i/60Hz, Side-by-Side (Full) => VModeTables line 47
+							break;
+					}
+
+					break;
+
+				case _1080p_24Hz:
+					switch(_3D_Struct)
+					{
+						case FRAME_PACKING:
+							ConvertedVIC = 53;			
+							break;
+
+						case SIDE_BY_SIDE_FULL:
+							ConvertedVIC = 54;			
+							break;
+
+						case L_PLUS_DEPTH:
+							ConvertedVIC = 55;			
+							break;
+					}
+
+					break;
+			}
+		}
+	}
+
+
+    else
+        ConvertedVIC = VIC;
+
+    return ConvertedVIC;
+}
+
+
+
diff --git a/drivers/video/hdmi/si9022/SIIVideoModeTable.h b/drivers/video/hdmi/si9022/SIIVideoModeTable.h
new file mode 100755
index 0000000..e7e5d25
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIVideoModeTable.h
@@ -0,0 +1,84 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+typedef struct {
+	unsigned char Mode_C1;
+	unsigned char Mode_C2;
+	unsigned char SubMode;
+} ModeIdType;
+
+typedef struct {
+	unsigned int Pixels;
+	unsigned int Lines;
+} PxlLnTotalType;
+
+typedef struct {
+	unsigned int H;
+	unsigned int V;
+} HVPositionType;
+
+typedef struct {
+	unsigned int H;
+	unsigned int V;
+} HVResolutionType;
+
+typedef struct{
+   unsigned char RefrTypeVHPol;
+   unsigned int VFreq;
+   PxlLnTotalType Total;
+} TagType;
+
+typedef struct {
+	unsigned char IntAdjMode;
+	unsigned int HLength;
+	unsigned char VLength;
+	unsigned int Top;
+	unsigned int Dly;
+	unsigned int HBit2HSync;
+	unsigned char VBit2VSync;
+	unsigned int Field2Offset;
+}  _656Type;
+
+typedef struct {
+	ModeIdType ModeId;
+	unsigned int PixClk;
+	TagType Tag;
+	HVPositionType Pos;
+	HVResolutionType Res;
+	unsigned char AspectRatio;
+	_656Type _656;
+	unsigned char PixRep;
+	unsigned char _3D_Struct;
+} VModeInfoType;
+
+#define NSM                     0   // No Sub-Mode
+
+#define ProgrVNegHNeg           0x00
+#define ProgrVNegHPos           0x01
+#define ProgrVPosHNeg           0x02
+#define ProgrVPosHPos           0x03
+
+#define InterlaceVNegHNeg       0x04
+#define InterlaceVPosHNeg       0x05
+#define InterlaceVNgeHPos       0x06
+#define InterlaceVPosHPos       0x07
+
+#define PC_BASE                 60
+
+// Aspect ratio
+//=============
+#define _4                      0   // 4:3
+#define _4or16                  1   // 4:3 or 16:9
+#define _16                     2   // 16:9
+
+//extern code const VModeInfoType VModesTable[];
+extern const VModeInfoType VModesTable[];
+//extern code const unsigned char AspectRatioTable[];
+extern const unsigned char AspectRatioTable[];
+
+unsigned char ConvertVIC_To_VM_Index(unsigned char, unsigned char);
diff --git a/drivers/video/hdmi/si9022/SIIdefs.h b/drivers/video/hdmi/si9022/SIIdefs.h
new file mode 100755
index 0000000..742b2f6
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIdefs.h
@@ -0,0 +1,141 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+void TXHAL_InitMicroGpios (void);
+void TXHAL_InitPreReset (void);
+void TXHAL_InitPostReset (void);
+
+#define  DEBUG	1
+
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// SiI9022A/24A 81BGA
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#define C_9022A_OR_C_9024A_81BGA
+
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// Micro Controller Pins
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//sbit PinI2CSCL = P1^7;
+//sbit PinI2CSDA = P1^6;
+
+//sbit GRANT = P2^2;      		// GPIO3 on BB Header pin 9
+//sbit REQUEST = P2^3;    		// GPIO4 on BB Header pin 10
+//sbit CYC_MICRO_RESET = P2^1; 	// Connected to 9022A/4A pin C3 (CRST#)
+//sbit DEBUG = P1^0;				// Jumper JP16 - Jumper ON = low / Jumper OFF = high
+//sbit Master = P1^4;
+
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// Project Definitions
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#define T_MONITORING_PERIOD		10
+#define R_INIT_PERIOD			10
+#define R_MONITORING_PERIOD		200
+
+#define TX_HW_RESET_PERIOD      200
+#define RX_HW_RESET_PERIOD		600
+
+#define INT_CONTROL 0x00 // Interrupt pin is push-pull and active high (this is normally 0x06)
+
+#define SiI_DEVICE_ID           0xB0
+#define SiI_DEVICE_STRING       "SiI 9022A/9024A 81BGA\n"
+#define T_HW_RESET              1
+//#define RX_ONBOARD
+#define SiI_9022AYBT_DEVICEID_CHECK
+//#define PLL_BACKDOOR          // TPI does not support programming of Output Clock PLL
+#define F_9022A_9334            // for now, use new TPI features...
+#define CLOCK_EDGE_RISING
+#define SOURCE_TERMINATION_ON
+
+#define DEV_INDEXED_READ
+#define DEV_INDEXED_WRITE
+#define DEV_INDEXED_RMW
+
+#define DEV_SUPPORT_EDID
+//#define DEV_SUPPORT_HDCP
+//#define DEV_SUPPORT_CEC
+//#define DEV_ACNU_BOARD
+
+/*\
+| | TPI API Version
+\*/
+
+#define TPI_API_MAJ_VERSION	1
+#define TPI_API_MIN_VERSION	4	// feature set
+#define TPI_API_SUB_VERSION	1	// command length change
+
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// Debug Definitions
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+#define DISABLE 0x00
+#define ENABLE  0xFF
+
+// Compile debug prints inline or not
+#define CONF__TPI_DEBUG_PRINT   (DISABLE)
+#define CONF__CPI_DEBUG_PRINT   (DISABLE)
+#define CONF__TPI_EDID_PRINT    (DISABLE)
+#define CONF__TPI_TRACE_PRINT	(DISABLE)
+
+/*\
+| | Trace Print Macro
+| |
+| | Note: TPI_DEBUG_PRINT Requires double parenthesis
+| | Example:  TPI_DEBUG_PRINT(("hello, world!\n"));
+\*/
+
+#if (CONF__TPI_TRACE_PRINT == ENABLE)
+    #define TPI_TRACE_PRINT(x)      //if (DEBUG == 0) printk x
+#else
+    #define TPI_TRACE_PRINT(x)
+#endif
+
+/*\
+| | Debug Print Macro
+| |
+| | Note: TPI_DEBUG_PRINT Requires double parenthesis
+| | Example:  TPI_DEBUG_PRINT(("hello, world!\n"));
+\*/
+
+#if (CONF__TPI_DEBUG_PRINT == ENABLE)
+    #define TPI_DEBUG_PRINT(x)      //if (DEBUG == 0) printk x
+#else
+    #define TPI_DEBUG_PRINT(x)
+#endif
+
+/*\
+| | CPI Debug Print Macro
+| |
+| | Note: To enable CPI description printing, both CONF__CPI_DEBUG_PRINT and CONF__TPI_DEBUG_PRINT must be enabled
+| |
+| | Note: CPI_DEBUG_PRINT Requires double parenthesis
+| | Example:  CPI_DEBUG_PRINT(("hello, world!\n"));
+\*/
+
+#if (CONF__CPI_DEBUG_PRINT == ENABLE)
+    #define CPI_DEBUG_PRINT(x)      //if (DEBUG == 0) TPI_DEBUG_PRINT(x)
+#else
+    #define CPI_DEBUG_PRINT(x)
+#endif
+
+/*\
+| | EDID Print Macro
+| |
+| | Note: To enable EDID description printing, both CONF__TPI_EDID_PRINT and CONF__TPI_DEBUG_PRINT must be enabled
+| |
+| | Note: TPI_EDID_PRINT Requires double parenthesis
+| | Example:  TPI_EDID_PRINT(("hello, world!\n"));
+\*/
+
+#if (CONF__TPI_EDID_PRINT == ENABLE)
+    #define TPI_EDID_PRINT(x)       //if (DEBUG == 0) TPI_DEBUG_PRINT(x)
+#else
+    #define TPI_EDID_PRINT(x)
+#endif
+
+//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+//#define TEST_CEC                    // Define when testing CEC by sending SiIMon commands
+
diff --git a/drivers/video/hdmi/si9022/SIIedid.h b/drivers/video/hdmi/si9022/SIIedid.h
new file mode 100755
index 0000000..d163887
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SIIedid.h
@@ -0,0 +1,66 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+#ifdef DEV_SUPPORT_EDID
+
+#define MAX_V_DESCRIPTORS			20
+#define MAX_A_DESCRIPTORS			10
+#define MAX_SPEAKER_CONFIGURATIONS	 4
+#define AUDIO_DESCR_SIZE			 3
+
+typedef struct {								// for storing EDID parsed data
+	unsigned char VideoDescriptor[MAX_V_DESCRIPTORS];	// maximum number of video descriptors
+	unsigned char AudioDescriptor[MAX_A_DESCRIPTORS][3];	// maximum number of audio descriptors
+	unsigned char SpkrAlloc[MAX_SPEAKER_CONFIGURATIONS];	// maximum number of speaker configurations
+	bool UnderScan;								// "1" if DTV monitor underscans IT video formats by default
+	bool BasicAudio;							// Sink supports Basic Audio
+	bool YCbCr_4_4_4;							// Sink supports YCbCr 4:4:4
+	bool YCbCr_4_2_2;							// Sink supports YCbCr 4:2:2
+	bool HDMI_Sink;								// "1" if HDMI signature found
+	unsigned char CEC_A_B;								// CEC Physical address. See HDMI 1.3 Table 8-6
+	unsigned char CEC_C_D;
+	unsigned char ColorimetrySupportFlags;				// IEC 61966-2-4 colorimetry support: 1 - xvYCC601; 2 - xvYCC709 
+	unsigned char MetadataProfile;
+	bool _3D_Supported;	 
+	} Type_EDID_Descriptors;
+
+enum EDID_ErrorCodes {
+	EDID_OK,
+	EDID_INCORRECT_HEADER,
+	EDID_CHECKSUM_ERROR,
+	EDID_NO_861_EXTENSIONS,
+	EDID_SHORT_DESCRIPTORS_OK,
+	EDID_LONG_DESCRIPTORS_OK,
+	EDID_EXT_TAG_ERROR,
+	EDID_REV_ADDR_ERROR,
+	EDID_V_DESCR_OVERFLOW,
+	EDID_UNKNOWN_TAG_CODE,
+	EDID_NO_DETAILED_DESCRIPTORS,
+	EDID_DDC_BUS_REQ_FAILURE,
+	EDID_DDC_BUS_RELEASE_FAILURE,
+	EDID_DDC_NO_RESPONSE
+	};
+
+unsigned char DoEdidRead (void);
+
+#define ReadBlockEDID(a,b,c)	I2C_ReadBlock(EDID_ROM_ADDR, a, c, b)
+
+#define IsHDMI_Sink()			(EDID_Data.HDMI_Sink)
+#define IsCEC_DEVICE()			(((EDID_Data.CEC_A_B != 0xFF) && (EDID_Data.CEC_C_D != 0xFF)) ? TRUE : FALSE)
+
+extern Type_EDID_Descriptors EDID_Data;		// holds parsed EDID data needed by the FW
+extern unsigned char EDID_TempData[];
+
+extern bool edidDataValid;
+
+#else
+
+#define IsHDMI_Sink()			(TRUE)
+#define IsCEC_DEVICE()			(FALSE)
+
+#endif
diff --git a/drivers/video/hdmi/si9022/SerialPort.h b/drivers/video/hdmi/si9022/SerialPort.h
new file mode 100755
index 0000000..4556070
--- /dev/null
+++ b/drivers/video/hdmi/si9022/SerialPort.h
@@ -0,0 +1,23 @@
+/***********************************************************************************/
+/*  Copyright (c) 2002-2009, Silicon Image, Inc.  All rights reserved.             */
+/*  No part of this work may be reproduced, modified, distributed, transmitted,    */
+/*  transcribed, or translated into any language or computer format, in any form   */
+/*  or by any means without written permission of: Silicon Image, Inc.,            */
+/*  1060 East Arques Avenue, Sunnyvale, California 94085                           */
+/***********************************************************************************/
+
+// API Command Lengths
+//=======================
+
+// These are here because thet are referenced in av_config.c
+
+#define VIDEO_SETUP_CMD_LEN     0x15
+#define AUDIO_SETUP_CMD_LEN 	0x07
+#define I2S_MAPPING_CMD_LEN     0x04
+#define CFG_I2S_INPUT_CMD_LEN   0x01
+#define I2S_STREAM_HDR_CMD_LEN  0x05
+#define API_VERSION_CMD_LEN		0x03
+#define TPI_FW_VERSION_CMD_LEN	(int)sizeof(TPI_FW_VERSION)
+#define EHDMI_MODE_CMD_LEN		0x01 
+
+void SerComm(void);
diff --git a/drivers/video/hdmi/si9022/imap_HDMI.c b/drivers/video/hdmi/si9022/imap_HDMI.c
new file mode 100644
index 0000000..8963375
--- /dev/null
+++ b/drivers/video/hdmi/si9022/imap_HDMI.c
@@ -0,0 +1,1365 @@
+/***************************************************************************** 
+ * ** drivers/video/infotm_HDMI/imap_HDMI.c
+ * ** 
+ * ** Copyright (c) 2009~2014 ShangHai Infotm Ltd all rights reserved. 
+ * ** 
+ * ** Use of Infotm's code is governed by terms and conditions 
+ * ** stated in the accompanying licensing statement. 
+ * ** 
+ * ** Description: Implementation file of Infotm HDMI.
+ * **
+ * ** Author:
+ * **     Alex Zhang <alex.zhang@infotmic.com.cn>
+ * **      
+ * ** Revision History: 
+ * ** ----------------- 
+ * ** 1.0  06/11/2010 Alex Zhang 
+ * ** 1.1  06/18/2010 Alex Zhang 
+ * ** 2.0  06/21/2010 Alex Zhang 
+ * ** 2.1  06/23/2010 Alex Zhang 
+ * ** 2.2  06/24/2010 Alex Zhang 
+ * *****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/mutex.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/ioctl.h>
+#include <linux/poll.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <plat/imapx.h>
+#include <asm/mach/irq.h>
+/* import imapfb configuration for compatibility */
+#include "../../infotm/imapfb.h"
+#include "imap_HDMI.h"
+#include "SIITPI.h"
+#include "SIITPI_Access.h"
+#include "Externals.h"
+#include "SIITPI_Regs.h"
+#include "SIIConstants.h"
+#include "SIIMacros.h"
+#include "SIIedid.h"
+#include "SIIdefs.h"
+#include "SIIAV_Config.h"
+
+#ifdef CONFIG_FAKE_PM
+#include <plat/fake_pm.h>
+#endif
+
+#define HDMI_MAJOR               84
+#define HDMI_POLL_MAJOR               85
+#define HDMI_MINOR               0
+#define i2c_device_address  0x70
+#define HDMI_TVIF_TEST	
+
+
+#define turn_on_backlight() imapx_gpio_setcfg(__imapx_name_to_gpio(CONFIG_IG_LCD_BACKLIGHT), IG_CTRL0, IG_NORMAL)
+
+#define turn_off_backlight()	\
+({				\
+	imapx_gpio_setcfg(__imapx_name_to_gpio(CONFIG_IG_LCD_BACKLIGHT), IG_OUTPUT, IG_NORMAL);	\
+	imapx_gpio_setpin(__imapx_name_to_gpio(CONFIG_IG_LCD_BACKLIGHT), 0, IG_NORMAL);	\
+})
+
+extern unsigned char DoEdidRead (void);
+
+static unsigned short normal_i2c[] = {0, I2C_CLIENT_END};
+
+static struct class *HDMI_class;
+
+I2C_CLIENT_INSMOD;
+
+wait_queue_head_t       HDMI_wait;
+spinlock_t              lock;
+struct completion	Monitor_Wait;
+unsigned int	HDMI_MENU_SWITCH = -1; 
+unsigned int	HDMI_HOTPLUG_IN = -1;
+unsigned int    HDMI_HOTPLUG_RESULT = 0;
+unsigned int VIDEO_MODE = 0;
+EXTERL_SYMBOL(VIDEO_MODE);
+unsigned int DOUBLE_DISPLAY_MODE = 0;
+EXTERL_SYMBOL(DOUBLE_DISPLAY_MODE);
+unsigned int PANAUISION_MODE = 0;
+EXTERL_SYMBOL(PANAUISION_MODE);
+unsigned int HDMI_QUERY_MONITOR_FLAG = -1;
+static unsigned int previous_mode = 1;
+
+#define HDMI_HP_POLL_DELAY	1000
+extern void imapbl_lowlevel_blctrl(int);
+extern void imap_iokey_spken(int);
+
+static const struct i2c_device_id HDMI_i2c_id[] = {
+	{ "imap_HDMI", 0 },
+	{ }
+};
+
+static unsigned char HDMI_V_MODE[7] = {16,4,3,2,18,17,1};
+
+static int HDMI_power(int en);
+/*
+ *This variable save the HDMI mode supported by the connected TV
+ *
+ *BIT0:1080P
+ *BIT1:720P
+ *BIT2:480P_16_9
+ *BIT3:480P_4_3
+ *BIT4:576P_16_9
+ *BIT5:576P_4_3
+ *BIT6:640_480
+ */
+static unsigned char TV_V_MODE;
+
+static struct i2c_client gHDMIClient;
+static struct mutex HDMI_lock;
+
+struct imap_HDMI_info {
+	struct device *dev;
+	struct i2c_client *client;
+	struct delayed_work    delayed_work;
+};
+
+struct_lcd_timing_param ids_timing[10] = 
+{
+	{0}, /* this row is removed, lcd timing will be provied by lcd driver, apr.20.2011 */
+
+	{1,0,3,12,0,36,1080,4,5,1,127,1920,109,44,0x06,0,0,0,0,0,0,0,0,0,0,0,0,1},
+	{1,0,3,12,0,20,720,5,5,0,127,1280,203,40,0x06,0,0,0,0,0,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,30,480,9,6,0,60,720,16,62,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,30,480,9,6,0,60,720,16,62,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,39,576,5,5,0,68,720,12,64,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,39,576,5,5,0,68,720,12,64,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1}, 
+	{2,0,3,12,0,33,480,10,2,0,48,640,16,96,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},    
+	{1,0,3,12,0,23,600,1,4,0,88,800,40,128,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+	{2,0,3,12,0,29,768,3,6,0,160,1024,24,136,0x06,0,0,0,1,1,0,0,0,0,0,0,0,1},
+};
+
+struct_tvif_timing_param tvif_timing[10] = 
+{
+	{1,0,0,1,0,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/18,/**/600,/**/10,/**/18,/**/600,/**/10,/**/408,/**/1024,/**/0,134,32,/**/134,4667,/**/134,4667,/**/1023,/**/599},
+	{1,0,0,1,1,/**/0,1,0,1,0,0,1,1,0,0,0,/**/0,1,0,0,0,0,
+	 /**/41,/**/1080,/**/4,/**/41,/**/1080,/**/4,/**/272,/**/1920,/**/0,84,44,/**/84,8191,/**/84,8191,/**/1919,/**/1079},
+	{1,0,0,1,1,/**/0,1,0,1,0,0,1,1,0,0,0,/**/0,1,0,0,0,0,
+	 /**/25,/**/720,/**/5,/**/25,/**/720,/**/5,/**/362,/**/1280,/**/0,106,40,/**/106,8191,/**/106,8191,/**/1279,/**/719},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/36,/**/480,/**/9,/**/36,/**/480,/**/9,/**/130,/**/720,/**/0,12,62,/**/12,5147,/**/12,5147,/**/719,/**/479},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/36,/**/480,/**/9,/**/36,/**/480,/**/9,/**/130,/**/720,/**/0,12,62,/**/12,5147,/**/12,5147,/**/719,/**/479},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/44,/**/576,/**/5,/**/44,/**/576,/**/5,/**/136,/**/720,/**/0,8,64,/**/8,4319,/**/8,4319,/**/719,/**/575},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/44,/**/576,/**/5,/**/44,/**/576,/**/5,/**/136,/**/720,/**/0,8,64,/**/8,4319,/**/8,4319,/**/719,/**/575},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/35,/**/480,/**/10,/**/35,/**/480,/**/10,/**/152,/**/640,/**/0,12,96,/**/12,1599,/**/12,1599,/**/639,/**/479},
+	{1,0,0,1,1,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/27,/**/600,/**/1,/**/27,/**/600,/**/1,/**/248,/**/800,/**/0,40,128,/**/40,3168,/**/40,3168,/**/799,/**/599},
+	{1,0,0,1,2,/**/0,1,0,1,0,0,0,0,0,0,0,/**/0,1,0,0,0,0,
+	 /**/35,/**/768,/**/3,/**/35,/**/768,/**/3,/**/312,/**/1024,/**/0,24,136,/**/24,6720,/**/24,6720,/**/1023,/**/767},
+};
+
+struct_lds_clk_param ids_clk[10] = 
+{
+	{0x13,0 /* this value is removed, invoke lcd driver interface instead, apr.20.2011 */},
+	{0x24,0x0909},
+	{0x24,0x1515},
+	{0x1A,0x1D1D},
+	{0x1A,0x1D1D},
+	{0x1A,0x1D1D},
+	{0x1A,0x1D1D},
+	{0x18,0x1D1D},
+	{0x13,0x1515},
+	{0x40,0x1d1d},
+};
+
+static unsigned int LCDCON_DataBuf[6];
+static unsigned int LCDINT_DataBuf[3];
+static unsigned int OVLCON0_DataBuf[12];
+static unsigned int OVLCON1_DataBuf[12];
+static unsigned int OVLCON2_DataBuf[12];
+static unsigned int OVLCON3_DataBuf[10];
+static unsigned int OVLCOLCON_DataBuf[14];
+static unsigned int OVLPAL0_DataBuf[256];
+static unsigned int OVLPAL1_DataBuf[256];
+static unsigned int OVLPAL2_DataBuf[128];
+static unsigned int OVLPAL3_DataBuf[128];
+
+/*only for system UI*/
+void osd_excursion(LCD_TIMING timing)
+{
+	unsigned int lefttopx;
+	unsigned int lefttopy;
+	unsigned int rightbottomx;
+	unsigned int rightbottomy;
+	unsigned int excursionx = 0;
+	unsigned int excursiony = 0;
+
+	switch(timing)
+	{
+		case HDMI_1080P:                                 
+			excursionx = (1920 - imapfb_fimd.xres)/2;
+			excursiony = (1080 - imapfb_fimd.yres)/2;
+			break;                                   
+
+		case HDMI_720P:                                  
+			excursionx = (1280- imapfb_fimd.xres)/2; 
+			excursiony = (720- imapfb_fimd.yres)/2;  
+			break;                                   
+
+		case HDMI_480P_16_9:                             
+		case HDMI_480P_4_3:                              
+			excursionx = (720 - imapfb_fimd.xres)/2; 
+			excursiony = (480 - imapfb_fimd.yres)/2; 
+			break;                                   
+
+		case HDMI_576P_16_9:                             
+		case HDMI_576P_4_3:                              
+			excursionx = (720 - imapfb_fimd.xres)/2; 
+			excursiony = (576 - imapfb_fimd.yres)/2; 
+			break;                                   
+
+		case HDMI_640_480:                               
+			excursionx = (640- imapfb_fimd.xres)/2;  
+			excursiony = (480- imapfb_fimd.yres)/2;  
+			break;                                   
+
+		case HDMI_800_600:
+			excursionx = (800 - imapfb_fimd.xres)/2;
+			excursiony = (600 - imapfb_fimd.yres)/2;
+			break;
+
+		case HDMI_1024_768:
+			excursionx = (1024 - imapfb_fimd.xres)/2;
+			excursiony = (768 - imapfb_fimd.yres)/2;
+			break;
+		default:
+			printk("Not supported by now Maybe later\n");
+			break;
+	}
+
+	lefttopx = 0;//((__raw_readl(IMAP_OVCW0PCAR) >> 16) & (0x7ff));
+	lefttopy = 0;//((__raw_readl(IMAP_OVCW0PCAR) >> 0) & (0x7ff));
+	rightbottomx = imapfb_fimd.xres;//((__raw_readl(IMAP_OVCW0PCBR) >> 16) & (0x7ff));
+	rightbottomy = imapfb_fimd.yres;//((__raw_readl(IMAP_OVCW0PCBR) >> 0) & (0x7ff));
+	__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(lefttopx + excursionx) | IMAP_OVCWxPCAR_LEFTTOPY(lefttopy + excursiony), IMAP_OVCW0PCAR);
+	__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(rightbottomx + excursionx - 1) | IMAP_OVCWxPCBR_RIGHTBOTY(rightbottomy + excursiony - 1), IMAP_OVCW0PCBR);
+}
+
+BOOL lcd_change_timing(LCD_TIMING timing, BOOL tv_IF)
+{
+	unsigned int temp;
+	unsigned char temp_reg[4];
+	int i;
+
+/*close lcd screen*/
+//	if(timing != LCD)
+//	  imapbl_lowlevel_blctrl(0);
+
+	/*Save IDS register value before software reset*/
+	/*LCD controller*/
+	LCDCON_DataBuf[0] = __raw_readl(IMAP_LCDCON1);
+	LCDCON_DataBuf[1] = __raw_readl(IMAP_LCDCON2);
+	LCDCON_DataBuf[2] = __raw_readl(IMAP_LCDCON3);
+	LCDCON_DataBuf[3] = __raw_readl(IMAP_LCDCON4);
+	LCDCON_DataBuf[4] = __raw_readl(IMAP_LCDCON5);
+	LCDCON_DataBuf[5] = __raw_readl(IMAP_LCDVCLKFSR);
+
+/*Interrupt */	
+	LCDINT_DataBuf[0] = __raw_readl(IMAP_IDSINTPND);
+	LCDINT_DataBuf[1] = __raw_readl(IMAP_IDSSRCPND);
+	LCDINT_DataBuf[2] = __raw_readl(IMAP_IDSINTMSK);
+
+/*Overlay controller 0*/	
+	OVLCON0_DataBuf[0] = __raw_readl(IMAP_OVCDCR);
+	OVLCON0_DataBuf[1] = __raw_readl(IMAP_OVCPCR);	
+	OVLCON0_DataBuf[2] = __raw_readl(IMAP_OVCBKCOLOR);
+	OVLCON0_DataBuf[3] = __raw_readl(IMAP_OVCW0CR);
+	OVLCON0_DataBuf[4] = __raw_readl(IMAP_OVCW0PCAR);
+	OVLCON0_DataBuf[5] = __raw_readl(IMAP_OVCW0PCBR);
+	OVLCON0_DataBuf[6] = __raw_readl(IMAP_OVCW0B0SAR);
+	OVLCON0_DataBuf[7] = __raw_readl(IMAP_OVCW0B1SAR);
+	OVLCON0_DataBuf[8] = __raw_readl(IMAP_OVCW0VSSR);
+	OVLCON0_DataBuf[9] = __raw_readl(IMAP_OVCW0CMR);
+	OVLCON0_DataBuf[10] = __raw_readl(IMAP_OVCW0B2SAR);
+	OVLCON0_DataBuf[11] = __raw_readl(IMAP_OVCW0B3SAR);
+
+/*Overlay controller 1*/	
+	OVLCON1_DataBuf[0] = __raw_readl(IMAP_OVCW1CR);
+	OVLCON1_DataBuf[1] = __raw_readl(IMAP_OVCW1PCAR);
+	OVLCON1_DataBuf[2] = __raw_readl(IMAP_OVCW1PCBR);
+	OVLCON1_DataBuf[3] = __raw_readl(IMAP_OVCW1PCCR);
+	OVLCON1_DataBuf[4] = __raw_readl(IMAP_OVCW1B0SAR);
+	OVLCON1_DataBuf[5] = __raw_readl(IMAP_OVCW1B1SAR);
+	OVLCON1_DataBuf[6] = __raw_readl(IMAP_OVCW1VSSR);
+	OVLCON1_DataBuf[7] = __raw_readl(IMAP_OVCW1CKCR);
+	OVLCON1_DataBuf[8] = __raw_readl(IMAP_OVCW1CKR);
+	OVLCON1_DataBuf[9] = __raw_readl(IMAP_OVCW1CMR);
+	OVLCON1_DataBuf[10] = __raw_readl(IMAP_OVCW1B2SAR);
+	OVLCON1_DataBuf[11] = __raw_readl(IMAP_OVCW1B3SAR);
+
+/*Overlay controller 2*/	
+	OVLCON2_DataBuf[0] = __raw_readl(IMAP_OVCW2CR);
+	OVLCON2_DataBuf[1] = __raw_readl(IMAP_OVCW2PCAR);
+	OVLCON2_DataBuf[2] = __raw_readl(IMAP_OVCW2PCBR);
+	OVLCON2_DataBuf[3] = __raw_readl(IMAP_OVCW2PCCR);
+	OVLCON2_DataBuf[4] = __raw_readl(IMAP_OVCW2B0SAR);
+	OVLCON2_DataBuf[5] = __raw_readl(IMAP_OVCW2B1SAR);
+	OVLCON2_DataBuf[6] = __raw_readl(IMAP_OVCW2VSSR);
+	OVLCON2_DataBuf[7] = __raw_readl(IMAP_OVCW2CKCR);
+	OVLCON2_DataBuf[8] = __raw_readl(IMAP_OVCW2CKR);
+	OVLCON2_DataBuf[9] = __raw_readl(IMAP_OVCW2CMR);
+	OVLCON2_DataBuf[10] = __raw_readl(IMAP_OVCW2B2SAR);
+	OVLCON2_DataBuf[11] = __raw_readl(IMAP_OVCW2B3SAR);
+
+/*Overlay controller 3*/	
+	OVLCON3_DataBuf[0] = __raw_readl(IMAP_OVCW3CR);
+	OVLCON3_DataBuf[1] = __raw_readl(IMAP_OVCW3PCAR);
+	OVLCON3_DataBuf[2] = __raw_readl(IMAP_OVCW3PCBR);
+	OVLCON3_DataBuf[3] = __raw_readl(IMAP_OVCW3PCCR);
+	OVLCON3_DataBuf[4] = __raw_readl(IMAP_OVCW3BSAR);
+	OVLCON3_DataBuf[5] = __raw_readl(IMAP_OVCW3VSSR);
+	OVLCON3_DataBuf[6] = __raw_readl(IMAP_OVCW3CKCR);
+	OVLCON3_DataBuf[7] = __raw_readl(IMAP_OVCW3CKR);
+	OVLCON3_DataBuf[8] = __raw_readl(IMAP_OVCW3CMR);
+	OVLCON3_DataBuf[9] = __raw_readl(IMAP_OVCW3SABSAR);
+
+/*Overlay color controller*/	
+	OVLCOLCON_DataBuf[0] = __raw_readl(IMAP_OVCBRB0SAR);
+	OVLCOLCON_DataBuf[1] = __raw_readl(IMAP_OVCBRB1SAR);
+	OVLCOLCON_DataBuf[2] = __raw_readl(IMAP_OVCOEF11);
+	OVLCOLCON_DataBuf[3] = __raw_readl(IMAP_OVCOEF12);
+	OVLCOLCON_DataBuf[4] = __raw_readl(IMAP_OVCOEF13);
+	OVLCOLCON_DataBuf[5] = __raw_readl(IMAP_OVCOEF21);
+	OVLCOLCON_DataBuf[6] = __raw_readl(IMAP_OVCOEF22);
+	OVLCOLCON_DataBuf[7] = __raw_readl(IMAP_OVCOEF23);
+	OVLCOLCON_DataBuf[8] = __raw_readl(IMAP_OVCOEF31);
+	OVLCOLCON_DataBuf[9] = __raw_readl(IMAP_OVCOEF32);
+	OVLCOLCON_DataBuf[10] = __raw_readl(IMAP_OVCOEF33);
+	OVLCOLCON_DataBuf[11] = __raw_readl(IMAP_OVCOMC);
+	OVLCOLCON_DataBuf[12] = __raw_readl(IMAP_OVCBRB2SAR);
+	OVLCOLCON_DataBuf[13] = __raw_readl(IMAP_OVCBRB3SAR);
+
+/*Overlay PAL0 */
+	for(i=0;i<256;i++)	
+		OVLPAL0_DataBuf[i] = __raw_readl(IMAP_OVCW0PAL+i*0x4);
+
+/*Overlay PAL1 */
+	for(i=0;i<256;i++)	
+		OVLPAL1_DataBuf[i] = __raw_readl(IMAP_OVCW1PAL+i*0x4);
+
+/*Overlay PAL2 */
+	for(i=0;i<128;i++)	
+		OVLPAL2_DataBuf[i] = __raw_readl(IMAP_OVCW2PAL+i*0x4);
+
+/*Overlay PAL3 */
+	for(i=0;i<256;i++)	
+		OVLPAL3_DataBuf[i] = __raw_readl(IMAP_OVCW3PAL+i*0x4);
+
+/*Save lcd and osd open status*/
+	temp_reg[0] = (OVLCON0_DataBuf[3] & 0x1);
+	temp_reg[1]= (OVLCON1_DataBuf[0] & 0x1);
+	temp_reg[2]= (OVLCON2_DataBuf[0] & 0x1);
+	temp_reg[3]= (OVLCON3_DataBuf[0] & 0x1);
+
+/*LDS module software reset*/
+	temp = __raw_readl(rAHBP_RST);
+	temp |= 0x1<<6;
+	__raw_writel(temp, rAHBP_RST);
+
+	for(i=0;i<10;i++)
+		udelay(1000);
+
+	temp = __raw_readl(rAHBP_RST);
+	temp &= ~(0x1<<6);
+	__raw_writel(temp, rAHBP_RST);
+	
+/*Config LCD clock*/
+	lcd_config_clk(timing);
+
+/*write value back to register*/
+	__raw_writel(LCDINT_DataBuf[2], IMAP_IDSINTMSK);
+
+	__raw_writel(OVLCON0_DataBuf[0], IMAP_OVCDCR);
+	__raw_writel(OVLCON0_DataBuf[1], IMAP_OVCPCR);
+	__raw_writel(OVLCON0_DataBuf[2], IMAP_OVCBKCOLOR);
+	__raw_writel((OVLCON0_DataBuf[3] & ~0x1), IMAP_OVCW0CR);
+	__raw_writel(OVLCON0_DataBuf[4], IMAP_OVCW0PCAR);
+	__raw_writel(OVLCON0_DataBuf[5], IMAP_OVCW0PCBR);
+	__raw_writel(OVLCON0_DataBuf[6], IMAP_OVCW0B0SAR);
+	__raw_writel(OVLCON0_DataBuf[7], IMAP_OVCW0B1SAR);
+	__raw_writel(OVLCON0_DataBuf[8], IMAP_OVCW0VSSR);
+	__raw_writel(OVLCON0_DataBuf[9], IMAP_OVCW0CMR);
+	__raw_writel(OVLCON0_DataBuf[10], IMAP_OVCW0B2SAR);
+	__raw_writel(OVLCON0_DataBuf[11], IMAP_OVCW0B3SAR);
+	
+	__raw_writel((OVLCON1_DataBuf[0] & ~0x1), IMAP_OVCW1CR);
+	__raw_writel(OVLCON1_DataBuf[1], IMAP_OVCW1PCAR);
+	__raw_writel(OVLCON1_DataBuf[2], IMAP_OVCW1PCBR);
+	__raw_writel(OVLCON1_DataBuf[3], IMAP_OVCW1PCCR);
+	__raw_writel(OVLCON1_DataBuf[4], IMAP_OVCW1B0SAR);
+	__raw_writel(OVLCON1_DataBuf[5], IMAP_OVCW1B1SAR);
+	__raw_writel(OVLCON1_DataBuf[6], IMAP_OVCW1VSSR);
+	__raw_writel(OVLCON1_DataBuf[7], IMAP_OVCW1CKCR);
+	__raw_writel(OVLCON1_DataBuf[8], IMAP_OVCW1CKR);
+	__raw_writel(OVLCON1_DataBuf[9], IMAP_OVCW1CMR);
+	__raw_writel(OVLCON1_DataBuf[10], IMAP_OVCW1B2SAR);
+	__raw_writel(OVLCON1_DataBuf[11], IMAP_OVCW1B3SAR);
+	
+	__raw_writel((OVLCON2_DataBuf[0] & ~0x1), IMAP_OVCW2CR);
+	__raw_writel(OVLCON2_DataBuf[1], IMAP_OVCW2PCAR);
+	__raw_writel(OVLCON2_DataBuf[2], IMAP_OVCW2PCBR);
+	__raw_writel(OVLCON2_DataBuf[3], IMAP_OVCW2PCCR);
+	__raw_writel(OVLCON2_DataBuf[4], IMAP_OVCW2B0SAR);
+	__raw_writel(OVLCON2_DataBuf[5], IMAP_OVCW2B1SAR);
+	__raw_writel(OVLCON2_DataBuf[6], IMAP_OVCW2VSSR);
+	__raw_writel(OVLCON2_DataBuf[7], IMAP_OVCW2CKCR);
+	__raw_writel(OVLCON2_DataBuf[8], IMAP_OVCW2CKR);
+	__raw_writel(OVLCON2_DataBuf[9], IMAP_OVCW2CMR);
+	__raw_writel(OVLCON2_DataBuf[10], IMAP_OVCW2B2SAR);
+	__raw_writel(OVLCON2_DataBuf[11], IMAP_OVCW2B3SAR);
+
+	__raw_writel((OVLCON3_DataBuf[0] & ~0x1), IMAP_OVCW3CR);
+	__raw_writel(OVLCON3_DataBuf[1], IMAP_OVCW3PCAR);
+	__raw_writel(OVLCON3_DataBuf[2], IMAP_OVCW3PCBR);
+	__raw_writel(OVLCON3_DataBuf[3], IMAP_OVCW3PCCR);
+	__raw_writel(OVLCON3_DataBuf[4], IMAP_OVCW3BSAR);
+	__raw_writel(OVLCON3_DataBuf[5], IMAP_OVCW3VSSR);
+	__raw_writel(OVLCON3_DataBuf[6], IMAP_OVCW3CKCR);
+	__raw_writel(OVLCON3_DataBuf[7], IMAP_OVCW3CKR);
+	__raw_writel(OVLCON3_DataBuf[8], IMAP_OVCW3CMR);
+	__raw_writel(OVLCON3_DataBuf[9], IMAP_OVCW3SABSAR);
+
+	__raw_writel(OVLCOLCON_DataBuf[0], IMAP_OVCBRB0SAR);
+	__raw_writel(OVLCOLCON_DataBuf[1], IMAP_OVCBRB1SAR);
+	__raw_writel(OVLCOLCON_DataBuf[2], IMAP_OVCOEF11);
+	__raw_writel(OVLCOLCON_DataBuf[3], IMAP_OVCOEF12);
+	__raw_writel(OVLCOLCON_DataBuf[4], IMAP_OVCOEF13);
+	__raw_writel(OVLCOLCON_DataBuf[5], IMAP_OVCOEF21);
+	__raw_writel(OVLCOLCON_DataBuf[6], IMAP_OVCOEF22);
+	__raw_writel(OVLCOLCON_DataBuf[7], IMAP_OVCOEF23);
+	__raw_writel(OVLCOLCON_DataBuf[8], IMAP_OVCOEF31);
+	__raw_writel(OVLCOLCON_DataBuf[9], IMAP_OVCOEF32);
+	__raw_writel(OVLCOLCON_DataBuf[10], IMAP_OVCOEF33);
+	__raw_writel(OVLCOLCON_DataBuf[11], IMAP_OVCOMC);
+	__raw_writel(OVLCOLCON_DataBuf[12], IMAP_OVCBRB2SAR);
+	__raw_writel(OVLCOLCON_DataBuf[13], IMAP_OVCBRB3SAR);
+
+	for(i=0;i<256;i++)
+		__raw_writel(OVLPAL0_DataBuf[i], IMAP_OVCW0PAL + 0x4*i);
+	
+	for(i=0;i<256;i++)
+		__raw_writel(OVLPAL1_DataBuf[i], IMAP_OVCW1PAL + 0x4*i);
+	
+	for(i=0;i<128;i++)
+		__raw_writel(OVLPAL2_DataBuf[i], IMAP_OVCW2PAL + 0x4*i);
+	
+	for(i=0;i<128;i++)
+		__raw_writel(OVLPAL3_DataBuf[i], IMAP_OVCW3PAL + 0x4*i);
+
+/*change osd window smaller than Hactive and Vactive back to system resolution if timing 12*/
+
+	if(timing == LCD || (imapfb_fimd.xres == 800 && timing == HDMI_800_600) || (imapfb_fimd.xres == 1024 && timing == HDMI_1024_768))
+	{
+		/* if LCD use imapfb_fimd configurations, apr.20.2011 */
+		__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0), IMAP_OVCW0PCAR);
+		__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(imapfb_fimd.xres - 1) |
+		   IMAP_OVCWxPCBR_RIGHTBOTY(imapfb_fimd.yres - 1), IMAP_OVCW0PCBR);
+
+	}
+	else
+	{
+		if(ids_timing[timing].HACTIVE < imapfb_fimd.xres)
+		{	
+			__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0), IMAP_OVCW0PCAR);
+			__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(ids_timing[timing].HACTIVE -1) | IMAP_OVCWxPCBR_RIGHTBOTY((__raw_readl(IMAP_OVCW0PCBR) & 0x7ff ) -1), IMAP_OVCW0PCBR);
+		}
+
+		if(ids_timing[timing].VACTIVE < imapfb_fimd.yres)
+		{	
+			__raw_writel(IMAP_OVCWxPCAR_LEFTTOPX(0) | IMAP_OVCWxPCAR_LEFTTOPY(0), IMAP_OVCW0PCAR);
+			__raw_writel(IMAP_OVCWxPCBR_RIGHTBOTX(((__raw_readl(IMAP_OVCW0PCBR) & (0x7ff<<16)) >> 16) -1) | IMAP_OVCWxPCBR_RIGHTBOTY(ids_timing[timing].VACTIVE -1), IMAP_OVCW0PCBR);
+		}
+	}
+
+/*change timing*/
+
+	lcd_config_controller(timing);
+	if(tv_IF == 1)
+	{
+		if(timing == LCD)
+		{
+			__raw_writel((__raw_readl(IMAP_LCDCON5) & ~(0x3<<11)), IMAP_LCDCON5);
+		}
+		else
+		{
+			__raw_writel((__raw_readl(IMAP_LCDCON5) | (0x2<<11)), IMAP_LCDCON5);
+			tvif_config_controller(timing);
+		}
+	}
+
+/*enable lcd data output*/	
+	if(temp_reg[0])
+		__raw_writel((__raw_readl(IMAP_OVCW0CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW0CR);
+
+	if(temp_reg[1])
+		__raw_writel((__raw_readl(IMAP_OVCW1CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW1CR);
+
+	if(temp_reg[2])
+		__raw_writel((__raw_readl(IMAP_OVCW2CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW2CR);
+
+	if(temp_reg[3])
+		__raw_writel((__raw_readl(IMAP_OVCW3CR ) |IMAP_OVCWxCR_ENWIN_ENABLE), IMAP_OVCW3CR);
+
+	if(tv_IF == 1)
+	{
+		if(timing == LCD)
+		{
+			__raw_writel((__raw_readl(IMAP_TVICR) & ~(0x1<<31)), IMAP_TVICR);
+			__raw_writel((__raw_readl(IMAP_OVCDCR) & ~(0x3)), IMAP_OVCDCR);
+			__raw_writel((__raw_readl(IMAP_LCDCON1) | IMAP_LCDCON1_ENVID_ENABLE), IMAP_LCDCON1);
+		}
+//		else if (timing == HDMI_800_600 || timing == HDMI_1024_768 || timing == HDMI_720P){
+//			__raw_writel((__raw_readl(IMAP_OVCDCR) | (0x1<<1)), IMAP_OVCDCR);
+//			msleep(10);
+//			__raw_writel((__raw_readl(IMAP_TVICR) | (0x1<<31)), IMAP_TVICR);
+//		}
+		else{
+			__raw_writel((__raw_readl(IMAP_OVCDCR) | (0x1<<1)), IMAP_OVCDCR);
+			msleep(10);
+			__raw_writel((__raw_readl(IMAP_TVICR) | (0x1<<31)), IMAP_TVICR);
+		}
+	}
+	else
+	{
+		__raw_writel((__raw_readl(IMAP_LCDCON1) | IMAP_LCDCON1_ENVID_ENABLE), IMAP_LCDCON1);
+	}
+
+//	if(timing == LCD || timing == HDMI_800_600 || timing == HDMI_1024_768)
+//	{
+//		imapbl_lowlevel_blctrl(1);	
+//	}
+}
+
+
+void lcd_config_clk(LCD_TIMING timing)
+{
+	unsigned int temp;
+
+	/* if lcd, use imapfb_set_clk interface, apr.20.2011 */
+	if(timing == LCD)
+	{
+		imapfb_set_clk();
+		return ;
+	}
+
+	temp = readl(rDPLL_CFG); 
+	temp &=~(1<<31);
+	writel(temp,rDPLL_CFG);
+
+	temp = readl(rDPLL_CFG); 
+	temp = ids_clk[timing].DPLLCFG;
+	writel(temp,rDPLL_CFG);
+
+	//enable dpll	
+	temp = readl(rDPLL_CFG); 
+	temp |=(1<<31);
+	writel(temp,rDPLL_CFG);
+
+	/*wait untill dpll is locked*/
+	while(!(readl(rPLL_LOCKED) & 0x2));
+
+	temp = readl(rDIV_CFG4);
+	temp = ids_clk[timing].DIVCFG4;
+	writel(temp,rDIV_CFG4);
+}
+
+void tvif_config_controller(LCD_TIMING timing)
+{
+	unsigned int reg_temp[16];
+
+	reg_temp[0] = (tvif_timing[timing].Clock_enable << 31) |
+			(tvif_timing[timing].TV_PCLK_mode << 11) |
+			(tvif_timing[timing].Inv_clock << 9) |
+			(tvif_timing[timing].clock_sel << 8) |
+			(tvif_timing[timing].Clock_div << 0 );
+
+	reg_temp[1] = (tvif_timing[timing].tvif_enable << 31) |
+			(tvif_timing[timing].ITU601_656n << 30) |
+			(tvif_timing[timing].Bit16ofITU60 << 29) |
+			(tvif_timing[timing].Direct_data << 28 ) |
+			(tvif_timing[timing].Bitswap << 18 ) |
+			(tvif_timing[timing].Data_order << 16) |
+			(tvif_timing[timing].Inv_vsync << 13 ) |
+			(tvif_timing[timing].Inv_hsync << 12 ) |
+			(tvif_timing[timing].Inv_href << 11 ) |
+			(tvif_timing[timing].Inv_field << 10) |
+			(tvif_timing[timing].Begin_with_EAV << 0);
+
+	reg_temp[2] = (tvif_timing[timing].Matrix_mode << 31 ) |
+			(tvif_timing[timing].Passby << 30) |
+			(tvif_timing[timing].Inv_MSB_in << 29)|
+			(tvif_timing[timing].Inv_MSB_out << 28) |
+			(tvif_timing[timing].Matrix_oft_b << 8 ) |
+			(tvif_timing[timing].Matrix_oft_a << 0);
+
+	reg_temp[3] = tvif_timing[timing].UBA1_LEN;
+
+	reg_temp[4] = tvif_timing[timing].UNBA_LEN;
+
+	reg_temp[5] = tvif_timing[timing].UNBA2_LEN;
+
+	reg_temp[6] = tvif_timing[timing].LBA1_LEN;
+
+	reg_temp[7] = tvif_timing[timing].LNBA_LEN;
+
+	reg_temp[8] = tvif_timing[timing].LBA2_LEN;
+
+	reg_temp[9] = tvif_timing[timing].BLANK_LEN;
+
+	reg_temp[10] = tvif_timing[timing].VIDEO_LEN;
+
+	reg_temp[11] = (tvif_timing[timing].Hsync_VB1_ctrl << 30)|
+			(tvif_timing[timing].Hsync_delay << 16) |
+			(tvif_timing[timing].Hsync_extend);
+
+	reg_temp[12] = (tvif_timing[timing].Vsync_delay_upper << 16) |
+			(tvif_timing[timing].Vsync_extend_upper);
+
+	reg_temp[13] = (tvif_timing[timing].Vsync_delay_lower << 16) |
+			(tvif_timing[timing].Vsync_extend_lower);
+
+	reg_temp[14] = tvif_timing[timing].DISP_XSIZE;
+
+	reg_temp[15] = tvif_timing[timing].DISP_YSIZE;	
+
+	__raw_writel(reg_temp[0], IMAP_TVCCR);
+	__raw_writel(reg_temp[1], IMAP_TVICR);
+	__raw_writel(reg_temp[2], IMAP_TVCMCR);
+	__raw_writel(reg_temp[3], IMAP_TVUBA1);
+	__raw_writel(reg_temp[4], IMAP_TVUNBA);
+	__raw_writel(reg_temp[5], IMAP_TVUBA2);
+	__raw_writel(reg_temp[6], IMAP_TVLBA1);
+	__raw_writel(reg_temp[7], IMAP_TVLNBA);
+	__raw_writel(reg_temp[8], IMAP_TVLBA2);
+	__raw_writel(reg_temp[9], IMAP_TVBLEN);
+	__raw_writel(reg_temp[10], IMAP_TVVLEN);
+	__raw_writel(reg_temp[11], IMAP_TVHSCR);
+	__raw_writel(reg_temp[12], IMAP_TVVSHCR);
+	__raw_writel(reg_temp[13], IMAP_TVVSLCR);
+	__raw_writel(reg_temp[14], IMAP_TVXSIZE);
+	__raw_writel(reg_temp[15], IMAP_TVYSIZE);
+}
+
+void lcd_config_controller(LCD_TIMING timing)
+{	
+	unsigned int reg_temp[5];
+
+	if(timing == LCD)
+	{
+		/* if LCD , use imapfb_fimd configurations, apr.20.2011 */
+		writel(imapfb_fimd.lcdcon1, IMAP_LCDCON1); 
+		writel(imapfb_fimd.lcdcon2, IMAP_LCDCON2); 
+		writel(imapfb_fimd.lcdcon3, IMAP_LCDCON3); 
+		writel(imapfb_fimd.lcdcon4, IMAP_LCDCON4); 
+		writel(imapfb_fimd.lcdcon5, IMAP_LCDCON5); 
+
+		return ;
+	}
+
+	reg_temp[0] = (ids_timing[timing].VCLK <<	8) |		
+				(ids_timing[timing].EACH_FRAME << 7) |		
+				(ids_timing[timing].LCD_PANNEL << 5) |		
+				(ids_timing[timing].BPP_MODE << 1) |
+				(ids_timing[timing].LCD_OUTPUT);
+
+	reg_temp[1] = ((ids_timing[timing].VBPD -1) << 24) |
+				(((ids_timing[timing].VACTIVE -1) & ~0x400) <<14) |
+				((ids_timing[timing].VFPD -1 ) << 6) |
+				((ids_timing[timing].VSPW -1));
+
+	reg_temp[2] = (ids_timing[timing].VACTIVE_HIGHBIT <<31) |
+				((ids_timing[timing].HBPD -1) << 19) |
+				((ids_timing[timing].HACTIVE -1) << 8) |
+				((ids_timing[timing].HFPD -1));
+
+	reg_temp[3] = ((ids_timing[timing].HSPW -1));
+
+	reg_temp[4] = ((ids_timing[timing].COLOR_MODE) << 24)|
+				((ids_timing[timing].BPP24BL) << 12)|
+				((ids_timing[timing].FRM565) << 11) |
+				((ids_timing[timing].INVVCLK) << 10)|
+				((ids_timing[timing].INVVLINE) <<9 )|
+				((ids_timing[timing].INVVFRAME) <<8)|
+				((ids_timing[timing].INVVD) <<7) |
+				((ids_timing[timing].INVVDEN) << 6) |
+				((ids_timing[timing].INVPWREN) << 5)|
+				((ids_timing[timing].INVENDLINE) << 4)|
+				((ids_timing[timing].PWREN) << 3) |
+				((ids_timing[timing].ENLEND) <<2 ) |
+				((ids_timing[timing].BSWP) << 1) |
+				((ids_timing[timing].HWSWP));
+				
+	writel(reg_temp[0],IMAP_LCDCON1);
+	writel(reg_temp[1],IMAP_LCDCON2);
+	writel(reg_temp[2],IMAP_LCDCON3);
+	writel(reg_temp[3],IMAP_LCDCON4);
+	writel(reg_temp[4],IMAP_LCDCON5);
+}
+
+int HDMI_dev_init(struct i2c_client *client)
+{
+	unsigned int temp;
+	unsigned int ret;
+
+	/* get and config interrupt */
+	temp = __imapx_name_to_gpio(CONFIG_HDMI_SI9022_INT);
+
+	if(temp == IMAPX_GPIO_ERROR)
+	{
+		printk(KERN_ERR "Get SI9022 interrupt failed.\n");
+		return -ENOTTY;
+	}
+
+	
+	//si9022_irq = imapx_gpio_to_irq(temp);
+	/* config irq status */
+	//imapx_gpio_setirq(temp, FILTER_MAX, IG_FALL, 1);
+
+	TPI_Init();
+
+	/*
+	ret = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);
+	if(!((ret & HOT_PLUG_STATE) >> 2))
+	{
+		TxPowerState(TX_POWER_STATE_D3);
+	}
+	*/
+
+	/*
+	msleep(100);
+	lcd_change_timing(HDMI_1080P);
+	msleep(200);
+	OnHdmiCableConnected(HDMI_1080P);
+	ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);				
+	*/
+
+	return 0;
+}
+
+unsigned int hdmi_count = 0;
+
+static void hp_delayed_work(struct work_struct *work)
+{
+	unsigned int ret;
+	struct imap_HDMI_info *HDMI_info =
+		        container_of(to_delayed_work(work), struct imap_HDMI_info, delayed_work);
+	
+	ret = ReadByteTPI(TPI_INTERRUPT_STATUS_REG);
+
+//	printk("ret %d HDMI_QUERY_MONITOR_FLAG %d \
+			VIDEO_MODE %d DOUBLE_DISPLAY_MODE %d HDMI_HOTPLUG_RESULT %d \
+			hdmi_count %d\n",ret, HDMI_QUERY_MONITOR_FLAG, VIDEO_MODE,\
+		       				DOUBLE_DISPLAY_MODE, HDMI_HOTPLUG_RESULT, hdmi_count);
+	if(((ret & HOT_PLUG_STATE) >> 2) && \
+		(HDMI_QUERY_MONITOR_FLAG == 1) && \
+		(VIDEO_MODE == 0 || DOUBLE_DISPLAY_MODE == 0 || PANAUISION_MODE == 0) && \
+	       	HDMI_HOTPLUG_RESULT == 0 && \
+		hdmi_count >5)
+	{
+		HDMI_QUERY_MONITOR_FLAG = -1;
+		HDMI_HOTPLUG_IN = 1;
+		HDMI_HOTPLUG_RESULT = 1;
+		hdmi_count = 0;
+		complete(&Monitor_Wait);
+	}
+	else if((!((ret & HOT_PLUG_STATE) >> 2)) && \
+		(HDMI_QUERY_MONITOR_FLAG == 1) && \
+		(VIDEO_MODE == 1 || DOUBLE_DISPLAY_MODE == 1 || PANAUISION_MODE == 1) && \
+		HDMI_HOTPLUG_RESULT == 1 &&\
+		hdmi_count >5)
+	{
+		HDMI_QUERY_MONITOR_FLAG = -1;
+		HDMI_HOTPLUG_IN= 0;
+		HDMI_HOTPLUG_RESULT = 0;
+		hdmi_count = 0;
+		complete(&Monitor_Wait);
+	}
+
+	hdmi_count ++ ;
+sche:
+	schedule_delayed_work(&HDMI_info->delayed_work,
+			msecs_to_jiffies(HDMI_HP_POLL_DELAY));
+}
+
+
+
+static int HDMI_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct device *dev = NULL;
+	struct task_struct *t;
+
+	printk(KERN_INFO "Device for HDMI will be Initializad\n");
+
+	/* register this i2c device with the driver core */
+	dev = device_create(HDMI_class, NULL, MKDEV(HDMI_MAJOR, HDMI_MINOR), NULL, "HDMI");
+	if (IS_ERR(dev))
+	{
+		ret = PTR_ERR(dev);
+		goto exit;
+	}
+
+	dev = device_create(HDMI_class, NULL, MKDEV(HDMI_POLL_MAJOR, HDMI_MINOR), NULL, "HDMI_poll");
+	if (IS_ERR(dev))
+	{
+		ret = PTR_ERR(dev);
+		goto exit;
+	}
+
+	memcpy(&gHDMIClient, client, sizeof(struct i2c_client));
+
+	mutex_init(&HDMI_lock);
+
+	/* HDMI device initialization */
+	ret = HDMI_dev_init(client);
+	if (ret < 0)
+	{
+		printk(KERN_ERR "HDMI_i2c_probe: failed to initialise SI9022\n");
+		goto exit;
+	}
+
+	printk(KERN_INFO "Init HDMI device OK\n");
+
+	return 0;
+
+exit:
+	return ret;
+}
+
+static int HDMI_i2c_remove(struct i2c_client *client)
+{
+	printk(KERN_INFO "Remove HDMI device driver\n");
+
+	mutex_destroy(&HDMI_lock);
+
+	return 0;
+}
+
+static unsigned int 
+HDMI_poll(struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask;
+
+	poll_wait(file, &HDMI_wait, wait);
+
+	if(HDMI_HOTPLUG_IN == 1)
+		mask |= POLLIN | POLLRDNORM;
+	else
+		mask = POLLERR;
+
+	return mask;
+}
+
+static int HDMI_open(struct inode *inode, struct file *file)
+{
+	file->private_data = &gHDMIClient;
+	return 0;
+}
+
+static int HDMI_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static ssize_t
+HDMI_poll_write(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	HDMI_QUERY_MONITOR_FLAG = 1;
+	wait_for_completion(&Monitor_Wait);
+	printk("Monitor wait completion\n");
+
+	return 0;
+}
+
+static ssize_t
+HDMI_poll_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned int HDMI_HOTPLUG_TYPE = 0;
+	int ret = 0;
+
+	if(HDMI_HOTPLUG_IN == -1)
+	{
+		if(HDMI_MENU_SWITCH == -1)
+			HDMI_HOTPLUG_TYPE = 1;	/*No hotplug	No Menu button pressed*/
+		else if(HDMI_MENU_SWITCH == 0)
+			HDMI_HOTPLUG_TYPE = 2;	/*No hotplug	Menu Button Pressed to LCD*/
+		else if(HDMI_MENU_SWITCH == 1)
+			HDMI_HOTPLUG_TYPE = 3;	/*No hotplug	Menu Button Pressed to TV*/
+	}
+	else if(HDMI_HOTPLUG_IN == 0)
+	{
+		if(HDMI_MENU_SWITCH == -1)
+			HDMI_HOTPLUG_TYPE = 4;	/*hotplug out detected No menu button pressed*/
+		else if (HDMI_MENU_SWITCH == 0)
+			HDMI_HOTPLUG_TYPE = 5 ;	/*hotplug out detected menu button pressed to LCD*/
+		else if (HDMI_MENU_SWITCH == 1)
+			HDMI_HOTPLUG_TYPE = 6 ;	/*hotplug out detected menu button pressed to TV*/
+	}
+	else if(HDMI_HOTPLUG_IN == 1)
+	{
+		if(HDMI_MENU_SWITCH == -1)
+			HDMI_HOTPLUG_TYPE = 7;	/*hotplug in detected No menu button pressed*/
+		else if (HDMI_MENU_SWITCH == 0)
+			HDMI_HOTPLUG_TYPE = 8 ;	/*hotplug in detected menu button pressed to LCD*/
+		else if (HDMI_MENU_SWITCH == 1)
+			HDMI_HOTPLUG_TYPE = 9 ;	/*hotplug in detected menu button pressed to TV*/
+	}
+
+	if(copy_to_user((void __user *)buf, &HDMI_HOTPLUG_TYPE, sizeof(unsigned int)))
+	{
+		printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+		ret = -EFAULT;
+	}
+	HDMI_HOTPLUG_IN = -1;
+	HDMI_MENU_SWITCH = -1;
+
+	return ret;
+}
+
+static long HDMI_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	unsigned int temp1;
+	unsigned int temp2;
+	unsigned int check_result;
+	unsigned long flags;
+	void __user *argp = (void __user *)arg;
+	LCD_TIMING HDMI_TIMING_TYPE ;
+	
+	mutex_lock(&HDMI_lock);
+
+	switch(cmd)
+	{
+		case HDMI_CHECK_MODE:
+			printk("%s commond :HDMI_CHECK previous_mode %d\n",__func__, previous_mode);
+			if(copy_to_user((void __user *)argp, &previous_mode, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+				ret = -EFAULT;
+			}
+			break;
+		case HDMI_CHECK_CONNECT:
+			printk("%s commond :HDMI_CHECK_CONNECT\n",__func__);
+			if(copy_to_user((void __user *)argp, &HDMI_HOTPLUG_RESULT, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+				ret = -EFAULT;
+			}
+			break;
+		case HDMI_SET_MODE:
+			printk("%s commond :HDMI_SET_MODE previous_mode %d\n",__func__, previous_mode);
+			if(copy_from_user(&previous_mode, argp, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy previous_mode from  user space error\n");
+				ret = -EFAULT;
+			}
+			break;
+		case HDMI_SET_NOTMAL_TIMING:  //return
+			if(VIDEO_MODE == 1 || DOUBLE_DISPLAY_MODE == 1 || PANAUISION_MODE == 1)
+			{
+				printk("%s commond : HDMI_SET_NOTMAL_TIMING\n",__func__);
+#ifdef CONFIG_UI_MAP_COLOR
+				if(VIDEO_MODE == 1)
+				{
+					__raw_writel(~0x1<<24, IMAP_OVCW0CMR);
+					__raw_writel(~0x1<<24, IMAP_OVCW3CMR);
+				}
+#endif
+				turn_off_backlight();
+				VIDEO_MODE = 0;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+				DisableTMDS();
+				msleep(1000);
+				lcd_change_timing(LCD, 1);
+				imap_iokey_spken(1);
+				turn_on_backlight();
+			}
+			break;
+		case HDMI_SET_VIDEO_TIMING:  //enter hdmi mode
+			if(copy_from_user(&HDMI_TIMING_TYPE, argp, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy from user space error\n");
+				ret = -EFAULT;
+			}
+			if(VIDEO_MODE == 0)
+			{
+				turn_off_backlight();
+				imap_iokey_spken(0);
+				printk("%s commond : HDMI_SET_VIDEO_TIMING\n",__func__);
+#ifdef CONFIG_UI_MAP_COLOR
+				__raw_writel(0x1<<24 | ((0x0 & 0xffffff)<<0), IMAP_OVCW0CMR);
+				__raw_writel(0x1<<24 | ((0x0 & 0xffffff)<<0), IMAP_OVCW3CMR);
+#endif
+				lcd_change_timing(HDMI_TIMING_TYPE - HDMI_640_480, 1);
+				msleep(50);
+				OnHdmiCableConnected(HDMI_TIMING_TYPE - HDMI_640_480);
+				ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);	
+				VIDEO_MODE = 1;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+			}
+			break;
+		case HDMI_SET_DOUBLE_DISPLAY_TIMING:
+#ifdef CONFIG_DOUBLE_DISPLAY_MODE
+#ifdef CONFIG_UI_MAP_COLOR
+			if(VIDEO_MODE == 1)
+			{
+				__raw_writel(~0x1<<24, IMAP_OVCW0CMR);
+				__raw_writel(~0x1<<24, IMAP_OVCW3CMR);
+			}
+#endif
+			if(DOUBLE_DISPLAY_MODE == 0)
+			{
+				turn_off_backlight();
+				DisableTMDS();
+				printk("%s commond :HDMI_SET_DOUBLE_DISPLAY_TIMING\n",__func__);
+				if(imapfb_fimd.xres == 800){
+					lcd_change_timing(HDMI_800_600, 1);
+					msleep(50);
+					OnHdmiCableConnected(HDMI_800_600);
+					ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);	
+				}else if(imapfb_fimd.xres == 1024){
+					lcd_change_timing(HDMI_1024_768, 1);
+					msleep(50);
+					OnHdmiCableConnected(HDMI_1024_768);
+					ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);	
+				}
+				DOUBLE_DISPLAY_MODE = 1;
+				PANAUISION_MODE = 0;
+				VIDEO_MODE = 0;
+				previous_mode = 1;
+				msleep(1000);
+				turn_on_backlight();
+				imap_iokey_spken(1);
+			}
+#else
+			printk("double display mode not supported\n");
+			if(VIDEO_MODE == 1|| PANAUISION_MODE == 1 || DOUBLE_DISPLAY_MODE == 1)
+			{
+				VIDEO_MODE = 0;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+				DisableTMDS();
+				lcd_change_timing(LCD, 1);
+				imap_iokey_spken(1);
+				turn_on_backlight();
+			}
+			ret = -1;
+#endif
+			break;
+		case HDMI_SET_PANAUISION_TIMING:
+#ifdef CONFIG_PANAUISION_MODE
+#ifdef CONFIG_UI_MAP_COLOR
+			if(VIDEO_MODE == 1)
+			{
+				__raw_writel(~0x1<<24, IMAP_OVCW0CMR);
+				__raw_writel(~0x1<<24, IMAP_OVCW3CMR);
+			}
+#endif
+			if(PANAUISION_MODE == 0)
+			{
+				turn_off_backlight();
+				imap_iokey_spken(0);
+				DisableTMDS();
+				printk("%s commond :HDMI_PANAUISION_TIMING\n",__func__);
+				if(imapfb_fimd.xres == 800){
+					lcd_change_timing(HDMI_1024_768, 1);
+					osd_excursion(HDMI_1024_768);
+					msleep(50);
+					OnHdmiCableConnected(HDMI_1024_768);
+					ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);	
+				}else if(imapfb_fimd.xres == 1024){
+					lcd_change_timing(HDMI_720P, 1);
+					osd_excursion(HDMI_720P);
+					msleep(50);
+					OnHdmiCableConnected(HDMI_720P);
+					ReadModifyWriteIndexedRegister(INDEXED_PAGE_0, 0x0A, 0x08, 0x08);	
+				}
+				PANAUISION_MODE = 1;
+				DOUBLE_DISPLAY_MODE = 0;
+				VIDEO_MODE = 0;
+				previous_mode = 2;
+			}
+#else
+			printk("panauision mode not supported\n");
+			if(VIDEO_MODE == 1|| PANAUISION_MODE == 1 || DOUBLE_DISPLAY_MODE == 1)
+			{
+				VIDEO_MODE = 0;
+				DOUBLE_DISPLAY_MODE = 0;
+				PANAUISION_MODE = 0;
+				DisableTMDS();
+				lcd_change_timing(LCD, 1);
+				imap_iokey_spken(1);
+				turn_on_backlight();
+			}
+			ret = -1;
+#endif
+			break;
+		case HDMI_TV_SUPPORT_V_MODE:
+			if(copy_to_user((void __user *)argp, &TV_V_MODE, sizeof(unsigned int)))
+			{
+				printk(KERN_ERR "[HDMI_ioctl]: copy to user space error\n");
+				ret = -EFAULT;
+			}
+
+			break;
+		default:
+			printk(KERN_ERR "[HDMI_ioctl]: unknown command type\n");
+			ret = -EFAULT;
+			break;
+	}
+	mutex_unlock(&HDMI_lock);
+	return ret;
+}
+
+#if defined(CONFIG_PM)
+int HDMI_i2c_suspend(struct i2c_client *client, pm_message_t state)
+{
+	printk(KERN_INFO "iic Suspend SI9022\n");
+	if(HDMI_HOTPLUG_RESULT == 1 && (( VIDEO_MODE == 1) || (DOUBLE_DISPLAY_MODE == 1) || (PANAUISION_MODE == 1)))
+	{
+		TxPowerState(TX_POWER_STATE_D3);
+		lcd_change_timing(LCD, 1);
+		VIDEO_MODE = 0;
+		DOUBLE_DISPLAY_MODE = 0;
+		PANAUISION_MODE = 0;
+		HDMI_HOTPLUG_RESULT = 0;
+	}
+
+	HDMI_power(0);
+	return 0;
+}
+		
+int HDMI_i2c_resume(struct i2c_client *client)
+{
+	printk(KERN_INFO "iic Resume SI9022\n");
+	
+	HDMI_power(1);
+	TPI_Init();
+
+	return 0;
+}		
+#endif
+
+static const struct file_operations HDMI_fops = {
+	.owner                  = THIS_MODULE,
+	.unlocked_ioctl = HDMI_ioctl,
+	.open                   = HDMI_open,
+	.poll		= HDMI_poll,
+	.release                        = HDMI_release,
+};
+
+static const struct file_operations HDMI_poll_fops = {
+	.owner                  = THIS_MODULE,
+	.read		= HDMI_poll_read,
+	.write		= HDMI_poll_write,
+};
+
+static struct i2c_driver HDMI_i2c_driver = {
+	.driver = {
+		.name = "imap_HDMI-i2c",
+		.owner = THIS_MODULE,
+	},
+	.probe = HDMI_i2c_probe,
+	.remove = HDMI_i2c_remove,
+#if defined(CONFIG_PM) 
+	.suspend = HDMI_i2c_suspend,
+	.resume = HDMI_i2c_resume,
+#endif
+	.id_table = HDMI_i2c_id,
+};
+
+static int HDMI_power(int en)
+{
+	unsigned long gpio;
+
+	gpio = __imapx_name_to_gpio(CONFIG_HDMI_SI9022_POWER);
+
+	if(gpio == IMAPX_GPIO_ERROR)
+	  /* power gpio is not configurated */
+	  return 0;
+
+	imapx_gpio_setcfg(gpio, IG_OUTPUT, IG_NMSL);
+	if(en)
+	  imapx_gpio_setpin(gpio, 1, IG_NMSL);
+	else
+	  imapx_gpio_setpin(gpio, 0, IG_NMSL);
+
+	return 0;
+}
+
+static int __init HDMI_probe(struct platform_device *pdev)
+{
+	struct i2c_board_info info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct imap_HDMI_info *HDMI_info;
+	int ret;
+
+#ifdef CONFIG_FAKE_PM
+	if_in_suspend = 0;
+#endif
+
+	printk(KERN_INFO "HDMI Probe to add i2c driver for HDMI device\n");
+
+	HDMI_power(1);
+	HDMI_info =(struct imap_HDMI_info *) kzalloc(sizeof(struct imap_HDMI_info), GFP_KERNEL);
+	if(!HDMI_info)
+	{
+		printk(KERN_ERR "Cannot allocate for HDMI_info\n");
+		return -ENOMEM;
+	}
+
+	ret = register_chrdev(HDMI_MAJOR, "imap-HDMI", &HDMI_fops);
+	if (ret)
+		goto out;
+
+	ret = register_chrdev(HDMI_POLL_MAJOR, "imap-HDMI_poll", &HDMI_poll_fops);
+	if (ret)
+		goto out;
+
+	HDMI_class = class_create(THIS_MODULE, "HDMI_dev");
+	if (IS_ERR(HDMI_class))
+	{
+		printk(KERN_ERR "HDMI_init: fail to create HDMI device class\n");
+		ret = PTR_ERR(HDMI_class);
+		goto out_unreg_chrdev;
+	}
+
+	/* Add i2c_driver */
+	ret = i2c_add_driver(&HDMI_i2c_driver);
+	if(ret)
+	{
+		printk(KERN_ERR "HDMI_init: fail to register i2c driver\n");
+		goto out_unreg_class;
+	}
+
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	info.addr = i2c_device_address;
+	strlcpy(info.type, "imap_HDMI", I2C_NAME_SIZE);
+
+	adapter = i2c_get_adapter(CONFIG_HDMI_SI9022_I2C + 1);
+	if (!adapter)
+	{
+		printk(KERN_ERR "HDMI_init: can't get i2c adapter\n");
+		goto err_adapter;
+	}
+
+	HDMI_info->client = i2c_new_device(adapter, &info);
+	i2c_put_adapter(adapter);
+	if (!(HDMI_info->client))
+	{
+		printk(KERN_ERR "HDMI_init: can't add i2c device at 0x%x\n", (unsigned int)info.addr);
+		goto err_adapter;
+	}
+
+	spin_lock_init(&lock);
+	init_completion(&Monitor_Wait); 
+	HDMI_info->dev = &(pdev->dev);
+
+	INIT_DELAYED_WORK(&HDMI_info->delayed_work, hp_delayed_work);
+
+	schedule_delayed_work(&HDMI_info->delayed_work,
+	                      msecs_to_jiffies(HDMI_HP_POLL_DELAY));
+
+
+	platform_set_drvdata(pdev, HDMI_info);
+
+	printk(KERN_INFO "HDMI device add i2c driver OK!\n");
+
+	return 0;
+
+err_adapter:
+	i2c_del_driver(&HDMI_i2c_driver);
+out_unreg_class:
+	class_destroy(HDMI_class);
+out_unreg_chrdev:
+	unregister_chrdev(HDMI_MAJOR, "imap-HDMI");
+	unregister_chrdev(HDMI_POLL_MAJOR, "imap-HDMI_poll");
+
+out:
+	printk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);
+
+	return ret;
+}
+
+static int HDMI_remove(struct platform_device *pdev)
+{
+	struct imap_HDMI_info *info = (struct imap_HDMI_info *)platform_get_drvdata(pdev);
+
+	i2c_unregister_device(info->client);
+	i2c_del_driver(&HDMI_i2c_driver);
+	class_destroy(HDMI_class);
+	unregister_chrdev(HDMI_MAJOR, "imap-HDMI");
+	unregister_chrdev(HDMI_POLL_MAJOR, "imap-HDMI_poll");
+
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+int HDMI_suspend(struct platform_device *dev, pm_message_t state)
+{
+	printk(KERN_INFO "Suspend EP932\n");
+	return 0;
+}
+		
+int HDMI_resume(struct platform_device *dev)
+{
+        printk(KERN_INFO "Resume EP932\n");
+	return 0;
+}		
+#endif
+
+static struct platform_driver HDMI_driver = {
+	.driver = {
+		.name = "imap-HDMI",
+		.owner = THIS_MODULE,
+	},
+	.probe = HDMI_probe,
+	.suspend = HDMI_suspend,
+	.resume = HDMI_resume,
+	.remove = HDMI_remove,
+};
+
+static int __init HDMI_init(void)
+{
+	return platform_driver_register(&HDMI_driver);
+}
+
+static void __exit HDMI_exit(void)
+{
+	platform_driver_unregister(&HDMI_driver);
+}
+
+module_init(HDMI_init);
+module_exit(HDMI_exit);
+
+MODULE_DESCRIPTION("Infotm HDMI driver");
+MODULE_AUTHOR("Alex Zhang, <alex.zhang@infotmic.com.cn>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/hdmi/si9022/imap_HDMI.h b/drivers/video/hdmi/si9022/imap_HDMI.h
new file mode 100644
index 0000000..3277aba
--- /dev/null
+++ b/drivers/video/hdmi/si9022/imap_HDMI.h
@@ -0,0 +1,264 @@
+/***************************************************************************** 
+ * ** drivers/video/infotm_HDMI/imap_HDMI.h
+ * ** 
+ * ** Copyright (c) 2009~2014 ShangHai Infotm Ltd all rights reserved. 
+ * ** 
+ * ** Use of Infotm's code is governed by terms and conditions 
+ * ** stated in the accompanying licensing statement. 
+ * ** 
+ * ** Description: Head file of Infotm HDMI.
+ * **
+ * ** Author:
+ * **     Alex Zhang <alex.zhang@infotmic.com.cn>
+ * **      
+ * ** Revision History: 
+ * ** ----------------- 
+ * ** 1.0  06/11/2010 Alex Zhang 
+* *****************************************************************************/
+#ifndef __IMAP_HDMI_H__
+#define __IMAP_HDMI_H__
+
+
+//typedef unsigned long UINT32;
+#define UINT32 unsigned long
+typedef unsigned long BOOL; 
+
+typedef struct{
+/*LCDCON1*/
+	UINT32 VCLK;
+	UINT32 EACH_FRAME;
+	UINT32 LCD_PANNEL;
+	UINT32 BPP_MODE;
+	UINT32 LCD_OUTPUT;
+
+/*LCDCON2*/
+	UINT32 VBPD;
+	UINT32 VACTIVE;
+	UINT32 VFPD;
+	UINT32 VSPW;
+
+/*LCDCON3*/	
+	UINT32 VACTIVE_HIGHBIT;
+	UINT32 HBPD;
+	UINT32 HACTIVE;
+	UINT32 HFPD;
+
+/*LCDCON4*/	
+	UINT32 HSPW;
+
+/*LCDCON5*/
+	UINT32 COLOR_MODE;
+	UINT32 BPP24BL;
+	UINT32 FRM565;
+	UINT32 INVVCLK;
+	UINT32 INVVLINE;
+	UINT32 INVVFRAME;
+	UINT32 INVVD;
+	UINT32 INVVDEN;
+	UINT32 INVPWREN;
+	UINT32 INVENDLINE;
+	UINT32 PWREN;
+	UINT32 ENLEND;
+	UINT32 BSWP;
+	UINT32 HWSWP;
+} struct_lcd_timing_param;
+
+typedef struct{
+/*IMAP_TVCCR*/
+	UINT32 Clock_enable;
+	UINT32 TV_PCLK_mode;
+	UINT32 Inv_clock;
+	UINT32 clock_sel;
+       	UINT32 Clock_div;
+
+/*TVICR*/
+	UINT32 tvif_enable;
+	UINT32 ITU601_656n;
+	UINT32 Bit16ofITU60;
+	UINT32 Direct_data;
+	UINT32 Bitswap;
+	UINT32 Data_order;
+	UINT32 Inv_vsync;
+	UINT32 Inv_hsync;
+	UINT32 Inv_href;
+	UINT32 Inv_field;
+	UINT32 Begin_with_EAV;
+
+/*TVCMCR*/
+	UINT32 Matrix_mode;
+	UINT32 Passby;
+	UINT32 Inv_MSB_in;
+	UINT32 Inv_MSB_out;
+	UINT32 Matrix_oft_b;
+	UINT32 Matrix_oft_a;
+
+/*TVUBA1
+ *
+ *VBPD+VSPW
+ *
+ */
+	UINT32 UBA1_LEN;
+
+/*TVUNBA
+ *
+ *vACTIVE
+ *
+ */	
+	UINT32 UNBA_LEN;
+
+/*TVUBA2
+ *
+ *VFPD
+ *
+ */
+	UINT32 UNBA2_LEN;
+
+/*TVLBA1
+ *
+ *VBPD+VSPW
+ *
+ */
+	UINT32 LBA1_LEN;
+
+/*TVLNBA
+ *
+ *VACTIVE
+ *
+ */
+	UINT32 LNBA_LEN;
+
+/*TVLBA2
+ *
+ *VFPD
+ *
+ */
+	UINT32 LBA2_LEN;
+
+/*TVBLEN
+ *
+ *HFPD+HSPW+HBPD-8
+ *
+ */
+	UINT32 BLANK_LEN;
+
+/*TVVLEN
+ *
+ *HACTIVE
+ *
+ */	
+	UINT32 VIDEO_LEN;
+
+/*TVHSCR
+ *
+ *0
+ *HFPD
+ *HSPW
+ *
+ */
+	UINT32 Hsync_VB1_ctrl;
+	UINT32 Hsync_delay;
+	UINT32 Hsync_extend;
+
+/*TVVSHCR
+ *
+ *HFPD
+ *VSPW*HTOTAL-1
+ *
+ */
+	UINT32 Vsync_delay_upper;
+	UINT32 Vsync_extend_upper;
+
+/*TVVSLCR
+ *
+ *HFPD
+ *VSPW*HTOTAL-1
+ */
+	UINT32 Vsync_delay_lower;
+	UINT32 Vsync_extend_lower;
+
+/*TVXSIZE
+ *
+ *HACTIVE-1
+ *
+ */
+	UINT32 DISP_XSIZE;
+
+/*TVYSIZE
+ *
+ *VACTIVE-1
+ *
+ */
+	UINT32 DISP_YSIZE;
+	
+}struct_tvif_timing_param;
+
+typedef struct{
+/*DPLLCFG*/
+	UINT32 DPLLCFG;
+
+/*DIVCFG4*/	
+	UINT32 DIVCFG4;
+} struct_lds_clk_param;
+
+typedef enum
+{
+	LCD = 0,
+	HDMI_1080P,
+//	HDMI_1080I,
+	HDMI_720P,
+	HDMI_480P_16_9,
+	HDMI_480P_4_3,
+//	HDMI_480I_16_9,
+//	HDMI_480I_4_3,
+	HDMI_576P_16_9,
+	HDMI_576P_4_3,
+//	HDMI_576I_16_9,
+//	HDMI_576I_4_3,
+	HDMI_640_480,	
+	HDMI_800_600,	
+	HDMI_1024_768,	
+	HDMI_1080P_TV,
+//	HDMI_1080I,
+	HDMI_720P_TV,
+	HDMI_480P_16_9_TV,
+	HDMI_480P_4_3_TV,
+//	HDMI_480I_16_9,
+//	HDMI_480I_4_3,
+	HDMI_576P_16_9_TV,
+	HDMI_576P_4_3_TV,
+//	HDMI_576I_16_9,
+//	HDMI_576I_4_3,
+	HDMI_640_480_TV,	
+	HDMI_800_600_TV,	
+	HDMI_1024_768_TV,	
+}LCD_TIMING;
+
+/*
+struct imap_HDMI_info {
+	void (* ClearPending)(void);
+	void (* HotplugMonitor)(void);
+	struct tasklet_struct my_tasklet;
+	struct i2c_client *client
+};
+*/
+
+BOOL lcd_change_timing(LCD_TIMING timing, BOOL tv_IF);
+void lcd_config_clk(LCD_TIMING timing);
+void lcd_config_controller(LCD_TIMING timing);
+void tvif_config_controller(LCD_TIMING timing);
+
+#define HDMI_CHECK_HOTPLUG	_IOR('H', 301, UINT32)
+#define HDMI_SET_NOTMAL_TIMING	_IO('H', 302)
+#define HDMI_SET_VIDEO_TIMING	_IOW('H', 303, UINT32)
+#define HDMI_SET_DOUBLE_DISPLAY_TIMING	_IO('H', 311)
+#define HDMI_SET_PANAUISION_TIMING	_IO('H', 312)
+#define HDMI_QUERY_APP		_IO('H', 304)
+#define HDMI_QUERY_RENDER	_IO('H', 305)
+#define HDMI_CHECK_MENUSWITCH	_IOR('H', 306, UINT32)
+#define HDMI_CHECK_MODE		_IOR('H', 307, UINT32)
+#define HDMI_CHECK_CONNECT		_IOR('H', 314, UINT32)
+#define HDMI_SET_MODE		_IOW('H', 313, UINT32)
+#define HDMI_QUERY_MONITOR	_IO('H', 308)
+#define HDMI_TV_SUPPORT_V_MODE  _IOR('H', 310, UINT32)
+
+#endif
