diff --git a/drivers/cpufreq/cpufreq_smartass2.c b/drivers/cpufreq/cpufreq_smartass2.c
index 2eab720..d37cfb9 100644
--- a/drivers/cpufreq/cpufreq_smartass2.c
+++ b/drivers/cpufreq/cpufreq_smartass2.c
@@ -110,9 +110,21 @@ static unsigned int sleep_wakeup_freq;
 #define DEFAULT_SAMPLE_RATE_JIFFIES 2
 static unsigned int sample_rate_jiffies;
 
+/*
+ * Boost enabled
+ */
+#define DEFAULT_BOOST_ENABLED 0
+static unsigned int boost_enabled;
 
-/*************** End of tunables ***************/
+/*
+ * Boost pulse
+ */
+#define DEFAULT_BOOST_PULSE 500000
+#define MAX_BOOST_PULSE 5000000
+static unsigned long boost_pulse;
+static u64 boost_pulse_time;
 
+/*************** End of tunables ***************/
 
 static void (*pm_idle_old)(void);
 static atomic_t active_count = ATOMIC_INIT(0);
@@ -380,6 +392,8 @@ static void cpufreq_smartass_freq_change_time_work(struct work_struct *work)
 	struct smartass_info_s *this_smartass;
 	struct cpufreq_policy *policy;
 	unsigned int relation = CPUFREQ_RELATION_L;
+	unsigned int boosted;
+
 	for_each_possible_cpu(cpu) {
 		this_smartass = &per_cpu(smartass_info, cpu);
 		if (!work_cpumask_test_and_clear(cpu))
@@ -391,52 +405,75 @@ static void cpufreq_smartass_freq_change_time_work(struct work_struct *work)
 		old_freq = this_smartass->old_freq;
 		policy = this_smartass->cur_policy;
 
-		if (old_freq != policy->cur) {
-			// frequency was changed by someone else?
-			printk(KERN_WARNING "Smartass: frequency changed by 3rd party: %d to %d\n",
-			       old_freq,policy->cur);
-			new_freq = old_freq;
-		}
-		else if (ramp_dir > 0 && nr_running() > 1) {
-			// ramp up logic:
-			if (old_freq < this_smartass->ideal_speed)
-				new_freq = this_smartass->ideal_speed;
-			else if (ramp_up_step) {
-				new_freq = old_freq + ramp_up_step;
-				relation = CPUFREQ_RELATION_H;
+		// boost pulse:
+		boosted = 0;
+		if (boost_enabled > 0 && boost_pulse > 0) {
+			u64 now = ktime_to_us(ktime_get());
+			if (now <= boost_pulse_time + boost_pulse) {
+				// boost logic:
+				if (old_freq < this_smartass->ideal_speed) {
+					new_freq = this_smartass->ideal_speed;
+					relation = CPUFREQ_RELATION_H;
+					boosted = 1;
+				}
+				dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d boost %d\n",
+					old_freq,new_freq);
 			}
 			else {
-				new_freq = policy->max;
-				relation = CPUFREQ_RELATION_H;
+				boost_pulse = 0;
+				dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d boost end\n",
+					old_freq);
 			}
-			dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d ramp up: ramp_dir=%d ideal=%d\n",
-				old_freq,ramp_dir,this_smartass->ideal_speed);
 		}
-		else if (ramp_dir < 0) {
-			// ramp down logic:
-			if (old_freq > this_smartass->ideal_speed) {
-				new_freq = this_smartass->ideal_speed;
-				relation = CPUFREQ_RELATION_H;
+
+		if (boosted == 0) {
+			if (old_freq != policy->cur) {
+				// frequency was changed by someone else?
+				printk(KERN_WARNING "Smartass: frequency changed by 3rd party: %d to %d\n",
+						old_freq,policy->cur);
+				new_freq = old_freq;
 			}
-			else if (ramp_down_step)
-				new_freq = old_freq - ramp_down_step;
-			else {
-				// Load heuristics: Adjust new_freq such that, assuming a linear
-				// scaling of load vs. frequency, the load in the new frequency
-				// will be max_cpu_load:
-				new_freq = old_freq * this_smartass->cur_cpu_load / max_cpu_load;
-				if (new_freq > old_freq) // min_cpu_load > max_cpu_load ?!
-					new_freq = old_freq -1;
+			else if (ramp_dir > 0 && nr_running() > 1) {
+				// ramp up logic:
+				if (old_freq < this_smartass->ideal_speed)
+					new_freq = this_smartass->ideal_speed;
+				else if (ramp_up_step) {
+					new_freq = old_freq + ramp_up_step;
+					relation = CPUFREQ_RELATION_H;
+				}
+				else {
+					new_freq = policy->max;
+					relation = CPUFREQ_RELATION_H;
+				}
+				dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d ramp up: ramp_dir=%d ideal=%d\n",
+					old_freq,ramp_dir,this_smartass->ideal_speed);
+			}
+			else if (ramp_dir < 0) {
+				// ramp down logic:
+				if (old_freq > this_smartass->ideal_speed) {
+					new_freq = this_smartass->ideal_speed;
+					relation = CPUFREQ_RELATION_H;
+				}
+				else if (ramp_down_step)
+					new_freq = old_freq - ramp_down_step;
+				else {
+					// Load heuristics: Adjust new_freq such that, assuming a linear
+					// scaling of load vs. frequency, the load in the new frequency
+					// will be max_cpu_load:
+					new_freq = old_freq * this_smartass->cur_cpu_load / max_cpu_load;
+					if (new_freq > old_freq) // min_cpu_load > max_cpu_load ?!
+						new_freq = old_freq -1;
+				}
+				dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d ramp down: ramp_dir=%d ideal=%d\n",
+					old_freq,ramp_dir,this_smartass->ideal_speed);
+			}
+			else { // ramp_dir==0 ?! Could the timer change its mind about a queued ramp up/down
+				// before the work task gets to run?
+				// This may also happen if we refused to ramp up because the nr_running()==1
+				new_freq = old_freq;
+				dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d nothing: ramp_dir=%d nr_running=%lu\n",
+					old_freq,ramp_dir,nr_running());
 			}
-			dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d ramp down: ramp_dir=%d ideal=%d\n",
-				old_freq,ramp_dir,this_smartass->ideal_speed);
-		}
-		else { // ramp_dir==0 ?! Could the timer change its mind about a queued ramp up/down
-		       // before the work task gets to run?
-		       // This may also happen if we refused to ramp up because the nr_running()==1
-			new_freq = old_freq;
-			dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d nothing: ramp_dir=%d nr_running=%lu\n",
-				old_freq,ramp_dir,nr_running());
 		}
 
 		// do actual ramp up (returns 0, if frequency change failed):
@@ -465,9 +502,10 @@ static ssize_t store_debug_mask(struct kobject *kobj, struct attribute *attr, co
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0)
-		debug_mask = input;
-	return res;
+	if (res < 0)
+		return -EINVAL;
+	debug_mask = input;
+	return count;
 }
 
 static ssize_t show_up_rate_us(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -480,9 +518,11 @@ static ssize_t store_up_rate_us(struct kobject *kobj, struct attribute *attr, co
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0 && input <= 100000000)
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0 && input <= 100000000)
 		up_rate_us = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_down_rate_us(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -495,9 +535,11 @@ static ssize_t store_down_rate_us(struct kobject *kobj, struct attribute *attr,
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0 && input <= 100000000)
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0 && input <= 100000000)
 		down_rate_us = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_sleep_ideal_freq(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -510,12 +552,14 @@ static ssize_t store_sleep_ideal_freq(struct kobject *kobj, struct attribute *at
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0) {
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0) {
 		sleep_ideal_freq = input;
 		if (suspended)
 			smartass_update_min_max_allcpus();
 	}
-	return res;
+	return count;
 }
 
 static ssize_t show_sleep_wakeup_freq(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -528,9 +572,11 @@ static ssize_t store_sleep_wakeup_freq(struct kobject *kobj, struct attribute *a
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0)
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0)
 		sleep_wakeup_freq = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_awake_ideal_freq(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -543,12 +589,14 @@ static ssize_t store_awake_ideal_freq(struct kobject *kobj, struct attribute *at
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0) {
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0) {
 		awake_ideal_freq = input;
 		if (!suspended)
 			smartass_update_min_max_allcpus();
 	}
-	return res;
+	return count;
 }
 
 static ssize_t show_sample_rate_jiffies(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -561,9 +609,11 @@ static ssize_t store_sample_rate_jiffies(struct kobject *kobj, struct attribute
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input > 0 && input <= 1000)
+	if (res < 0)
+		return -EINVAL;
+	if (input > 0 && input <= 1000)
 		sample_rate_jiffies = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_ramp_up_step(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -576,9 +626,11 @@ static ssize_t store_ramp_up_step(struct kobject *kobj, struct attribute *attr,
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0)
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0)
 		ramp_up_step = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_ramp_down_step(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -591,9 +643,11 @@ static ssize_t store_ramp_down_step(struct kobject *kobj, struct attribute *attr
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input >= 0)
+	if (res < 0)
+		return -EINVAL;
+	if (input >= 0)
 		ramp_down_step = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_max_cpu_load(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -606,9 +660,11 @@ static ssize_t store_max_cpu_load(struct kobject *kobj, struct attribute *attr,
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input > 0 && input <= 100)
+	if (res < 0)
+		return -EINVAL;
+	if (input > 0 && input <= 100)
 		max_cpu_load = input;
-	return res;
+	return count;
 }
 
 static ssize_t show_min_cpu_load(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -621,14 +677,55 @@ static ssize_t store_min_cpu_load(struct kobject *kobj, struct attribute *attr,
 	ssize_t res;
 	unsigned long input;
 	res = strict_strtoul(buf, 0, &input);
-	if (res >= 0 && input > 0 && input < 100)
+	if (res < 0)
+		return -EINVAL;
+	if (input > 0 && input < 100)
 		min_cpu_load = input;
-	return res;
+	return count;
+}
+
+static ssize_t show_boost_enabled(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", boost_enabled);
+}
+
+static ssize_t store_boost_enabled(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res < 0)
+		return -EINVAL;
+	boost_enabled = (input == 0 ? 0 : 1);
+	return count;
+}
+
+static ssize_t show_boost_pulse(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", boost_pulse);
+}
+
+static ssize_t store_boost_pulse(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res < 0)
+		return -EINVAL;
+	boost_pulse_time = ktime_to_us(ktime_get());
+	if (input > MAX_BOOST_PULSE)
+		boost_pulse = MAX_BOOST_PULSE;
+	else if (input <= 1)
+		boost_pulse = DEFAULT_BOOST_PULSE;
+	else
+		boost_pulse = input;
+	dprintk(SMARTASS_DEBUG_ALG,"Smartass: boost input=%lu pulse=%lu\n", input, boost_pulse);
+	return count;
 }
 
 #define define_global_rw_attr(_name)		\
 static struct global_attr _name##_attr =	\
-	__ATTR(_name, 0644, show_##_name, store_##_name)
+	__ATTR(_name, 0666, show_##_name, store_##_name)
 
 define_global_rw_attr(debug_mask);
 define_global_rw_attr(up_rate_us);
@@ -641,6 +738,8 @@ define_global_rw_attr(ramp_up_step);
 define_global_rw_attr(ramp_down_step);
 define_global_rw_attr(max_cpu_load);
 define_global_rw_attr(min_cpu_load);
+define_global_rw_attr(boost_enabled);
+define_global_rw_attr(boost_pulse);
 
 static struct attribute * smartass_attributes[] = {
 	&debug_mask_attr.attr,
@@ -654,6 +753,8 @@ static struct attribute * smartass_attributes[] = {
 	&ramp_down_step_attr.attr,
 	&max_cpu_load_attr.attr,
 	&min_cpu_load_attr.attr,
+	&boost_enabled_attr.attr,
+	&boost_pulse_attr.attr,
 	NULL,
 };
 
@@ -812,6 +913,8 @@ static int __init cpufreq_smartass_init(void)
 	ramp_down_step = DEFAULT_RAMP_DOWN_STEP;
 	max_cpu_load = DEFAULT_MAX_CPU_LOAD;
 	min_cpu_load = DEFAULT_MIN_CPU_LOAD;
+	boost_enabled = DEFAULT_BOOST_ENABLED;
+	boost_pulse = 0;
 
 	spin_lock_init(&cpumask_lock);
 
