diff --git a/Android.mk b/Android.mk
index 14ff6ac..f3bb599 100644
--- a/Android.mk
+++ b/Android.mk
@@ -38,6 +38,9 @@ LOCAL_SRC_FILES += \
     twrp-functions.cpp \
     openrecoveryscript.cpp
 
+LOCAL_SRC_FILES += \
+   libcrecovery/system.c
+
 ifneq ($(TARGET_RECOVERY_REBOOT_SRC),)
   LOCAL_SRC_FILES += $(TARGET_RECOVERY_REBOOT_SRC)
 endif
diff --git a/common.h b/common.h
index 7bd769a..9a77a4d 100644
--- a/common.h
+++ b/common.h
@@ -23,6 +23,8 @@
 extern "C" {
 #endif
 
+int __system(const char *command);
+
 static long tmplog_offset = 0;
 
 #define ui_print(...) gui_print(__VA_ARGS__)
diff --git a/crypto/jb/cryptfs.c b/crypto/jb/cryptfs.c
index 456d49f..12c1c0e 100644
--- a/crypto/jb/cryptfs.c
+++ b/crypto/jb/cryptfs.c
@@ -46,6 +46,7 @@
 #include "cutils/properties.h"
 #include "hardware_legacy/power.h"
 //#include "VolumeManager.h"
+#include "../../common.h"
 
 #define DM_CRYPT_BUF_SIZE 4096
 #define DATA_MNT_POINT "/data"
@@ -998,7 +999,7 @@ static int cryptfs_enable_wipe(char *crypto_blkdev, off64_t size, int type)
         return -1;
     }
 
-    if (system(cmdline)) {
+    if (__system(cmdline)) {
       SLOGE("Error creating empty filesystem on %s\n", crypto_blkdev);
     } else {
       SLOGD("Successfully created empty filesystem on %s\n", crypto_blkdev);
diff --git a/data.cpp b/data.cpp
index e7dafa1..ac6d801 100644
--- a/data.cpp
+++ b/data.cpp
@@ -843,7 +843,7 @@ void DataManager::Output_Version(void) {
 	Path += "/TWRP/.version";
 	if (TWFunc::Path_Exists(Path)) {
 		Command = "rm -f " + Path;
-		system(Command.c_str());
+		__system(Command.c_str());
 	}
 	FILE *fp = fopen(Path.c_str(), "w");
 	if (fp == NULL) {
diff --git a/gui/Android.mk b/gui/Android.mk
index 58d9c4b..6bb3a7f 100644
--- a/gui/Android.mk
+++ b/gui/Android.mk
@@ -21,6 +21,9 @@ LOCAL_SRC_FILES := \
     keyboard.cpp \
     input.cpp
 
+LOCAL_SRC_FILES += \
+    ../libcrecovery/system.c
+
 ifneq ($(TWRP_CUSTOM_KEYBOARD),)
   LOCAL_SRC_FILES += $(TWRP_CUSTOM_KEYBOARD)
 else
diff --git a/gui/action.cpp b/gui/action.cpp
index dd38b31..97c78e1 100644
--- a/gui/action.cpp
+++ b/gui/action.cpp
@@ -213,7 +213,7 @@ int GUIAction::flash_zip(std::string filename, std::string pageName, const int s
 			DataManager::SetValue("tw_operation", "Configuring TWRP");
 			DataManager::SetValue("tw_partition", "");
 			ui_print("Configuring TWRP...\n");
-			if (system("/sbin/installTwrp reinstall") < 0)
+			if (__system("/sbin/installTwrp reinstall") < 0)
 			{
 				ui_print("Unable to configure TWRP with this kernel.\n");
 			}
@@ -466,7 +466,7 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 
 			PartitionManager.Mount_Current_Storage(true);
 			sprintf(command, "cp /tmp/recovery.log %s", DataManager::GetCurrentStoragePath().c_str());
-			system(command);
+			__system(command);
 			sync();
 			ui_print("Copied recovery log to %s.\n", DataManager::GetCurrentStoragePath().c_str());
 		} else
@@ -672,10 +672,10 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 				} else {
 					TWPartition* Boot = PartitionManager.Find_Partition_By_Path("/boot");
 					if (Boot == NULL || Boot->Current_File_System != "emmc")
-						system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
+						__system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
 					else {
 						string injectcmd = "injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash bd=" + Boot->Actual_Block_Device;
-						system(injectcmd.c_str());
+						__system(injectcmd.c_str());
 					}
 					ui_print("TWRP injection complete.\n");
 				}
@@ -812,7 +812,7 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 			} else {
 				char cmd[512];
 				sprintf(cmd, "dd %s", arg.c_str());
-				system(cmd);
+				__system(cmd);
 			}
             operation_end(0, simulate);
             return 0;
@@ -879,7 +879,7 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 			if (simulate) {
 				simulate_progress_bar();
 			} else {
-				op_status = system(arg.c_str());
+				op_status = __system(arg.c_str());
 				if (op_status != 0)
 					op_status = 1;
 			}
@@ -936,7 +936,7 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 			if (simulate) {
 				simulate_progress_bar();
 			} else {
-				system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
+				__system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
 				ui_print("TWRP injection complete.\n");
 			}
 
@@ -1040,7 +1040,7 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 				Sideload_File = DataManager::GetCurrentStoragePath() + "/sideload.zip";
 				if (TWFunc::Path_Exists(Sideload_File)) {
 					Command = "rm " + Sideload_File;
-					system(Command.c_str());
+					__system(Command.c_str());
 				}
 				ui_print("Starting ADB sideload feature...\n");
 				ret = apply_from_adb(ui, &wipe_cache, Sideload_File.c_str());
@@ -1056,10 +1056,10 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 					} else {
 						TWPartition* Boot = PartitionManager.Find_Partition_By_Path("/boot");
 						if (Boot == NULL || Boot->Current_File_System != "emmc")
-							system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
+							__system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
 						else {
 							string injectcmd = "injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash bd=" + Boot->Actual_Block_Device;
-							system(injectcmd.c_str());
+							__system(injectcmd.c_str());
 						}
 						ui_print("TWRP injection complete.\n");
 					}
@@ -1074,7 +1074,7 @@ int GUIAction::doAction(Action action, int isThreaded /* = 0 */)
 			string Command, Sideload_File;
 			Sideload_File = DataManager::GetCurrentStoragePath() + "/sideload.zip";
 			Command = "rm " + Sideload_File;
-			system(Command.c_str());
+			__system(Command.c_str());
 			DataManager::GetValue("tw_child_pid", child_pid);
 			ui_print("Cancelling ADB sideload...\n");
 			kill(child_pid, SIGTERM);
diff --git a/makelist.cpp b/makelist.cpp
index 7b3b3eb..93a8de7 100644
--- a/makelist.cpp
+++ b/makelist.cpp
@@ -122,8 +122,8 @@ int MakeList::Make_File_List(string Path)
 {
 	Makelist_File_Count = 0;
 	Makelist_Current_Size = 0;
-	system("cd /tmp && rm -rf list");
-	system("cd /tmp && mkdir list");
+	__system("cd /tmp && rm -rf list");
+	__system("cd /tmp && mkdir list");
 	if (Generate_File_Lists(Path) < 0) {
 		LOGE("Error generating file list\n");
 		return -1;
diff --git a/minadbd/Android.mk b/minadbd/Android.mk
index 5a4de68..c7ae912 100644
--- a/minadbd/Android.mk
+++ b/minadbd/Android.mk
@@ -15,6 +15,7 @@ LOCAL_SRC_FILES := \
 	fdevent.c \
 	transport.c \
 	transport_usb.c \
+	transport_local.c \
 	sockets.c \
 	services.c \
 	usb_linux_client.c \
diff --git a/openrecoveryscript.cpp b/openrecoveryscript.cpp
index 47bf5d6..e727868 100644
--- a/openrecoveryscript.cpp
+++ b/openrecoveryscript.cpp
@@ -60,11 +60,11 @@ int OpenRecoveryScript::check_for_script_file(void) {
 		strcat(exec, SCRIPT_FILE_CACHE);
 		strcat(exec, " ");
 		strcat(exec, SCRIPT_FILE_TMP);
-		system(exec);
+		__system(exec);
 		// Delete the file from /cache
 		strcpy(exec, "rm ");
 		strcat(exec, SCRIPT_FILE_CACHE);
-		system(exec);
+		__system(exec);
 		return 1;
 	}
 	return 0;
@@ -329,7 +329,7 @@ int OpenRecoveryScript::run_script_file(void) {
 				// Reboot
 			} else if (strcmp(command, "cmd") == 0) {
 				if (cindex != 0) {
-					system(value);
+					__system(value);
 				} else {
 					LOGE("No value given for cmd\n");
 				}
@@ -350,10 +350,10 @@ int OpenRecoveryScript::run_script_file(void) {
 		ui_print("Injecting TWRP into boot image...\n");
 		TWPartition* Boot = PartitionManager.Find_Partition_By_Path("/boot");
 		if (Boot == NULL || Boot->Current_File_System != "emmc")
-			system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
+			__system("injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash");
 		else {
 			string injectcmd = "injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash bd=" + Boot->Actual_Block_Device;
-			system(injectcmd.c_str());
+			__system(injectcmd.c_str());
 		}
 		ui_print("TWRP injection complete.\n");
 	}
diff --git a/partition.cpp b/partition.cpp
index f5173b1..0f9508b 100644
--- a/partition.cpp
+++ b/partition.cpp
@@ -242,7 +242,7 @@ bool TWPartition::Process_Fstab_Line(string Line, bool Display_Error) {
 			if (Mount(false) && !TWFunc::Path_Exists("/cache/recovery/.")) {
 				string Recreate_Command = "cd /cache && mkdir recovery";
 				LOGI("Recreating /cache/recovery folder.\n");
-				system(Recreate_Command.c_str());
+				__system(Recreate_Command.c_str());
 			}
 		} else if (Mount_Point == "/datadata") {
 			Wipe_During_Factory_Reset = true;
@@ -559,7 +559,7 @@ bool TWPartition::Get_Size_Via_df(bool Display_Error) {
 
 	min_len = Actual_Block_Device.size() + 2;
 	sprintf(command, "df %s > /tmp/dfoutput.txt", Mount_Point.c_str());
-	system(command);
+	__system(command);
 	fp = fopen("/tmp/dfoutput.txt", "rt");
 	if (fp == NULL) {
 		LOGI("Unable to open /tmp/dfoutput.txt.\n");
@@ -697,7 +697,7 @@ bool TWPartition::Mount(bool Display_Error) {
 			string Command;
 
 			Command = "mount " + Symlink_Path + " " + Symlink_Mount_Point;
-			system(Command.c_str());
+			__system(Command.c_str());
 		}
 		return true;
 	}
@@ -795,7 +795,7 @@ bool TWPartition::Wipe_AndSec(void) {
 	sprintf(cmd, "rm -rf %s/.android_secure/* && rm -rf %s/.android_secure/.*", Mount_Point.c_str(), Mount_Point.c_str());
 
 	LOGI("rm -rf command is: '%s'\n", cmd);
-	system(cmd);
+	__system(cmd);
     return true;
 }
 
@@ -932,10 +932,10 @@ void TWPartition::Check_FS_Type() {
 		return;
 
 	if (TWFunc::Path_Exists("/tmp/blkidoutput.txt"))
-		system("rm /tmp/blkidoutput.txt");
+		__system("rm /tmp/blkidoutput.txt");
 
 	blkCommand = "blkid " + Actual_Block_Device + " > /tmp/blkidoutput.txt";
-	system(blkCommand.c_str());
+	__system(blkCommand.c_str());
 	fp = fopen("/tmp/blkidoutput.txt", "rt");
 	if (fp == NULL)
 		return;
@@ -1002,7 +1002,7 @@ bool TWPartition::Wipe_EXT23(string File_System) {
 		Find_Actual_Block_Device();
 		sprintf(command, "mke2fs -t %s -m 0 %s", File_System.c_str(), Actual_Block_Device.c_str());
 		LOGI("mke2fs command: %s\n", command);
-		if (system(command) == 0) {
+		if (__system(command) == 0) {
 			Current_File_System = File_System;
 			Recreate_AndSec_Folder();
 			ui_print("Done.\n");
@@ -1036,7 +1036,7 @@ bool TWPartition::Wipe_EXT4() {
 		}
 		Command += " " + Actual_Block_Device;
 		LOGI("make_ext4fs command: %s\n", Command.c_str());
-		if (system(Command.c_str()) == 0) {
+		if (__system(Command.c_str()) == 0) {
 			Current_File_System = "ext4";
 			Recreate_AndSec_Folder();
 			ui_print("Done.\n");
@@ -1061,7 +1061,7 @@ bool TWPartition::Wipe_FAT() {
 		ui_print("Formatting %s using mkdosfs...\n", Display_Name.c_str());
 		Find_Actual_Block_Device();
 		sprintf(command,"mkdosfs %s", Actual_Block_Device.c_str()); // use mkdosfs to format it
-		if (system(command) == 0) {
+		if (__system(command) == 0) {
 			Current_File_System = "vfat";
 			Recreate_AndSec_Folder();
 			ui_print("Done.\n");
@@ -1121,7 +1121,7 @@ bool TWPartition::Wipe_RMRF() {
 	sprintf(cmd, "rm -rf %s/* && rm -rf %s/.*", Mount_Point.c_str(), Mount_Point.c_str());
 
 	LOGI("rm -rf command is: '%s'\n", cmd);
-	system(cmd);
+	__system(cmd);
 	Recreate_AndSec_Folder();
     return true;
 }
@@ -1147,7 +1147,7 @@ bool TWPartition::Wipe_Data_Without_Wiping_Media() {
 			if (strcmp(de->d_name, "media") == 0 || strcmp(de->d_name, ".layout_version") == 0)   continue;
 
 			sprintf(cmd, "rm -fr /data/%s", de->d_name);
-			system(cmd);
+			__system(cmd);
 		}
 		closedir(d);
 		ui_print("Done.\n");
@@ -1199,7 +1199,7 @@ bool TWPartition::Backup_Tar(string backup_folder) {
 			Command = "tar " + Tar_Args + " -f '" + Full_FileName + "' -T /tmp/list/filelist" + split_index;
 			LOGI("Backup command: '%s'\n", Command.c_str());
 			ui_print("Backup archive %i of %i...\n", (index + 1), backup_count);
-			system(Command.c_str()); // sending backup command formed earlier above
+			__system(Command.c_str()); // sending backup command formed earlier above
 
 			file_size = TWFunc::Get_File_Size(Full_FileName);
 			if (file_size == 0) {
@@ -1209,7 +1209,7 @@ bool TWPartition::Backup_Tar(string backup_folder) {
 			total_bsize += file_size;
 		}
 		ui_print(" * Total size: %llu bytes.\n", total_bsize);
-		system("cd /tmp && rm -rf list");
+		__system("cd /tmp && rm -rf list");
 	} else {
 		Full_FileName = backup_folder + "/" + Backup_FileName;
 		if (Has_Data_Media)
@@ -1217,7 +1217,7 @@ bool TWPartition::Backup_Tar(string backup_folder) {
 		else
 			Command = "cd " + Backup_Path + " && tar " + Tar_Args + " -f '" + Full_FileName + "' ./*";
 		LOGI("Backup command: '%s'\n", Command.c_str());
-		system(Command.c_str());
+		__system(Command.c_str());
 		if (TWFunc::Get_File_Size(Full_FileName) == 0) {
 			LOGE("Backup file size for '%s' is 0 bytes.\n", Full_FileName.c_str());
 			return false;
@@ -1241,7 +1241,7 @@ bool TWPartition::Backup_DD(string backup_folder) {
 
 	Command = "dd if=" + Actual_Block_Device + " of='" + Full_FileName + "'";
 	LOGI("Backup command: '%s'\n", Command.c_str());
-	system(Command.c_str());
+	__system(Command.c_str());
 	if (TWFunc::Get_File_Size(Full_FileName) == 0) {
 		LOGE("Backup file size for '%s' is 0 bytes.\n", Full_FileName.c_str());
 		return false;
@@ -1264,7 +1264,7 @@ bool TWPartition::Backup_Dump_Image(string backup_folder) {
 
 	Command = "dump_image " + MTD_Name + " '" + Full_FileName + "'";
 	LOGI("Backup command: '%s'\n", Command.c_str());
-	system(Command.c_str());
+	__system(Command.c_str());
 	if (TWFunc::Get_File_Size(Full_FileName) == 0) {
 		// Actual size may not match backup size due to bad blocks on MTD devices so just check for 0 bytes
 		LOGE("Backup file size for '%s' is 0 bytes.\n", Full_FileName.c_str());
@@ -1303,7 +1303,7 @@ bool TWPartition::Restore_Tar(string restore_folder, string Restore_File_System)
 			ui_print("Restoring archive %i...\n", index + 1);
 			Command = "tar -xf '" + Full_FileName + "'";
 			LOGI("Restore command: '%s'\n", Command.c_str());
-			system(Command.c_str());
+			__system(Command.c_str());
 			index++;
 			sprintf(split_index, "%03i", index);
 			Full_FileName = restore_folder + "/" + Backup_FileName + split_index;
@@ -1315,7 +1315,7 @@ bool TWPartition::Restore_Tar(string restore_folder, string Restore_File_System)
 	} else {
 		Command = "cd " + Backup_Path + " && tar -xf '" + Full_FileName + "'";
 		LOGI("Restore command: '%s'\n", Command.c_str());
-		system(Command.c_str());
+		__system(Command.c_str());
 	}
 	return true;
 }
@@ -1341,7 +1341,7 @@ bool TWPartition::Restore_DD(string restore_folder) {
 	ui_print("Restoring %s...\n", Display_Name.c_str());
 	Command = "dd bs=4096 if='" + Full_FileName + "' of=" + Actual_Block_Device;
 	LOGI("Restore command: '%s'\n", Command.c_str());
-	system(Command.c_str());
+	__system(Command.c_str());
 	return true;
 }
 
@@ -1353,10 +1353,10 @@ bool TWPartition::Restore_Flash_Image(string restore_folder) {
 	// Sometimes flash image doesn't like to flash due to the first 2KB matching, so we erase first to ensure that it flashes
 	Command = "erase_image " + MTD_Name;
 	LOGI("Erase command: '%s'\n", Command.c_str());
-	system(Command.c_str());
+	__system(Command.c_str());
 	Command = "flash_image " + MTD_Name + " '" + Full_FileName + "'";
 	LOGI("Restore command: '%s'\n", Command.c_str());
-	system(Command.c_str());
+	__system(Command.c_str());
 	return true;
 }
 
@@ -1436,11 +1436,11 @@ void TWPartition::Recreate_Media_Folder(void) {
 		LOGE("Unable to recreate /data/media folder.\n");
 	} else if (!TWFunc::Path_Exists("/data/media")) {
 		LOGI("Recreating /data/media folder.\n");
-		system("cd /data && mkdir media && chmod 755 media");
+		__system("cd /data && mkdir media && chmod 755 media");
 		Command = "umount " + Symlink_Mount_Point;
-		system(Command.c_str());
+		__system(Command.c_str());
 		Command = "mount " + Symlink_Path + " " + Symlink_Mount_Point;
-		system(Command.c_str());
+		__system(Command.c_str());
 	}
 }
 
@@ -1455,10 +1455,10 @@ void TWPartition::Recreate_AndSec_Folder(void) {
 	} else if (!TWFunc::Path_Exists(Symlink_Path)) {
 		LOGI("Recreating android secure folder.\n");
 		Command = "umount " + Symlink_Mount_Point;
-		system(Command.c_str());
+		__system(Command.c_str());
 		Command = "cd " + Mount_Point + " && mkdir .android_secure";
-		system(Command.c_str());
+		__system(Command.c_str());
 		Command = "mount " + Symlink_Path + " " + Symlink_Mount_Point;
-		system(Command.c_str());
+		__system(Command.c_str());
 	}
 }
diff --git a/partitionmanager.cpp b/partitionmanager.cpp
index 2614383..bc5c745 100644
--- a/partitionmanager.cpp
+++ b/partitionmanager.cpp
@@ -482,7 +482,7 @@ bool TWPartitionManager::Make_MD5(bool generate_md5, string Backup_Folder, strin
 
 	if (TWFunc::Path_Exists(Full_File)) {
 		sprintf(command, "cd '%s' && md5sum %s > %s.md5",Backup_Folder.c_str(), Backup_Filename.c_str(), Backup_Filename.c_str());
-		if (system(command) == 0) {
+		if (__system(command) == 0) {
 			ui_print(" * MD5 Created.\n");
 			return true;
 		} else {
@@ -496,7 +496,7 @@ bool TWPartitionManager::Make_MD5(bool generate_md5, string Backup_Folder, strin
 		sprintf(filename, "%s%03i", Full_File.c_str(), index);
 		while (TWFunc::Path_Exists(filename) == true) {
 			sprintf(command, "cd '%s' && md5sum %s%03i > %s%03i.md5",Backup_Folder.c_str(), Backup_Filename.c_str(), index, Backup_Filename.c_str(), index);
-			if (system(command) != 0) {
+			if (__system(command) != 0) {
 				ui_print(" * MD5 Error.\n");
 				return false;
 			}
@@ -1295,18 +1295,18 @@ int TWPartitionManager::Wipe_Dalvik_Cache(void) {
 		return false;
 
 	ui_print("\nWiping Dalvik Cache Directories...\n");
-	system("rm -rf /data/dalvik-cache");
+	__system("rm -rf /data/dalvik-cache");
 	ui_print("Cleaned: /data/dalvik-cache...\n");
-	system("rm -rf /cache/dalvik-cache");
+	__system("rm -rf /cache/dalvik-cache");
 	ui_print("Cleaned: /cache/dalvik-cache...\n");
-	system("rm -rf /cache/dc");
+	__system("rm -rf /cache/dc");
 	ui_print("Cleaned: /cache/dc\n");
 
 	TWPartition* sdext = Find_Partition_By_Path("/sd-ext");
 	if (sdext != NULL) {
 		if (sdext->Is_Present && sdext->Mount(false)) {
 			if (stat("/sd-ext/dalvik-cache", &st) == 0) {
-                system("rm -rf /sd-ext/dalvik-cache");
+                __system("rm -rf /sd-ext/dalvik-cache");
         	    ui_print("Cleaned: /sd-ext/dalvik-cache...\n");
     	    }
         }
@@ -1319,9 +1319,9 @@ int TWPartitionManager::Wipe_Rotate_Data(void) {
 	if (!Mount_By_Path("/data", true))
 		return false;
 
-	system("rm -r /data/misc/akmd*");
-	system("rm -r /data/misc/rild*");
-	system("rm -r /data/misc/rild*");
+	__system("rm -r /data/misc/akmd*");
+	__system("rm -r /data/misc/rild*");
+	__system("rm -r /data/misc/rild*");
 	ui_print("Rotation data wiped.\n");
 	return true;
 }
@@ -1388,8 +1388,8 @@ int TWPartitionManager::Wipe_Media_From_Data(void) {
 			return false;
 
 		ui_print("Wiping internal storage -- /data/media...\n");
-		system("rm -rf /data/media");
-		system("cd /data && mkdir media && chmod 775 media");
+		__system("rm -rf /data/media");
+		__system("cd /data && mkdir media && chmod 775 media");
 		if (dat->Has_Data_Media) {
 			dat->Recreate_Media_Folder();
 		}
@@ -1506,6 +1506,7 @@ void TWPartitionManager::Update_System_Details(void) {
 #endif
 		}
 	}
+	DataManager::SetValue(TW_BACKUP_BOOT_VAR, 0);
 	DataManager::SetValue(TW_BACKUP_DATA_SIZE, data_size);
 	string current_storage_path = DataManager::GetCurrentStoragePath();
 	TWPartition* FreeStorage = Find_Partition_By_Path(current_storage_path);
@@ -1831,7 +1832,7 @@ int TWPartitionManager::Partition_SDCard(void) {
 		if (!SDext->UnMount(true))
 			return false;
 	}
-	system("umount \"$SWAPPATH\"");
+	__system("umount \"$SWAPPATH\"");
 	Device = SDCard->Actual_Block_Device;
 	// Just use the root block device
 	Device.resize(strlen("/dev/block/mmcblkX"));
@@ -1883,7 +1884,7 @@ int TWPartitionManager::Partition_SDCard(void) {
 	ui_print("Removing partition table...\n");
 	Command = "parted -s " + Device + " mklabel msdos";
 	LOGI("Command is: '%s'\n", Command.c_str());
-	if (system(Command.c_str()) != 0) {
+	if (__system(Command.c_str()) != 0) {
 		LOGE("Unable to remove partition table.\n");
 		Update_System_Details();
 		return false;
@@ -1891,7 +1892,7 @@ int TWPartitionManager::Partition_SDCard(void) {
 	ui_print("Creating FAT32 partition...\n");
 	Command = "parted " + Device + " mkpartfs primary fat32 0 " + fat_str + "MB";
 	LOGI("Command is: '%s'\n", Command.c_str());
-	if (system(Command.c_str()) != 0) {
+	if (__system(Command.c_str()) != 0) {
 		LOGE("Unable to create FAT32 partition.\n");
 		return false;
 	}
@@ -1899,7 +1900,7 @@ int TWPartitionManager::Partition_SDCard(void) {
 		ui_print("Creating EXT partition...\n");
 		Command = "parted " + Device + " mkpartfs primary ext2 " + fat_str + "MB " + ext_str + "MB";
 		LOGI("Command is: '%s'\n", Command.c_str());
-		if (system(Command.c_str()) != 0) {
+		if (__system(Command.c_str()) != 0) {
 			LOGE("Unable to create EXT partition.\n");
 			Update_System_Details();
 			return false;
@@ -1909,7 +1910,7 @@ int TWPartitionManager::Partition_SDCard(void) {
 		ui_print("Creating swap partition...\n");
 		Command = "parted " + Device + " mkpartfs primary linux-swap " + ext_str + "MB " + swap_str + "MB";
 		LOGI("Command is: '%s'\n", Command.c_str());
-		if (system(Command.c_str()) != 0) {
+		if (__system(Command.c_str()) != 0) {
 			LOGE("Unable to create swap partition.\n");
 			Update_System_Details();
 			return false;
@@ -1944,7 +1945,7 @@ int TWPartitionManager::Partition_SDCard(void) {
 		Command = "mke2fs -t " + ext_format + " -m 0 " + SDext->Actual_Block_Device;
 		ui_print("Formatting sd-ext as %s...\n", ext_format.c_str());
 		LOGI("Formatting sd-ext after partitioning, command: '%s'\n", Command.c_str());
-		system(Command.c_str());
+		__system(Command.c_str());
 	}
 
 	Update_System_Details();
diff --git a/pigz/yarn.c b/pigz/yarn.c
index 5e557f3..8ba2a9c 100644
--- a/pigz/yarn.c
+++ b/pigz/yarn.c
@@ -369,7 +369,7 @@ void destruct(thread *off_course)
 {
     int ret;
 
-    if ((ret = pthread_cancel(off_course->id)) != 0)
+    if ((ret = pthread_kill(off_course->id, SIGUSR2)) != 0)
         fail(ret);
     join(off_course);
 }
diff --git a/prebuilt/Android.mk b/prebuilt/Android.mk
index e260598..902d9ea 100644
--- a/prebuilt/Android.mk
+++ b/prebuilt/Android.mk
@@ -85,6 +85,15 @@ LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin
 LOCAL_SRC_FILES := $(LOCAL_MODULE)
 include $(BUILD_PREBUILT)
 
+#rebootrecovery
+include $(CLEAR_VARS)
+LOCAL_MODULE := rebootrecovery.sh
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_CLASS := RECOVERY_EXECUTABLES
+LOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
+
 #mke2fs.conf
 include $(CLEAR_VARS)
 LOCAL_MODULE := mke2fs.conf
diff --git a/recovery.cpp b/recovery.cpp
index b1333ea..8faa9d1 100644
--- a/recovery.cpp
+++ b/recovery.cpp
@@ -811,7 +811,7 @@ main(int argc, char **argv) {
 	printf("Starting the UI...");
 	gui_init();
 	printf("=> Linking mtab\n");
-	system("ln -s /proc/mounts /etc/mtab"); // Link mtab for mke2fs
+	__system("ln -s /proc/mounts /etc/mtab"); // Link mtab for mke2fs
 	printf("=> Processing recovery.fstab\n");
 	if (!PartitionManager.Process_Fstab("/etc/recovery.fstab", 1)) {
 		LOGE("Failing out of recovery due to problem with recovery.fstab.\n");
@@ -897,10 +897,10 @@ main(int argc, char **argv) {
 
 	LOGI("Backing up TWRP ramdisk...\n");
 	if (Boot == NULL || Boot->Current_File_System != "emmc")
-		system("injecttwrp --backup /tmp/backup_recovery_ramdisk.img");
+		__system("injecttwrp --backup /tmp/backup_recovery_ramdisk.img");
 	else {
 		string injectcmd = "injecttwrp --backup /tmp/backup_recovery_ramdisk.img bd=" + Boot->Actual_Block_Device;
-		system(injectcmd.c_str());
+		__system(injectcmd.c_str());
 	}
 	LOGI("Backup of TWRP ramdisk done.\n");
 #endif
@@ -954,7 +954,7 @@ main(int argc, char **argv) {
 		finish_recovery(NULL);
 		DataManager_ReadSettingsFile();
 		if (PartitionManager.Mount_By_Path("/system", false) && TWFunc::Path_Exists("/system/recovery-from-boot.p")) {
-			system("mv /system/recovery-from-boot.p /system/recovery-from-boot.bak");
+			__system("mv /system/recovery-from-boot.p /system/recovery-from-boot.bak");
 			ui_print("Renamed stock recovery file in /system to prevent\nthe stock ROM from replacing TWRP.\n");
 		}
 		PartitionManager.UnMount_By_Path("/system", false);
diff --git a/twrp-functions.cpp b/twrp-functions.cpp
index 3a2658e..50b3ce5 100644
--- a/twrp-functions.cpp
+++ b/twrp-functions.cpp
@@ -33,7 +33,7 @@ int TWFunc::Check_MD5(string File) {
 		DirPath = Get_Path(File);
 		MD5_File = Get_Filename(MD5_File);
 		Command = "cd '" + DirPath + "' && /sbin/busybox md5sum -c '" + MD5_File + "' > /tmp/md5output";
-		system(Command.c_str());
+		__system(Command.c_str());
 		FILE * cs = fopen("/tmp/md5output", "r");
 		if (cs == NULL) {
 			LOGE("Unable to open md5 output file.\n");
@@ -116,30 +116,30 @@ void TWFunc::install_htc_dumlock(void) {
 		return;
 
 	ui_print("Installing HTC Dumlock to system...\n");
-	system("cp /res/htcd/htcdumlocksys /system/bin/htcdumlock && chmod 755 /system/bin/htcdumlock");
+	__system("cp /res/htcd/htcdumlocksys /system/bin/htcdumlock && chmod 755 /system/bin/htcdumlock");
 	if (!Path_Exists("/system/bin/flash_image")) {
 		ui_print("Installing flash_image...\n");
-		system("cp /res/htcd/flash_imagesys /system/bin/flash_image && chmod 755 /system/bin/flash_image");
+		__system("cp /res/htcd/flash_imagesys /system/bin/flash_image && chmod 755 /system/bin/flash_image");
 		need_libs = 1;
 	} else
 		ui_print("flash_image is already installed, skipping...\n");
 	if (!Path_Exists("/system/bin/dump_image")) {
 		ui_print("Installing dump_image...\n");
-		system("cp /res/htcd/dump_imagesys /system/bin/dump_image && chmod 755 /system/bin/dump_image");
+		__system("cp /res/htcd/dump_imagesys /system/bin/dump_image && chmod 755 /system/bin/dump_image");
 		need_libs = 1;
 	} else
 		ui_print("dump_image is already installed, skipping...\n");
 	if (need_libs) {
 		ui_print("Installing libs needed for flash_image and dump_image...\n");
-		system("cp /res/htcd/libbmlutils.so /system/lib && chmod 755 /system/lib/libbmlutils.so");
-		system("cp /res/htcd/libflashutils.so /system/lib && chmod 755 /system/lib/libflashutils.so");
-		system("cp /res/htcd/libmmcutils.so /system/lib && chmod 755 /system/lib/libmmcutils.so");
-		system("cp /res/htcd/libmtdutils.so /system/lib && chmod 755 /system/lib/libmtdutils.so");
+		__system("cp /res/htcd/libbmlutils.so /system/lib && chmod 755 /system/lib/libbmlutils.so");
+		__system("cp /res/htcd/libflashutils.so /system/lib && chmod 755 /system/lib/libflashutils.so");
+		__system("cp /res/htcd/libmmcutils.so /system/lib && chmod 755 /system/lib/libmmcutils.so");
+		__system("cp /res/htcd/libmtdutils.so /system/lib && chmod 755 /system/lib/libmtdutils.so");
 	}
 	ui_print("Installing HTC Dumlock app...\n");
 	mkdir("/data/app", 0777);
-	system("rm /data/app/com.teamwin.htcdumlock*");
-	system("cp /res/htcd/HTCDumlock.apk /data/app/com.teamwin.htcdumlock.apk");
+	__system("rm /data/app/com.teamwin.htcdumlock*");
+	__system("cp /res/htcd/HTCDumlock.apk /data/app/com.teamwin.htcdumlock.apk");
 	sync();
 	ui_print("HTC Dumlock is installed.\n");
 }
@@ -149,7 +149,7 @@ void TWFunc::htc_dumlock_restore_original_boot(void) {
 		return;
 
 	ui_print("Restoring original boot...\n");
-	system("htcdumlock restore");
+	__system("htcdumlock restore");
 	ui_print("Original boot restored.\n");
 }
 
@@ -158,7 +158,7 @@ void TWFunc::htc_dumlock_reflash_recovery_to_boot(void) {
 		return;
 
 	ui_print("Reflashing recovery to boot...\n");
-	system("htcdumlock recovery noreboot");
+	__system("htcdumlock recovery noreboot");
 	ui_print("Recovery is flashed to boot.\n");
 }
 
@@ -331,12 +331,12 @@ void TWFunc::twfinish_recovery(const char *send_intent) {
     set_bootloader_message(&boot);
 
     // Remove the command file, so recovery won't repeat indefinitely.
-    if (system("mount /cache") != 0 ||
+    if (__system("mount /cache") != 0 ||
         (unlink(COMMAND_FILE) && errno != ENOENT)) {
         LOGW("Can't unlink %s\n", COMMAND_FILE);
     }
 
-    system("umount /cache");
+    __system("umount /cache");
     sync();  // For good measure.
 }
 
@@ -382,8 +382,8 @@ void TWFunc::check_and_run_script(const char* script_file, const char* display_n
 		char command[255];
 		strcpy(command, "chmod 755 ");
 		strcat(command, script_file);
-		system(command);
-		system(script_file);
+		__system(command);
+		__system(script_file);
 		ui_print("\nFinished running %s script.\n", display_name);
 	}
 }
diff --git a/minadbd/transport_local.c b/minadbd/transport_local.c
new file mode 100644
index 0000000..105c502
--- /dev/null
+++ b/minadbd/transport_local.c
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include "sysdeps.h"
+#include <sys/types.h>
+
+#define  TRACE_TAG  TRACE_TRANSPORT
+#include "adb.h"
+
+#ifdef HAVE_BIG_ENDIAN
+#define H4(x)	(((x) & 0xFF000000) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | (((x) & 0x000000FF) << 24)
+static inline void fix_endians(apacket *p)
+{
+    p->msg.command     = H4(p->msg.command);
+    p->msg.arg0        = H4(p->msg.arg0);
+    p->msg.arg1        = H4(p->msg.arg1);
+    p->msg.data_length = H4(p->msg.data_length);
+    p->msg.data_check  = H4(p->msg.data_check);
+    p->msg.magic       = H4(p->msg.magic);
+}
+#else
+#define fix_endians(p) do {} while (0)
+#endif
+
+#if ADB_HOST
+/* we keep a list of opened transports. The atransport struct knows to which
+ * local transport it is connected. The list is used to detect when we're
+ * trying to connect twice to a given local transport.
+ */
+#define  ADB_LOCAL_TRANSPORT_MAX  16
+
+ADB_MUTEX_DEFINE( local_transports_lock );
+
+static atransport*  local_transports[ ADB_LOCAL_TRANSPORT_MAX ];
+#endif /* ADB_HOST */
+
+static int remote_read(apacket *p, atransport *t)
+{
+    if(readx(t->sfd, &p->msg, sizeof(amessage))){
+        D("remote local: read terminated (message)\n");
+        return -1;
+    }
+
+    fix_endians(p);
+
+#if 0 && defined HAVE_BIG_ENDIAN
+    D("read remote packet: %04x arg0=%0x arg1=%0x data_length=%0x data_check=%0x magic=%0x\n",
+      p->msg.command, p->msg.arg0, p->msg.arg1, p->msg.data_length, p->msg.data_check, p->msg.magic);
+#endif
+    if(check_header(p)) {
+        D("bad header: terminated (data)\n");
+        return -1;
+    }
+
+    if(readx(t->sfd, p->data, p->msg.data_length)){
+        D("remote local: terminated (data)\n");
+        return -1;
+    }
+
+    if(check_data(p)) {
+        D("bad data: terminated (data)\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int remote_write(apacket *p, atransport *t)
+{
+    int   length = p->msg.data_length;
+
+    fix_endians(p);
+
+#if 0 && defined HAVE_BIG_ENDIAN
+    D("write remote packet: %04x arg0=%0x arg1=%0x data_length=%0x data_check=%0x magic=%0x\n",
+      p->msg.command, p->msg.arg0, p->msg.arg1, p->msg.data_length, p->msg.data_check, p->msg.magic);
+#endif
+    if(writex(t->sfd, &p->msg, sizeof(amessage) + length)) {
+        D("remote local: write terminated\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+
+int local_connect(int port) {
+    return local_connect_arbitrary_ports(port-1, port);
+}
+
+int local_connect_arbitrary_ports(int console_port, int adb_port)
+{
+    char buf[64];
+    int  fd = -1;
+
+#if ADB_HOST
+    const char *host = getenv("ADBHOST");
+    if (host) {
+        fd = socket_network_client(host, adb_port, SOCK_STREAM);
+    }
+#endif
+    if (fd < 0) {
+        fd = socket_loopback_client(adb_port, SOCK_STREAM);
+    }
+
+    if (fd >= 0) {
+        D("client: connected on remote on fd %d\n", fd);
+        close_on_exec(fd);
+        disable_tcp_nagle(fd);
+        snprintf(buf, sizeof buf, "%s%d", LOCAL_CLIENT_PREFIX, console_port);
+        register_socket_transport(fd, buf, adb_port, 1);
+        return 0;
+    }
+    return -1;
+}
+
+
+static void *client_socket_thread(void *x)
+{
+#if ADB_HOST
+    int  port  = DEFAULT_ADB_LOCAL_TRANSPORT_PORT;
+    int  count = ADB_LOCAL_TRANSPORT_MAX;
+
+    D("transport: client_socket_thread() starting\n");
+
+    /* try to connect to any number of running emulator instances     */
+    /* this is only done when ADB starts up. later, each new emulator */
+    /* will send a message to ADB to indicate that is is starting up  */
+    for ( ; count > 0; count--, port += 2 ) {
+        (void) local_connect(port);
+    }
+#endif
+    return 0;
+}
+
+static void *server_socket_thread(void * arg)
+{
+    int serverfd, fd;
+    struct sockaddr addr;
+    socklen_t alen;
+    int port = (int)arg;
+
+    D("transport: server_socket_thread() starting\n");
+    serverfd = -1;
+    for(;;) {
+        if(serverfd == -1) {
+            serverfd = socket_inaddr_any_server(port, SOCK_STREAM);
+            if(serverfd < 0) {
+                D("server: cannot bind socket yet\n");
+                adb_sleep_ms(1000);
+                continue;
+            }
+            close_on_exec(serverfd);
+        }
+
+        alen = sizeof(addr);
+        D("server: trying to get new connection from %d\n", port);
+        fd = adb_socket_accept(serverfd, &addr, &alen);
+        if(fd >= 0) {
+            D("server: new connection on fd %d\n", fd);
+            close_on_exec(fd);
+            disable_tcp_nagle(fd);
+            register_socket_transport(fd, "host", port, 1);
+        }
+    }
+    D("transport: server_socket_thread() exiting\n");
+    return 0;
+}
+
+/* This is relevant only for ADB daemon running inside the emulator. */
+#if !ADB_HOST
+/*
+ * Redefine open and write for qemu_pipe.h that contains inlined references
+ * to those routines. We will redifine them back after qemu_pipe.h inclusion.
+ */
+#undef open
+#undef write
+#define open    adb_open
+#define write   adb_write
+#include <hardware/qemu_pipe.h>
+#undef open
+#undef write
+#define open    ___xxx_open
+#define write   ___xxx_write
+
+/* A worker thread that monitors host connections, and registers a transport for
+ * every new host connection. This thread replaces server_socket_thread on
+ * condition that adbd daemon runs inside the emulator, and emulator uses QEMUD
+ * pipe to communicate with adbd daemon inside the guest. This is done in order
+ * to provide more robust communication channel between ADB host and guest. The
+ * main issue with server_socket_thread approach is that it runs on top of TCP,
+ * and thus is sensitive to network disruptions. For instance, the
+ * ConnectionManager may decide to reset all network connections, in which case
+ * the connection between ADB host and guest will be lost. To make ADB traffic
+ * independent from the network, we use here 'adb' QEMUD service to transfer data
+ * between the host, and the guest. See external/qemu/android/adb-*.* that
+ * implements the emulator's side of the protocol. Another advantage of using
+ * QEMUD approach is that ADB will be up much sooner, since it doesn't depend
+ * anymore on network being set up.
+ * The guest side of the protocol contains the following phases:
+ * - Connect with adb QEMUD service. In this phase a handle to 'adb' QEMUD service
+ *   is opened, and it becomes clear whether or not emulator supports that
+ *   protocol.
+ * - Wait for the ADB host to create connection with the guest. This is done by
+ *   sending an 'accept' request to the adb QEMUD service, and waiting on
+ *   response.
+ * - When new ADB host connection is accepted, the connection with adb QEMUD
+ *   service is registered as the transport, and a 'start' request is sent to the
+ *   adb QEMUD service, indicating that the guest is ready to receive messages.
+ *   Note that the guest will ignore messages sent down from the emulator before
+ *   the transport registration is completed. That's why we need to send the
+ *   'start' request after the transport is registered.
+ */
+static void *qemu_socket_thread(void * arg)
+{
+/* 'accept' request to the adb QEMUD service. */
+static const char _accept_req[] = "accept";
+/* 'start' request to the adb QEMUD service. */
+static const char _start_req[]  = "start";
+/* 'ok' reply from the adb QEMUD service. */
+static const char _ok_resp[]    = "ok";
+
+    const int port = (int)arg;
+    int res, fd;
+    char tmp[256];
+    char con_name[32];
+
+    D("transport: qemu_socket_thread() starting\n");
+
+    /* adb QEMUD service connection request. */
+    snprintf(con_name, sizeof(con_name), "qemud:adb:%d", port);
+
+    /* Connect to the adb QEMUD service. */
+    fd = qemu_pipe_open(con_name);
+    if (fd < 0) {
+        /* This could be an older version of the emulator, that doesn't
+         * implement adb QEMUD service. Fall back to the old TCP way. */
+        adb_thread_t thr;
+        D("adb service is not available. Falling back to TCP socket.\n");
+        adb_thread_create(&thr, server_socket_thread, arg);
+        return 0;
+    }
+
+    for(;;) {
+        /*
+         * Wait till the host creates a new connection.
+         */
+
+        /* Send the 'accept' request. */
+        res = adb_write(fd, _accept_req, strlen(_accept_req));
+        if (res == strlen(_accept_req)) {
+            /* Wait for the response. In the response we expect 'ok' on success,
+             * or 'ko' on failure. */
+            res = adb_read(fd, tmp, sizeof(tmp));
+            if (res != 2 || memcmp(tmp, _ok_resp, 2)) {
+                D("Accepting ADB host connection has failed.\n");
+                adb_close(fd);
+            } else {
+                /* Host is connected. Register the transport, and start the
+                 * exchange. */
+                register_socket_transport(fd, "host", port, 1);
+                adb_write(fd, _start_req, strlen(_start_req));
+            }
+
+            /* Prepare for accepting of the next ADB host connection. */
+            fd = qemu_pipe_open(con_name);
+            if (fd < 0) {
+                D("adb service become unavailable.\n");
+                return 0;
+            }
+        } else {
+            D("Unable to send the '%s' request to ADB service.\n", _accept_req);
+            return 0;
+        }
+    }
+    D("transport: qemu_socket_thread() exiting\n");
+    return 0;
+}
+#endif  // !ADB_HOST
+
+void local_init(int port)
+{
+    adb_thread_t thr;
+    void* (*func)(void *);
+
+    if(HOST) {
+        func = client_socket_thread;
+    } else {
+#if ADB_HOST
+        func = server_socket_thread;
+#else
+        /* For the adbd daemon in the system image we need to distinguish
+         * between the device, and the emulator. */
+        char is_qemu[PROPERTY_VALUE_MAX];
+        property_get("ro.kernel.qemu", is_qemu, "");
+        if (!strcmp(is_qemu, "1")) {
+            /* Running inside the emulator: use QEMUD pipe as the transport. */
+            func = qemu_socket_thread;
+        } else {
+            /* Running inside the device: use TCP socket as the transport. */
+            func = server_socket_thread;
+        }
+#endif // !ADB_HOST
+    }
+
+    D("transport: local %s init\n", HOST ? "client" : "server");
+
+    if(adb_thread_create(&thr, func, (void *)port)) {
+        fatal_errno("cannot create local socket %s thread",
+                    HOST ? "client" : "server");
+    }
+}
+
+static void remote_kick(atransport *t)
+{
+    int fd = t->sfd;
+    t->sfd = -1;
+    adb_shutdown(fd);
+    adb_close(fd);
+
+#if ADB_HOST
+    if(HOST) {
+        int  nn;
+        adb_mutex_lock( &local_transports_lock );
+        for (nn = 0; nn < ADB_LOCAL_TRANSPORT_MAX; nn++) {
+            if (local_transports[nn] == t) {
+                local_transports[nn] = NULL;
+                break;
+            }
+        }
+        adb_mutex_unlock( &local_transports_lock );
+    }
+#endif
+}
+
+static void remote_close(atransport *t)
+{
+    adb_close(t->fd);
+}
+
+
+#if ADB_HOST
+/* Only call this function if you already hold local_transports_lock. */
+atransport* find_emulator_transport_by_adb_port_locked(int adb_port)
+{
+    int i;
+    for (i = 0; i < ADB_LOCAL_TRANSPORT_MAX; i++) {
+        if (local_transports[i] && local_transports[i]->adb_port == adb_port) {
+            return local_transports[i];
+        }
+    }
+    return NULL;
+}
+
+atransport* find_emulator_transport_by_adb_port(int adb_port)
+{
+    adb_mutex_lock( &local_transports_lock );
+    atransport* result = find_emulator_transport_by_adb_port_locked(adb_port);
+    adb_mutex_unlock( &local_transports_lock );
+    return result;
+}
+
+/* Only call this function if you already hold local_transports_lock. */
+int get_available_local_transport_index_locked()
+{
+    int i;
+    for (i = 0; i < ADB_LOCAL_TRANSPORT_MAX; i++) {
+        if (local_transports[i] == NULL) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+int get_available_local_transport_index()
+{
+    adb_mutex_lock( &local_transports_lock );
+    int result = get_available_local_transport_index_locked();
+    adb_mutex_unlock( &local_transports_lock );
+    return result;
+}
+#endif
+
+int init_socket_transport(atransport *t, int s, int adb_port, int local)
+{
+    int  fail = 0;
+
+    t->kick = remote_kick;
+    t->close = remote_close;
+    t->read_from_remote = remote_read;
+    t->write_to_remote = remote_write;
+    t->sfd = s;
+    t->sync_token = 1;
+    t->connection_state = CS_OFFLINE;
+    t->type = kTransportLocal;
+    t->adb_port = 0;
+
+#if ADB_HOST
+    if (HOST && local) {
+        adb_mutex_lock( &local_transports_lock );
+        {
+            t->adb_port = adb_port;
+            atransport* existing_transport =
+                    find_emulator_transport_by_adb_port_locked(adb_port);
+            int index = get_available_local_transport_index_locked();
+            if (existing_transport != NULL) {
+                D("local transport for port %d already registered (%p)?\n",
+                adb_port, existing_transport);
+                fail = -1;
+            } else if (index < 0) {
+                // Too many emulators.
+                D("cannot register more emulators. Maximum is %d\n",
+                        ADB_LOCAL_TRANSPORT_MAX);
+                fail = -1;
+            } else {
+                local_transports[index] = t;
+            }
+       }
+       adb_mutex_unlock( &local_transports_lock );
+    }
+#endif
+    return fail;
+}
diff --git a/prebuilt/rebootrecovery.sh b/prebuilt/rebootrecovery.sh
new file mode 100644
index 0000000..11810aa
--- /dev/null
+++ b/prebuilt/rebootrecovery.sh
@@ -0,0 +1,2 @@
+#/sbin/sh
+touch /cache/recovery/boot
